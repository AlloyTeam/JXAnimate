<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>jquery-ui.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/JXAnimation.Audio.html">JXAnimation.Audio</a></li>
            
                <li><a href="../classes/Log.html">Log</a></li>
            
                <li><a href="../classes/Tab.html">Tab</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/JXAnimate.Audio.html">JXAnimate.Audio</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: jquery-ui.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*! jQuery UI - v1.9.1 - 2012-10-25
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.sortable.js, jquery.ui.effect.js, jquery.ui.accordion.js, jquery.ui.autocomplete.js, jquery.ui.button.js, jquery.ui.datepicker.js, jquery.ui.dialog.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js, jquery.ui.menu.js, jquery.ui.position.js, jquery.ui.progressbar.js, jquery.ui.slider.js, jquery.ui.spinner.js, jquery.ui.tabs.js, jquery.ui.tooltip.js
* Copyright 2012 jQuery Foundation and other contributors; Licensed MIT */

(function( $, undefined ) {

var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

// prevent duplicate loading
// this is only a problem because we proxy existing functions
// and we don&#x27;t want to double proxy them
$.ui = $.ui || {};
if ( $.ui.version ) {
	return;
}

$.extend( $.ui, {
	version: &quot;1.9.1&quot;,

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	_focus: $.fn.focus,
	focus: function( delay, fn ) {
		return typeof delay === &quot;number&quot; ?
			this.each(function() {
				var elem = this;
				setTimeout(function() {
					$( elem ).focus();
					if ( fn ) {
						fn.call( elem );
					}
				}, delay );
			}) :
			this._focus.apply( this, arguments );
	},

	scrollParent: function() {
		var scrollParent;
		if (($.ui.ie &amp;&amp; (/(static|relative)/).test(this.css(&#x27;position&#x27;))) || (/absolute/).test(this.css(&#x27;position&#x27;))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.css(this,&#x27;position&#x27;)) &amp;&amp; (/(auto|scroll)/).test($.css(this,&#x27;overflow&#x27;)+$.css(this,&#x27;overflow-y&#x27;)+$.css(this,&#x27;overflow-x&#x27;));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.css(this,&#x27;overflow&#x27;)+$.css(this,&#x27;overflow-y&#x27;)+$.css(this,&#x27;overflow-x&#x27;));
			}).eq(0);
		}

		return (/fixed/).test(this.css(&#x27;position&#x27;)) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( &quot;zIndex&quot;, zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length &amp;&amp; elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( &quot;position&quot; );
				if ( position === &quot;absolute&quot; || position === &quot;relative&quot; || position === &quot;fixed&quot; ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// &lt;div style=&quot;z-index: -10;&quot;&gt;&lt;div style=&quot;z-index: 0;&quot;&gt;&lt;/div&gt;&lt;/div&gt;
					value = parseInt( elem.css( &quot;zIndex&quot; ), 10 );
					if ( !isNaN( value ) &amp;&amp; value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = &quot;ui-id-&quot; + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( &quot;id&quot; );
			}
		});
	}
});

// support: jQuery &lt;1.8
if ( !$( &quot;&lt;a&gt;&quot; ).outerWidth( 1 ).jquery ) {
	$.each( [ &quot;Width&quot;, &quot;Height&quot; ], function( i, name ) {
		var side = name === &quot;Width&quot; ? [ &quot;Left&quot;, &quot;Right&quot; ] : [ &quot;Top&quot;, &quot;Bottom&quot; ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, &quot;padding&quot; + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, &quot;border&quot; + this + &quot;Width&quot; ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, &quot;margin&quot; + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ &quot;inner&quot; + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ &quot;inner&quot; + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + &quot;px&quot; );
			});
		};

		$.fn[ &quot;outer&quot; + name] = function( size, margin ) {
			if ( typeof size !== &quot;number&quot; ) {
				return orig[ &quot;outer&quot; + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + &quot;px&quot; );
			});
		};
	});
}

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( &quot;area&quot; === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== &quot;map&quot; ) {
			return false;
		}
		img = $( &quot;img[usemap=#&quot; + mapName + &quot;]&quot; )[0];
		return !!img &amp;&amp; visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		&quot;a&quot; === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &amp;&amp;
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &amp;&amp;
		!$( element ).parents().andSelf().filter(function() {
			return $.css( this, &quot;visibility&quot; ) === &quot;hidden&quot;;
		}).length;
}

$.extend( $.expr[ &quot;:&quot; ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery &lt;1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, &quot;tabindex&quot; ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, &quot;tabindex&quot; ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex &gt;= 0 ) &amp;&amp; focusable( element, !isTabIndexNaN );
	}
});

// support
$(function() {
	var body = document.body,
		div = body.appendChild( div = document.createElement( &quot;div&quot; ) );

	// access offsetHeight before setting the style to prevent a layout bug
	// in IE 9 which causes the element to continue to take up space even
	// after it is removed from the DOM (#8026)
	div.offsetHeight;

	$.extend( div.style, {
		minHeight: &quot;100px&quot;,
		height: &quot;auto&quot;,
		padding: 0,
		borderWidth: 0
	});

	$.support.minHeight = div.offsetHeight === 100;
	$.support.selectstart = &quot;onselectstart&quot; in div;

	// set display to none to avoid a layout bug in IE
	// http://dev.jquery.com/ticket/4014
	body.removeChild( div ).style.display = &quot;none&quot;;
});





// deprecated

(function() {
	var uaMatch = /msie ([\w.]+)/.exec( navigator.userAgent.toLowerCase() ) || [];
	$.ui.ie = uaMatch.length ? true : false;
	$.ui.ie6 = parseFloat( uaMatch[ 1 ], 10 ) === 6;
})();

$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? &quot;selectstart&quot; : &quot;mousedown&quot; ) +
			&quot;.ui-disableSelection&quot;, function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( &quot;.ui-disableSelection&quot; );
	}
});

$.extend( $.ui, {
	// $.ui.plugin is deprecated.  Use the proxy pattern instead.
	plugin: {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var i,
				set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
				return;
			}

			for ( i = 0; i &lt; set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	contains: $.contains,

	// only used by resizable
	hasScroll: function( el, a ) {

		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( &quot;overflow&quot; ) === &quot;hidden&quot;) {
			return false;
		}

		var scroll = ( a &amp;&amp; a === &quot;left&quot; ) ? &quot;scrollLeft&quot; : &quot;scrollTop&quot;,
			has = false;

		if ( el[ scroll ] &gt; 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn&#x27;t have the scroll set, see if it&#x27;s possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] &gt; 0 );
		el[ scroll ] = 0;
		return has;
	},

	// these are odd functions, fix the API or move into individual plugins
	isOverAxis: function( x, reference, size ) {
		//Determines when x coordinate is over &quot;b&quot; element axis
		return ( x &gt; reference ) &amp;&amp; ( x &lt; ( reference + size ) );
	},
	isOver: function( y, x, top, left, height, width ) {
		//Determines when x, y coordinates is over &quot;b&quot; element
		return $.ui.isOverAxis( y, top, height ) &amp;&amp; $.ui.isOverAxis( x, left, width );
	}
});

})( jQuery );

(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( &quot;remove&quot; );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		namespace = name.split( &quot;.&quot; )[ 0 ];

	name = name.split( &quot;.&quot; )[ 1 ];
	fullName = namespace + &quot;-&quot; + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ &quot;:&quot; ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without &quot;new&quot; keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use &quot;new&quot; keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we&#x27;ll modify the options hash on the prototype that we&#x27;re
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( $.isFunction( value ) ) {
			prototype[ prop ] = (function() {
				var _super = function() {
						return base.prototype[ prop ].apply( this, arguments );
					},
					_superApply = function( args ) {
						return base.prototype[ prop ].apply( this, args );
					};
				return function() {
					var __super = this._super,
						__superApply = this._superApply,
						returnValue;

					this._super = _super;
					this._superApply = _superApply;

					returnValue = value.apply( this, arguments );

					this._super = __super;
					this._superApply = __superApply;

					return returnValue;
				};
			})();
		}
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don&#x27;t prefix for widgets that aren&#x27;t DOM-based
		widgetEventPrefix: basePrototype.widgetEventPrefix || name
	}, prototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		// TODO remove widgetBaseClass, see #8155
		widgetBaseClass: fullName,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We&#x27;re essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + &quot;.&quot; + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex &lt; inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) &amp;&amp; value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don&#x27;t extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === &quot;string&quot;,
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall &amp;&amp; args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( &quot;cannot call methods on &quot; + name + &quot; prior to initialization; &quot; +
						&quot;attempted to call method &#x27;&quot; + options + &quot;&#x27;&quot; );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === &quot;_&quot; ) {
					return $.error( &quot;no such method &#x27;&quot; + options + &quot;&#x27; for &quot; + name + &quot; widget instance&quot; );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance &amp;&amp; methodValue !== undefined ) {
					returnValue = methodValue &amp;&amp; methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					new object( options, this );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: &quot;widget&quot;,
	widgetEventPrefix: &quot;&quot;,
	defaultElement: &quot;&lt;div&gt;&quot;,
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = &quot;.&quot; + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			// 1.9 BC for #7810
			// TODO remove dual storage
			$.data( element, this.widgetName, this );
			$.data( element, this.widgetFullName, this );
			this._on( this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( &quot;create&quot;, null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery &lt;1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( &quot;aria-disabled&quot; )
			.removeClass(
				this.widgetFullName + &quot;-disabled &quot; +
				&quot;ui-state-disabled&quot; );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( &quot;ui-state-hover&quot; );
		this.focusable.removeClass( &quot;ui-state-focus&quot; );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don&#x27;t return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === &quot;string&quot; ) {
			// handle nested keys, e.g., &quot;foo.bar&quot; =&gt; { foo: { bar: ___ } }
			options = {};
			parts = key.split( &quot;.&quot; );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i &lt; parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( value === undefined ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( value === undefined ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === &quot;disabled&quot; ) {
			this.widget()
				.toggleClass( this.widgetFullName + &quot;-disabled ui-state-disabled&quot;, !!value )
				.attr( &quot;aria-disabled&quot;, value );
			this.hoverable.removeClass( &quot;ui-state-hover&quot; );
			this.focusable.removeClass( &quot;ui-state-focus&quot; );
		}

		return this;
	},

	enable: function() {
		return this._setOption( &quot;disabled&quot;, false );
	},
	disable: function() {
		return this._setOption( &quot;disabled&quot;, true );
	},

	_on: function( element, handlers ) {
		var delegateElement,
			instance = this;
		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( instance.options.disabled === true ||
						$( this ).hasClass( &quot;ui-state-disabled&quot; ) ) {
					return;
				}
				return ( typeof handler === &quot;string&quot; ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== &quot;string&quot; ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || &quot;&quot;).split( &quot; &quot; ).join( this.eventNamespace + &quot; &quot; ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === &quot;string&quot; ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( &quot;ui-state-hover&quot; );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( &quot;ui-state-hover&quot; );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( &quot;ui-state-focus&quot; );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( &quot;ui-state-focus&quot; );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &amp;&amp;
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: &quot;fadeIn&quot;, hide: &quot;fadeOut&quot; }, function( method, defaultEffect ) {
	$.Widget.prototype[ &quot;_&quot; + method ] = function( element, options, callback ) {
		if ( typeof options === &quot;string&quot; ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === &quot;number&quot; ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === &quot;number&quot; ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions &amp;&amp; $.effects &amp;&amp; ( $.effects.effect[ effectName ] || $.uiBackCompat !== false &amp;&amp; $.effects[ effectName ] ) ) {
			element[ method ]( options );
		} else if ( effectName !== method &amp;&amp; element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

// DEPRECATED
if ( $.uiBackCompat !== false ) {
	$.Widget.prototype._getCreateOptions = function() {
		return $.metadata &amp;&amp; $.metadata.get( this.element[0] )[ this.widgetName ];
	};
}

})( jQuery );

(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function( e ) {
	mouseHandled = false;
});

$.widget(&quot;ui.mouse&quot;, {
	version: &quot;1.9.1&quot;,
	options: {
		cancel: &#x27;input,textarea,button,select,option&#x27;,
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind(&#x27;mousedown.&#x27;+this.widgetName, function(event) {
				return that._mouseDown(event);
			})
			.bind(&#x27;click.&#x27;+this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + &#x27;.preventClickEvent&#x27;)) {
					$.removeData(event.target, that.widgetName + &#x27;.preventClickEvent&#x27;);
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn&#x27;t mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind(&#x27;.&#x27;+this.widgetName);
		if ( this._mouseMoveDelegate ) {
			$(document)
				.unbind(&#x27;mousemove.&#x27;+this.widgetName, this._mouseMoveDelegate)
				.unbind(&#x27;mouseup.&#x27;+this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don&#x27;t let more than one widget handle mouseStart
		if( mouseHandled ) { return; }

		// we may have missed mouseup (out of window)
		(this._mouseStarted &amp;&amp; this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === &quot;string&quot; &amp;&amp; event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) &amp;&amp; this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko &amp; Opera)
		if (true === $.data(event.target, this.widgetName + &#x27;.preventClickEvent&#x27;)) {
			$.removeData(event.target, this.widgetName + &#x27;.preventClickEvent&#x27;);
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};
		$(document)
			.bind(&#x27;mousemove.&#x27;+this.widgetName, this._mouseMoveDelegate)
			.bind(&#x27;mouseup.&#x27;+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.ui.ie &amp;&amp; !(document.documentMode &gt;= 9) &amp;&amp; !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) &amp;&amp; this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind(&#x27;mousemove.&#x27;+this.widgetName, this._mouseMoveDelegate)
			.unbind(&#x27;mouseup.&#x27;+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + &#x27;.preventClickEvent&#x27;, true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) &gt;= this.options.distance
		);
	},

	_mouseDelayMet: function(event) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(event) {},
	_mouseDrag: function(event) {},
	_mouseStop: function(event) {},
	_mouseCapture: function(event) { return true; }
});

})(jQuery);

(function( $, undefined ) {

$.widget(&quot;ui.draggable&quot;, $.ui.mouse, {
	version: &quot;1.9.1&quot;,
	widgetEventPrefix: &quot;drag&quot;,
	options: {
		addClasses: true,
		appendTo: &quot;parent&quot;,
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: &quot;auto&quot;,
		cursorAt: false,
		grid: false,
		handle: false,
		helper: &quot;original&quot;,
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: &quot;default&quot;,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: &quot;both&quot;,
		snapTolerance: 20,
		stack: false,
		zIndex: false
	},
	_create: function() {

		if (this.options.helper == &#x27;original&#x27; &amp;&amp; !(/^(?:r|a|f)/).test(this.element.css(&quot;position&quot;)))
			this.element[0].style.position = &#x27;relative&#x27;;

		(this.options.addClasses &amp;&amp; this.element.addClass(&quot;ui-draggable&quot;));
		(this.options.disabled &amp;&amp; this.element.addClass(&quot;ui-draggable-disabled&quot;));

		this._mouseInit();

	},

	_destroy: function() {
		this.element.removeClass( &quot;ui-draggable ui-draggable-dragging ui-draggable-disabled&quot; );
		this._mouseDestroy();
	},

	_mouseCapture: function(event) {

		var o = this.options;

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).is(&#x27;.ui-resizable-handle&#x27;))
			return false;

		//Quit if we&#x27;re not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle)
			return false;

		$(o.iframeFix === true ? &quot;iframe&quot; : o.iframeFix).each(function() {
			$(&#x27;&lt;div class=&quot;ui-draggable-iframeFix&quot; style=&quot;background: #fff;&quot;&gt;&lt;/div&gt;&#x27;)
			.css({
				width: this.offsetWidth+&quot;px&quot;, height: this.offsetHeight+&quot;px&quot;,
				position: &quot;absolute&quot;, opacity: &quot;0.001&quot;, zIndex: 1000
			})
			.css($(this).offset())
			.appendTo(&quot;body&quot;);
		});

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass(&quot;ui-draggable-dragging&quot;);

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		/*
		 * - Position generation -
		 * This block generates everything position related - it&#x27;s the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper&#x27;s css position
		this.cssPosition = this.helper.css(&quot;position&quot;);
		this.scrollParent = this.helper.scrollParent();

		//The element&#x27;s absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if &#x27;cursorAt&#x27; is supplied
		(o.cursorAt &amp;&amp; this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		//Trigger event + callbacks
		if(this._trigger(&quot;start&quot;, event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager &amp;&amp; !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);


		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) $.ui.ddmanager.dragStart(this, event);

		return true;
	},

	_mouseDrag: function(event, noPropagation) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo(&quot;absolute&quot;);

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if(this._trigger(&#x27;drag&#x27;, event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		if(!this.options.axis || this.options.axis != &quot;y&quot;) this.helper[0].style.left = this.position.left+&#x27;px&#x27;;
		if(!this.options.axis || this.options.axis != &quot;x&quot;) this.helper[0].style.top = this.position.top+&#x27;px&#x27;;
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var dropped = false;
		if ($.ui.ddmanager &amp;&amp; !this.options.dropBehaviour)
			dropped = $.ui.ddmanager.drop(this, event);

		//if a drop comes from outside (a sortable)
		if(this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}

		//if the original element is no longer in the DOM don&#x27;t bother to continue (see #8269)
		var element = this.element[0], elementInDom = false;
		while ( element &amp;&amp; (element = element.parentNode) ) {
			if (element == document ) {
				elementInDom = true;
			}
		}
		if ( !elementInDom &amp;&amp; this.options.helper === &quot;original&quot; )
			return false;

		if((this.options.revert == &quot;invalid&quot; &amp;&amp; !dropped) || (this.options.revert == &quot;valid&quot; &amp;&amp; dropped) || this.options.revert === true || ($.isFunction(this.options.revert) &amp;&amp; this.options.revert.call(this.element, dropped))) {
			var that = this;
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if(that._trigger(&quot;stop&quot;, event) !== false) {
					that._clear();
				}
			});
		} else {
			if(this._trigger(&quot;stop&quot;, event) !== false) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function(event) {
		//Remove frame helpers
		$(&quot;div.ui-draggable-iframeFix&quot;).each(function() {
			this.parentNode.removeChild(this);
		});

		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if( $.ui.ddmanager ) $.ui.ddmanager.dragStop(this, event);

		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},

	cancel: function() {

		if(this.helper.is(&quot;.ui-draggable-dragging&quot;)) {
			this._mouseUp({});
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function(event) {

		var handle = !this.options.handle || !$(this.options.handle, this.element).length ? true : false;
		$(this.options.handle, this.element)
			.find(&quot;*&quot;)
			.andSelf()
			.each(function() {
				if(this == event.target) handle = true;
			});

		return handle;

	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper == &#x27;clone&#x27; ? this.element.clone().removeAttr(&#x27;id&#x27;) : this.element);

		if(!helper.parents(&#x27;body&#x27;).length)
			helper.appendTo((o.appendTo == &#x27;parent&#x27; ? this.element[0].parentNode : o.appendTo));

		if(helper[0] != this.element[0] &amp;&amp; !(/(fixed|absolute)/).test(helper.css(&quot;position&quot;)))
			helper.css(&quot;position&quot;, &quot;absolute&quot;);

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == &#x27;string&#x27;) {
			obj = obj.split(&#x27; &#x27;);
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if (&#x27;left&#x27; in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if (&#x27;right&#x27; in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if (&#x27;top&#x27; in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if (&#x27;bottom&#x27; in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it&#x27;s position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn&#x27;t the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == &#x27;absolute&#x27; &amp;&amp; this.scrollParent[0] != document &amp;&amp; $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
		|| (this.offsetParent[0].tagName &amp;&amp; this.offsetParent[0].tagName.toLowerCase() == &#x27;html&#x27; &amp;&amp; $.ui.ie)) //Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css(&quot;borderTopWidth&quot;),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css(&quot;borderLeftWidth&quot;),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == &quot;relative&quot;) {
			var p = this.element.position();
			return {
				top: p.top - (parseInt(this.helper.css(&quot;top&quot;),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css(&quot;left&quot;),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css(&quot;marginLeft&quot;),10) || 0),
			top: (parseInt(this.element.css(&quot;marginTop&quot;),10) || 0),
			right: (parseInt(this.element.css(&quot;marginRight&quot;),10) || 0),
			bottom: (parseInt(this.element.css(&quot;marginBottom&quot;),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == &#x27;parent&#x27;) o.containment = this.helper[0].parentNode;
		if(o.containment == &#x27;document&#x27; || o.containment == &#x27;window&#x27;) this.containment = [
			o.containment == &#x27;document&#x27; ? 0 : $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
			o.containment == &#x27;document&#x27; ? 0 : $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
			(o.containment == &#x27;document&#x27; ? 0 : $(window).scrollLeft()) + $(o.containment == &#x27;document&#x27; ? document : window).width() - this.helperProportions.width - this.margins.left,
			(o.containment == &#x27;document&#x27; ? 0 : $(window).scrollTop()) + ($(o.containment == &#x27;document&#x27; ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(/^(document|window|parent)$/).test(o.containment) &amp;&amp; o.containment.constructor != Array) {
			var c = $(o.containment);
			var ce = c[0]; if(!ce) return;
			var co = c.offset();
			var over = ($(ce).css(&quot;overflow&quot;) != &#x27;hidden&#x27;);

			this.containment = [
				(parseInt($(ce).css(&quot;borderLeftWidth&quot;),10) || 0) + (parseInt($(ce).css(&quot;paddingLeft&quot;),10) || 0),
				(parseInt($(ce).css(&quot;borderTopWidth&quot;),10) || 0) + (parseInt($(ce).css(&quot;paddingTop&quot;),10) || 0),
				(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css(&quot;borderLeftWidth&quot;),10) || 0) - (parseInt($(ce).css(&quot;paddingRight&quot;),10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,
				(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css(&quot;borderTopWidth&quot;),10) || 0) - (parseInt($(ce).css(&quot;paddingBottom&quot;),10) || 0) - this.helperProportions.height - this.margins.top  - this.margins.bottom
			];
			this.relative_container = c;

		} else if(o.containment.constructor == Array) {
			this.containment = o.containment;
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == &quot;absolute&quot; ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == &#x27;absolute&#x27; &amp;&amp; !(this.scrollParent[0] != document &amp;&amp; $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	// The absolute mouse position
				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											// The offsetParent&#x27;s offset without borders (offset + border)
				- ( ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																// The absolute mouse position
				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											// The offsetParent&#x27;s offset without borders (offset + border)
				- ( ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == &#x27;absolute&#x27; &amp;&amp; !(this.scrollParent[0] != document &amp;&amp; $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
		var pageX = event.pageX;
		var pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won&#x27;t check for options
			var containment;
			if(this.containment) {
			if (this.relative_container){
				var co = this.relative_container.offset();
				containment = [ this.containment[0] + co.left,
					this.containment[1] + co.top,
					this.containment[2] + co.left,
					this.containment[3] + co.top ];
			}
			else {
				containment = this.containment;
			}

				if(event.pageX - this.offset.click.left &lt; containment[0]) pageX = containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top &lt; containment[1]) pageY = containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left &gt; containment[2]) pageX = containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top &gt; containment[3]) pageY = containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				var top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? (!(top - this.offset.click.top &lt; containment[1] || top - this.offset.click.top &gt; containment[3]) ? top : (!(top - this.offset.click.top &lt; containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? (!(left - this.offset.click.left &lt; containment[0] || left - this.offset.click.left &gt; containment[2]) ? left : (!(left - this.offset.click.left &lt; containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																// The absolute mouse position
				- this.offset.click.top													// Click offset (relative to the element)
				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												// The offsetParent&#x27;s offset without borders (offset + border)
				+ ( ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																// The absolute mouse position
				- this.offset.click.left												// Click offset (relative to the element)
				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												// The offsetParent&#x27;s offset without borders (offset + border)
				+ ( ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_clear: function() {
		this.helper.removeClass(&quot;ui-draggable-dragging&quot;);
		if(this.helper[0] != this.element[0] &amp;&amp; !this.cancelHelperRemoval) this.helper.remove();
		//if($.ui.ddmanager) $.ui.ddmanager.current = null;
		this.helper = null;
		this.cancelHelperRemoval = false;
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call(this, type, [event, ui]);
		if(type == &quot;drag&quot;) this.positionAbs = this._convertPositionTo(&quot;absolute&quot;); //The absolute position has to be recalculated after plugins
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function(event) {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.ui.plugin.add(&quot;draggable&quot;, &quot;connectToSortable&quot;, {
	start: function(event, ui) {

		var inst = $(this).data(&quot;draggable&quot;), o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $.data(this, &#x27;sortable&#x27;);
			if (sortable &amp;&amp; !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	// Call the sortable&#x27;s refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it&#x27;s initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger(&quot;activate&quot;, event, uiSortable);
			}
		});

	},
	stop: function(event, ui) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var inst = $(this).data(&quot;draggable&quot;),
			uiSortable = $.extend({}, ui, { item: inst.element });

		$.each(inst.sortables, function() {
			if(this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don&#x27;t remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: &#x27;valid/invalid&#x27;
				if(this.shouldRevert) this.instance.options.revert = true;

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if(inst.options.helper == &#x27;original&#x27;)
					this.instance.currentItem.css({ top: &#x27;auto&#x27;, left: &#x27;auto&#x27; });

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger(&quot;deactivate&quot;, event, uiSortable);
			}

		});

	},
	drag: function(event, ui) {

		var inst = $(this).data(&quot;draggable&quot;), that = this;

		var checkPos = function(o) {
			var dyClick = this.offset.click.top, dxClick = this.offset.click.left;
			var helperTop = this.positionAbs.top, helperLeft = this.positionAbs.left;
			var itemHeight = o.height, itemWidth = o.width;
			var itemTop = o.top, itemLeft = o.left;

			return $.ui.isOver(helperTop + dyClick, helperLeft + dxClick, itemTop, itemLeft, itemHeight, itemWidth);
		};

		$.each(inst.sortables, function(i) {

			var innermostIntersecting = false;
			var thisSortable = this;
			//Copy over some variables to allow calling the sortable&#x27;s native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;

			if(this.instance._intersectsWith(this.instance.containerCache)) {
				innermostIntersecting = true;
				$.each(inst.sortables, function () {
					this.instance.positionAbs = inst.positionAbs;
					this.instance.helperProportions = inst.helperProportions;
					this.instance.offset.click = inst.offset.click;
					if  (this != thisSortable
						&amp;&amp; this.instance._intersectsWith(this.instance.containerCache)
						&amp;&amp; $.ui.contains(thisSortable.instance.element[0], this.instance.element[0]))
						innermostIntersecting = false;
						return innermostIntersecting;
				});
			}


			if(innermostIntersecting) {
				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if(!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn&#x27;t create a new one)
					this.instance.currentItem = $(that).clone().removeAttr(&#x27;id&#x27;).appendTo(this.instance.element).data(&quot;sortable-item&quot;, true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger(&quot;toSortable&quot;, event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if(this.instance.currentItem) this.instance._mouseDrag(event);

			} else {

				//If it doesn&#x27;t intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn&#x27;t remove the helper by using cancelHelperRemoval
				if(this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;

					//Prevent reverting on this forced stop
					this.instance.options.revert = false;

					// The out event needs to be triggered independently
					this.instance._trigger(&#x27;out&#x27;, event, this.instance._uiHash(this.instance));

					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it&#x27;s original size
					this.instance.currentItem.remove();
					if(this.instance.placeholder) this.instance.placeholder.remove();

					inst._trigger(&quot;fromSortable&quot;, event);
					inst.dropped = false; //draggable revert needs that
				}

			};

		});

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;cursor&quot;, {
	start: function(event, ui) {
		var t = $(&#x27;body&#x27;), o = $(this).data(&#x27;draggable&#x27;).options;
		if (t.css(&quot;cursor&quot;)) o._cursor = t.css(&quot;cursor&quot;);
		t.css(&quot;cursor&quot;, o.cursor);
	},
	stop: function(event, ui) {
		var o = $(this).data(&#x27;draggable&#x27;).options;
		if (o._cursor) $(&#x27;body&#x27;).css(&quot;cursor&quot;, o._cursor);
	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;opacity&quot;, {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data(&#x27;draggable&#x27;).options;
		if(t.css(&quot;opacity&quot;)) o._opacity = t.css(&quot;opacity&quot;);
		t.css(&#x27;opacity&#x27;, o.opacity);
	},
	stop: function(event, ui) {
		var o = $(this).data(&#x27;draggable&#x27;).options;
		if(o._opacity) $(ui.helper).css(&#x27;opacity&#x27;, o._opacity);
	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;scroll&quot;, {
	start: function(event, ui) {
		var i = $(this).data(&quot;draggable&quot;);
		if(i.scrollParent[0] != document &amp;&amp; i.scrollParent[0].tagName != &#x27;HTML&#x27;) i.overflowOffset = i.scrollParent.offset();
	},
	drag: function(event, ui) {

		var i = $(this).data(&quot;draggable&quot;), o = i.options, scrolled = false;

		if(i.scrollParent[0] != document &amp;&amp; i.scrollParent[0].tagName != &#x27;HTML&#x27;) {

			if(!o.axis || o.axis != &#x27;x&#x27;) {
				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY &lt; o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - i.overflowOffset.top &lt; o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
			}

			if(!o.axis || o.axis != &#x27;y&#x27;) {
				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX &lt; o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - i.overflowOffset.left &lt; o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
			}

		} else {

			if(!o.axis || o.axis != &#x27;x&#x27;) {
				if(event.pageY - $(document).scrollTop() &lt; o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) &lt; o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
			}

			if(!o.axis || o.axis != &#x27;y&#x27;) {
				if(event.pageX - $(document).scrollLeft() &lt; o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) &lt; o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
			}

		}

		if(scrolled !== false &amp;&amp; $.ui.ddmanager &amp;&amp; !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(i, event);

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;snap&quot;, {
	start: function(event, ui) {

		var i = $(this).data(&quot;draggable&quot;), o = i.options;
		i.snapElements = [];

		$(o.snap.constructor != String ? ( o.snap.items || &#x27;:data(draggable)&#x27; ) : o.snap).each(function() {
			var $t = $(this); var $o = $t.offset();
			if(this != i.element[0]) i.snapElements.push({
				item: this,
				width: $t.outerWidth(), height: $t.outerHeight(),
				top: $o.top, left: $o.left
			});
		});

	},
	drag: function(event, ui) {

		var inst = $(this).data(&quot;draggable&quot;), o = inst.options;
		var d = o.snapTolerance;

		var x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (var i = inst.snapElements.length - 1; i &gt;= 0; i--){

			var l = inst.snapElements[i].left, r = l + inst.snapElements[i].width,
				t = inst.snapElements[i].top, b = t + inst.snapElements[i].height;

			//Yes, I know, this is insane ;)
			if(!((l-d &lt; x1 &amp;&amp; x1 &lt; r+d &amp;&amp; t-d &lt; y1 &amp;&amp; y1 &lt; b+d) || (l-d &lt; x1 &amp;&amp; x1 &lt; r+d &amp;&amp; t-d &lt; y2 &amp;&amp; y2 &lt; b+d) || (l-d &lt; x2 &amp;&amp; x2 &lt; r+d &amp;&amp; t-d &lt; y1 &amp;&amp; y1 &lt; b+d) || (l-d &lt; x2 &amp;&amp; x2 &lt; r+d &amp;&amp; t-d &lt; y2 &amp;&amp; y2 &lt; b+d))) {
				if(inst.snapElements[i].snapping) (inst.options.snap.release &amp;&amp; inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				inst.snapElements[i].snapping = false;
				continue;
			}

			if(o.snapMode != &#x27;inner&#x27;) {
				var ts = Math.abs(t - y2) &lt;= d;
				var bs = Math.abs(b - y1) &lt;= d;
				var ls = Math.abs(l - x2) &lt;= d;
				var rs = Math.abs(r - x1) &lt;= d;
				if(ts) ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: b, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: r }).left - inst.margins.left;
			}

			var first = (ts || bs || ls || rs);

			if(o.snapMode != &#x27;outer&#x27;) {
				var ts = Math.abs(t - y1) &lt;= d;
				var bs = Math.abs(b - y2) &lt;= d;
				var ls = Math.abs(l - x1) &lt;= d;
				var rs = Math.abs(r - x2) &lt;= d;
				if(ts) ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: t, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: l }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
			}

			if(!inst.snapElements[i].snapping &amp;&amp; (ts || bs || ls || rs || first))
				(inst.options.snap.snap &amp;&amp; inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		};

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;stack&quot;, {
	start: function(event, ui) {

		var o = $(this).data(&quot;draggable&quot;).options;

		var group = $.makeArray($(o.stack)).sort(function(a,b) {
			return (parseInt($(a).css(&quot;zIndex&quot;),10) || 0) - (parseInt($(b).css(&quot;zIndex&quot;),10) || 0);
		});
		if (!group.length) { return; }

		var min = parseInt(group[0].style.zIndex) || 0;
		$(group).each(function(i) {
			this.style.zIndex = min + i;
		});

		this[0].style.zIndex = min + group.length;

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;zIndex&quot;, {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data(&quot;draggable&quot;).options;
		if(t.css(&quot;zIndex&quot;)) o._zIndex = t.css(&quot;zIndex&quot;);
		t.css(&#x27;zIndex&#x27;, o.zIndex);
	},
	stop: function(event, ui) {
		var o = $(this).data(&quot;draggable&quot;).options;
		if(o._zIndex) $(ui.helper).css(&#x27;zIndex&#x27;, o._zIndex);
	}
});

})(jQuery);

(function( $, undefined ) {

$.widget(&quot;ui.droppable&quot;, {
	version: &quot;1.9.1&quot;,
	widgetEventPrefix: &quot;drop&quot;,
	options: {
		accept: &#x27;*&#x27;,
		activeClass: false,
		addClasses: true,
		greedy: false,
		hoverClass: false,
		scope: &#x27;default&#x27;,
		tolerance: &#x27;intersect&#x27;
	},
	_create: function() {

		var o = this.options, accept = o.accept;
		this.isover = 0; this.isout = 1;

		this.accept = $.isFunction(accept) ? accept : function(d) {
			return d.is(accept);
		};

		//Store the droppable&#x27;s proportions
		this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };

		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
		$.ui.ddmanager.droppables[o.scope].push(this);

		(o.addClasses &amp;&amp; this.element.addClass(&quot;ui-droppable&quot;));

	},

	_destroy: function() {
		var drop = $.ui.ddmanager.droppables[this.options.scope];
		for ( var i = 0; i &lt; drop.length; i++ )
			if ( drop[i] == this )
				drop.splice(i, 1);

		this.element.removeClass(&quot;ui-droppable ui-droppable-disabled&quot;);
	},

	_setOption: function(key, value) {

		if(key == &#x27;accept&#x27;) {
			this.accept = $.isFunction(value) ? value : function(d) {
				return d.is(value);
			};
		}
		$.Widget.prototype._setOption.apply(this, arguments);
	},

	_activate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.addClass(this.options.activeClass);
		(draggable &amp;&amp; this._trigger(&#x27;activate&#x27;, event, this.ui(draggable)));
	},

	_deactivate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
		(draggable &amp;&amp; this._trigger(&#x27;deactivate&#x27;, event, this.ui(draggable)));
	},

	_over: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.addClass(this.options.hoverClass);
			this._trigger(&#x27;over&#x27;, event, this.ui(draggable));
		}

	},

	_out: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger(&#x27;out&#x27;, event, this.ui(draggable));
		}

	},

	_drop: function(event,custom) {

		var draggable = custom || $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return false; // Bail if draggable and droppable are same element

		var childrenIntersection = false;
		this.element.find(&quot;:data(droppable)&quot;).not(&quot;.ui-draggable-dragging&quot;).each(function() {
			var inst = $.data(this, &#x27;droppable&#x27;);
			if(
				inst.options.greedy
				&amp;&amp; !inst.options.disabled
				&amp;&amp; inst.options.scope == draggable.options.scope
				&amp;&amp; inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element))
				&amp;&amp; $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
			) { childrenIntersection = true; return false; }
		});
		if(childrenIntersection) return false;

		if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger(&#x27;drop&#x27;, event, this.ui(draggable));
			return this.element;
		}

		return false;

	},

	ui: function(c) {
		return {
			draggable: (c.currentItem || c.element),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	}

});

$.ui.intersect = function(draggable, droppable, toleranceMode) {

	if (!droppable.offset) return false;

	var x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,
		y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height;
	var l = droppable.offset.left, r = l + droppable.proportions.width,
		t = droppable.offset.top, b = t + droppable.proportions.height;

	switch (toleranceMode) {
		case &#x27;fit&#x27;:
			return (l &lt;= x1 &amp;&amp; x2 &lt;= r
				&amp;&amp; t &lt;= y1 &amp;&amp; y2 &lt;= b);
			break;
		case &#x27;intersect&#x27;:
			return (l &lt; x1 + (draggable.helperProportions.width / 2) // Right Half
				&amp;&amp; x2 - (draggable.helperProportions.width / 2) &lt; r // Left Half
				&amp;&amp; t &lt; y1 + (draggable.helperProportions.height / 2) // Bottom Half
				&amp;&amp; y2 - (draggable.helperProportions.height / 2) &lt; b ); // Top Half
			break;
		case &#x27;pointer&#x27;:
			var draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left),
				draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top),
				isOver = $.ui.isOver(draggableTop, draggableLeft, t, l, droppable.proportions.height, droppable.proportions.width);
			return isOver;
			break;
		case &#x27;touch&#x27;:
			return (
					(y1 &gt;= t &amp;&amp; y1 &lt;= b) ||	// Top edge touching
					(y2 &gt;= t &amp;&amp; y2 &lt;= b) ||	// Bottom edge touching
					(y1 &lt; t &amp;&amp; y2 &gt; b)		// Surrounded vertically
				) &amp;&amp; (
					(x1 &gt;= l &amp;&amp; x1 &lt;= r) ||	// Left edge touching
					(x2 &gt;= l &amp;&amp; x2 &lt;= r) ||	// Right edge touching
					(x1 &lt; l &amp;&amp; x2 &gt; r)		// Surrounded horizontally
				);
			break;
		default:
			return false;
			break;
		}

};

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { &#x27;default&#x27;: [] },
	prepareOffsets: function(t, event) {

		var m = $.ui.ddmanager.droppables[t.options.scope] || [];
		var type = event ? event.type : null; // workaround for #2317
		var list = (t.currentItem || t.element).find(&quot;:data(droppable)&quot;).andSelf();

		droppablesLoop: for (var i = 0; i &lt; m.length; i++) {

			if(m[i].options.disabled || (t &amp;&amp; !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) continue;	//No disabled and non-accepted
			for (var j=0; j &lt; list.length; j++) { if(list[j] == m[i].element[0]) { m[i].proportions.height = 0; continue droppablesLoop; } }; //Filter out elements in the current dragged item
			m[i].visible = m[i].element.css(&quot;display&quot;) != &quot;none&quot;; if(!m[i].visible) continue; 									//If the element is not visible, continue

			if(type == &quot;mousedown&quot;) m[i]._activate.call(m[i], event); //Activate the droppable if used directly from draggables

			m[i].offset = m[i].element.offset();
			m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };

		}

	},
	drop: function(draggable, event) {

		var dropped = false;
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(!this.options) return;
			if (!this.options.disabled &amp;&amp; this.visible &amp;&amp; $.ui.intersect(draggable, this, this.options.tolerance))
				dropped = this._drop.call(this, event) || dropped;

			if (!this.options.disabled &amp;&amp; this.visible &amp;&amp; this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				this.isout = 1; this.isover = 0;
				this._deactivate.call(this, event);
			}

		});
		return dropped;

	},
	dragStart: function( draggable, event ) {
		//Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
		draggable.element.parentsUntil( &quot;body&quot; ).bind( &quot;scroll.droppable&quot;, function() {
			if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
		});
	},
	drag: function(draggable, event) {

		//If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
		if(draggable.options.refreshPositions) $.ui.ddmanager.prepareOffsets(draggable, event);

		//Run through all droppables and check their positions based on specific tolerance options
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(this.options.disabled || this.greedyChild || !this.visible) return;
			var intersects = $.ui.intersect(draggable, this, this.options.tolerance);

			var c = !intersects &amp;&amp; this.isover == 1 ? &#x27;isout&#x27; : (intersects &amp;&amp; this.isover == 0 ? &#x27;isover&#x27; : null);
			if(!c) return;

			var parentInstance;
			if (this.options.greedy) {
				// find droppable parents with same scope
				var scope = this.options.scope;
				var parent = this.element.parents(&#x27;:data(droppable)&#x27;).filter(function () {
					return $.data(this, &#x27;droppable&#x27;).options.scope === scope;
				});

				if (parent.length) {
					parentInstance = $.data(parent[0], &#x27;droppable&#x27;);
					parentInstance.greedyChild = (c == &#x27;isover&#x27; ? 1 : 0);
				}
			}

			// we just moved into a greedy child
			if (parentInstance &amp;&amp; c == &#x27;isover&#x27;) {
				parentInstance[&#x27;isover&#x27;] = 0;
				parentInstance[&#x27;isout&#x27;] = 1;
				parentInstance._out.call(parentInstance, event);
			}

			this[c] = 1; this[c == &#x27;isout&#x27; ? &#x27;isover&#x27; : &#x27;isout&#x27;] = 0;
			this[c == &quot;isover&quot; ? &quot;_over&quot; : &quot;_out&quot;].call(this, event);

			// we just moved out of a greedy child
			if (parentInstance &amp;&amp; c == &#x27;isout&#x27;) {
				parentInstance[&#x27;isout&#x27;] = 0;
				parentInstance[&#x27;isover&#x27;] = 1;
				parentInstance._over.call(parentInstance, event);
			}
		});

	},
	dragStop: function( draggable, event ) {
		draggable.element.parentsUntil( &quot;body&quot; ).unbind( &quot;scroll.droppable&quot; );
		//Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
		if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
	}
};

})(jQuery);

(function( $, undefined ) {

$.widget(&quot;ui.resizable&quot;, $.ui.mouse, {
	version: &quot;1.9.1&quot;,
	widgetEventPrefix: &quot;resize&quot;,
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: &quot;slow&quot;,
		animateEasing: &quot;swing&quot;,
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: &quot;e,s,se&quot;,
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		zIndex: 1000
	},
	_create: function() {

		var that = this, o = this.options;
		this.element.addClass(&quot;ui-resizable&quot;);

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || &#x27;ui-resizable-helper&#x27; : null
		});

		//Wrap the element if it cannot hold child nodes
		if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

			//Create a wrapper element and set the wrapper to the new current internal element
			this.element.wrap(
				$(&#x27;&lt;div class=&quot;ui-wrapper&quot; style=&quot;overflow: hidden;&quot;&gt;&lt;/div&gt;&#x27;).css({
					position: this.element.css(&#x27;position&#x27;),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css(&#x27;top&#x27;),
					left: this.element.css(&#x27;left&#x27;)
				})
			);

			//Overwrite the original this.element
			this.element = this.element.parent().data(
				&quot;resizable&quot;, this.element.data(&#x27;resizable&#x27;)
			);

			this.elementIsWrapper = true;

			//Move margins to the wrapper
			this.element.css({ marginLeft: this.originalElement.css(&quot;marginLeft&quot;), marginTop: this.originalElement.css(&quot;marginTop&quot;), marginRight: this.originalElement.css(&quot;marginRight&quot;), marginBottom: this.originalElement.css(&quot;marginBottom&quot;) });
			this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});

			//Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css(&#x27;resize&#x27;);
			this.originalElement.css(&#x27;resize&#x27;, &#x27;none&#x27;);

			//Push the actual element to our proportionallyResize internal array
			this._proportionallyResizeElements.push(this.originalElement.css({ position: &#x27;static&#x27;, zoom: 1, display: &#x27;block&#x27; }));

			// avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css(&#x27;margin&#x27;) });

			// fix handlers offset
			this._proportionallyResize();

		}

		this.handles = o.handles || (!$(&#x27;.ui-resizable-handle&#x27;, this.element).length ? &quot;e,s,se&quot; : { n: &#x27;.ui-resizable-n&#x27;, e: &#x27;.ui-resizable-e&#x27;, s: &#x27;.ui-resizable-s&#x27;, w: &#x27;.ui-resizable-w&#x27;, se: &#x27;.ui-resizable-se&#x27;, sw: &#x27;.ui-resizable-sw&#x27;, ne: &#x27;.ui-resizable-ne&#x27;, nw: &#x27;.ui-resizable-nw&#x27; });
		if(this.handles.constructor == String) {

			if(this.handles == &#x27;all&#x27;) this.handles = &#x27;n,e,s,w,se,sw,ne,nw&#x27;;
			var n = this.handles.split(&quot;,&quot;); this.handles = {};

			for(var i = 0; i &lt; n.length; i++) {

				var handle = $.trim(n[i]), hname = &#x27;ui-resizable-&#x27;+handle;
				var axis = $(&#x27;&lt;div class=&quot;ui-resizable-handle &#x27; + hname + &#x27;&quot;&gt;&lt;/div&gt;&#x27;);

				// Apply zIndex to all handles - see #7960
				axis.css({ zIndex: o.zIndex });

				//TODO : What&#x27;s going on here?
				if (&#x27;se&#x27; == handle) {
					axis.addClass(&#x27;ui-icon ui-icon-gripsmall-diagonal-se&#x27;);
				};

				//Insert into internal handles object and append to element
				this.handles[handle] = &#x27;.ui-resizable-&#x27;+handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			target = target || this.element;

			for(var i in this.handles) {

				if(this.handles[i].constructor == String)
					this.handles[i] = $(this.handles[i], this.element).show();

				//Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
				if (this.elementIsWrapper &amp;&amp; this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

					var axis = $(this.handles[i], this.element), padWrapper = 0;

					//Checking the correct pad and border
					padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

					//The padding type i have to apply...
					var padPos = [ &#x27;padding&#x27;,
						/ne|nw|n/.test(i) ? &#x27;Top&#x27; :
						/se|sw|s/.test(i) ? &#x27;Bottom&#x27; :
						/^e$/.test(i) ? &#x27;Right&#x27; : &#x27;Left&#x27; ].join(&quot;&quot;);

					target.css(padPos, padWrapper);

					this._proportionallyResize();

				}

				//TODO: What&#x27;s that good for? There&#x27;s not anything to be executed left
				if(!$(this.handles[i]).length)
					continue;

			}
		};

		//TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = $(&#x27;.ui-resizable-handle&#x27;, this.element)
			.disableSelection();

		//Matching axis name
		this._handles.mouseover(function() {
			if (!that.resizing) {
				if (this.className)
					var axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
				//Axis, default = se
				that.axis = axis &amp;&amp; axis[1] ? axis[1] : &#x27;se&#x27;;
			}
		});

		//If we want to auto hide the elements
		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass(&quot;ui-resizable-autohide&quot;)
				.mouseenter(function() {
					if (o.disabled) return;
					$(this).removeClass(&quot;ui-resizable-autohide&quot;);
					that._handles.show();
				})
				.mouseleave(function(){
					if (o.disabled) return;
					if (!that.resizing) {
						$(this).addClass(&quot;ui-resizable-autohide&quot;);
						that._handles.hide();
					}
				});
		}

		//Initialize the mouse interaction
		this._mouseInit();

	},

	_destroy: function() {

		this._mouseDestroy();

		var _destroy = function(exp) {
			$(exp).removeClass(&quot;ui-resizable ui-resizable-disabled ui-resizable-resizing&quot;)
				.removeData(&quot;resizable&quot;).removeData(&quot;ui-resizable&quot;).unbind(&quot;.resizable&quot;).find(&#x27;.ui-resizable-handle&#x27;).remove();
		};

		//TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			var wrapper = this.element;
			this.originalElement.css({
				position: wrapper.css(&#x27;position&#x27;),
				width: wrapper.outerWidth(),
				height: wrapper.outerHeight(),
				top: wrapper.css(&#x27;top&#x27;),
				left: wrapper.css(&#x27;left&#x27;)
			}).insertAfter( wrapper );
			wrapper.remove();
		}

		this.originalElement.css(&#x27;resize&#x27;, this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var handle = false;
		for (var i in this.handles) {
			if ($(this.handles[i])[0] == event.target) {
				handle = true;
			}
		}

		return !this.options.disabled &amp;&amp; handle;
	},

	_mouseStart: function(event) {

		var o = this.options, iniPos = this.element.position(), el = this.element;

		this.resizing = true;
		this.documentScroll = { top: $(document).scrollTop(), left: $(document).scrollLeft() };

		// bugfix for http://dev.jquery.com/ticket/1749
		if (el.is(&#x27;.ui-draggable&#x27;) || (/absolute/).test(el.css(&#x27;position&#x27;))) {
			el.css({ position: &#x27;absolute&#x27;, top: iniPos.top, left: iniPos.left });
		}

		this._renderProxy();

		var curleft = num(this.helper.css(&#x27;left&#x27;)), curtop = num(this.helper.css(&#x27;top&#x27;));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		//Store needed variables
		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };
		this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalPosition = { left: curleft, top: curtop };
		this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		//Aspect Ratio
		this.aspectRatio = (typeof o.aspectRatio == &#x27;number&#x27;) ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

		var cursor = $(&#x27;.ui-resizable-&#x27; + this.axis).css(&#x27;cursor&#x27;);
		$(&#x27;body&#x27;).css(&#x27;cursor&#x27;, cursor == &#x27;auto&#x27; ? this.axis + &#x27;-resize&#x27; : cursor);

		el.addClass(&quot;ui-resizable-resizing&quot;);
		this._propagate(&quot;start&quot;, event);
		return true;
	},

	_mouseDrag: function(event) {

		//Increase performance, avoid regex
		var el = this.helper, o = this.options, props = {},
			that = this, smp = this.originalMousePosition, a = this.axis;

		var dx = (event.pageX-smp.left)||0, dy = (event.pageY-smp.top)||0;
		var trigger = this._change[a];
		if (!trigger) return false;

		// Calculate the attrs that will be change
		var data = trigger.apply(this, [event, dx, dy]);

		// Put this in the mouseDrag handler since the user can start pressing shift while resizing
		this._updateVirtualBoundaries(event.shiftKey);
		if (this._aspectRatio || event.shiftKey)
			data = this._updateRatio(data, event);

		data = this._respectSize(data, event);

		// plugins callbacks need to be called first
		this._propagate(&quot;resize&quot;, event);

		el.css({
			top: this.position.top + &quot;px&quot;, left: this.position.left + &quot;px&quot;,
			width: this.size.width + &quot;px&quot;, height: this.size.height + &quot;px&quot;
		});

		if (!this._helper &amp;&amp; this._proportionallyResizeElements.length)
			this._proportionallyResize();

		this._updateCache(data);

		// calling the user callback at the end
		this._trigger(&#x27;resize&#x27;, event, this.ui());

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var o = this.options, that = this;

		if(this._helper) {
			var pr = this._proportionallyResizeElements, ista = pr.length &amp;&amp; (/textarea/i).test(pr[0].nodeName),
				soffseth = ista &amp;&amp; $.ui.hasScroll(pr[0], &#x27;left&#x27;) /* TODO - jump height */ ? 0 : that.sizeDiff.height,
				soffsetw = ista ? 0 : that.sizeDiff.width;

			var s = { width: (that.helper.width()  - soffsetw), height: (that.helper.height() - soffseth) },
				left = (parseInt(that.element.css(&#x27;left&#x27;), 10) + (that.position.left - that.originalPosition.left)) || null,
				top = (parseInt(that.element.css(&#x27;top&#x27;), 10) + (that.position.top - that.originalPosition.top)) || null;

			if (!o.animate)
				this.element.css($.extend(s, { top: top, left: left }));

			that.helper.height(that.size.height);
			that.helper.width(that.size.width);

			if (this._helper &amp;&amp; !o.animate) this._proportionallyResize();
		}

		$(&#x27;body&#x27;).css(&#x27;cursor&#x27;, &#x27;auto&#x27;);

		this.element.removeClass(&quot;ui-resizable-resizing&quot;);

		this._propagate(&quot;stop&quot;, event);

		if (this._helper) this.helper.remove();
		return false;

	},

	_updateVirtualBoundaries: function(forceAspectRatio) {
		var o = this.options, pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b;

		b = {
			minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
			maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
			minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
			maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
		};

		if(this._aspectRatio || forceAspectRatio) {
			// We want to create an enclosing box whose aspect ration is the requested one
			// First, compute the &quot;projected&quot; size for each dimension based on the aspect ratio and other dimension
			pMinWidth = b.minHeight * this.aspectRatio;
			pMinHeight = b.minWidth / this.aspectRatio;
			pMaxWidth = b.maxHeight * this.aspectRatio;
			pMaxHeight = b.maxWidth / this.aspectRatio;

			if(pMinWidth &gt; b.minWidth) b.minWidth = pMinWidth;
			if(pMinHeight &gt; b.minHeight) b.minHeight = pMinHeight;
			if(pMaxWidth &lt; b.maxWidth) b.maxWidth = pMaxWidth;
			if(pMaxHeight &lt; b.maxHeight) b.maxHeight = pMaxHeight;
		}
		this._vBoundaries = b;
	},

	_updateCache: function(data) {
		var o = this.options;
		this.offset = this.helper.offset();
		if (isNumber(data.left)) this.position.left = data.left;
		if (isNumber(data.top)) this.position.top = data.top;
		if (isNumber(data.height)) this.size.height = data.height;
		if (isNumber(data.width)) this.size.width = data.width;
	},

	_updateRatio: function(data, event) {

		var o = this.options, cpos = this.position, csize = this.size, a = this.axis;

		if (isNumber(data.height)) data.width = (data.height * this.aspectRatio);
		else if (isNumber(data.width)) data.height = (data.width / this.aspectRatio);

		if (a == &#x27;sw&#x27;) {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a == &#x27;nw&#x27;) {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function(data, event) {

		var el = this.helper, o = this._vBoundaries, pRatio = this._aspectRatio || event.shiftKey, a = this.axis,
				ismaxw = isNumber(data.width) &amp;&amp; o.maxWidth &amp;&amp; (o.maxWidth &lt; data.width), ismaxh = isNumber(data.height) &amp;&amp; o.maxHeight &amp;&amp; (o.maxHeight &lt; data.height),
					isminw = isNumber(data.width) &amp;&amp; o.minWidth &amp;&amp; (o.minWidth &gt; data.width), isminh = isNumber(data.height) &amp;&amp; o.minHeight &amp;&amp; (o.minHeight &gt; data.height);

		if (isminw) data.width = o.minWidth;
		if (isminh) data.height = o.minHeight;
		if (ismaxw) data.width = o.maxWidth;
		if (ismaxh) data.height = o.maxHeight;

		var dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height;
		var cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);

		if (isminw &amp;&amp; cw) data.left = dw - o.minWidth;
		if (ismaxw &amp;&amp; cw) data.left = dw - o.maxWidth;
		if (isminh &amp;&amp; ch)	data.top = dh - o.minHeight;
		if (ismaxh &amp;&amp; ch)	data.top = dh - o.maxHeight;

		// fixing jump error on top/left - bug #2330
		var isNotwh = !data.width &amp;&amp; !data.height;
		if (isNotwh &amp;&amp; !data.left &amp;&amp; data.top) data.top = null;
		else if (isNotwh &amp;&amp; !data.top &amp;&amp; data.left) data.left = null;

		return data;
	},

	_proportionallyResize: function() {

		var o = this.options;
		if (!this._proportionallyResizeElements.length) return;
		var element = this.helper || this.element;

		for (var i=0; i &lt; this._proportionallyResizeElements.length; i++) {

			var prel = this._proportionallyResizeElements[i];

			if (!this.borderDif) {
				var b = [prel.css(&#x27;borderTopWidth&#x27;), prel.css(&#x27;borderRightWidth&#x27;), prel.css(&#x27;borderBottomWidth&#x27;), prel.css(&#x27;borderLeftWidth&#x27;)],
					p = [prel.css(&#x27;paddingTop&#x27;), prel.css(&#x27;paddingRight&#x27;), prel.css(&#x27;paddingBottom&#x27;), prel.css(&#x27;paddingLeft&#x27;)];

				this.borderDif = $.map(b, function(v, i) {
					var border = parseInt(v,10)||0, padding = parseInt(p[i],10)||0;
					return border + padding;
				});
			}

			prel.css({
				height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
				width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
			});

		};

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if(this._helper) {

			this.helper = this.helper || $(&#x27;&lt;div style=&quot;overflow:hidden;&quot;&gt;&lt;/div&gt;&#x27;);

			// fix ie6 offset TODO: This seems broken
			var ie6offset = ($.ui.ie6 ? 1 : 0),
			pxyoffset = ( $.ui.ie6 ? 2 : -1 );

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() + pxyoffset,
				height: this.element.outerHeight() + pxyoffset,
				position: &#x27;absolute&#x27;,
				left: this.elementOffset.left - ie6offset +&#x27;px&#x27;,
				top: this.elementOffset.top - ie6offset +&#x27;px&#x27;,
				zIndex: ++o.zIndex //TODO: Don&#x27;t modify option
			});

			this.helper
				.appendTo(&quot;body&quot;)
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx, dy) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [event, this.ui()]);
		(n != &quot;resize&quot; &amp;&amp; this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

});

/*
 * Resizable Extensions
 */

$.ui.plugin.add(&quot;resizable&quot;, &quot;alsoResize&quot;, {

	start: function (event, ui) {
		var that = $(this).data(&quot;resizable&quot;), o = that.options;

		var _store = function (exp) {
			$(exp).each(function() {
				var el = $(this);
				el.data(&quot;resizable-alsoresize&quot;, {
					width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
					left: parseInt(el.css(&#x27;left&#x27;), 10), top: parseInt(el.css(&#x27;top&#x27;), 10)
				});
			});
		};

		if (typeof(o.alsoResize) == &#x27;object&#x27; &amp;&amp; !o.alsoResize.parentNode) {
			if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
			else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
		}else{
			_store(o.alsoResize);
		}
	},

	resize: function (event, ui) {
		var that = $(this).data(&quot;resizable&quot;), o = that.options, os = that.originalSize, op = that.originalPosition;

		var delta = {
			height: (that.size.height - os.height) || 0, width: (that.size.width - os.width) || 0,
			top: (that.position.top - op.top) || 0, left: (that.position.left - op.left) || 0
		},

		_alsoResize = function (exp, c) {
			$(exp).each(function() {
				var el = $(this), start = $(this).data(&quot;resizable-alsoresize&quot;), style = {},
					css = c &amp;&amp; c.length ? c : el.parents(ui.originalElement[0]).length ? [&#x27;width&#x27;, &#x27;height&#x27;] : [&#x27;width&#x27;, &#x27;height&#x27;, &#x27;top&#x27;, &#x27;left&#x27;];

				$.each(css, function (i, prop) {
					var sum = (start[prop]||0) + (delta[prop]||0);
					if (sum &amp;&amp; sum &gt;= 0)
						style[prop] = sum || null;
				});

				el.css(style);
			});
		};

		if (typeof(o.alsoResize) == &#x27;object&#x27; &amp;&amp; !o.alsoResize.nodeType) {
			$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
		}else{
			_alsoResize(o.alsoResize);
		}
	},

	stop: function (event, ui) {
		$(this).removeData(&quot;resizable-alsoresize&quot;);
	}
});

$.ui.plugin.add(&quot;resizable&quot;, &quot;animate&quot;, {

	stop: function(event, ui) {
		var that = $(this).data(&quot;resizable&quot;), o = that.options;

		var pr = that._proportionallyResizeElements, ista = pr.length &amp;&amp; (/textarea/i).test(pr[0].nodeName),
					soffseth = ista &amp;&amp; $.ui.hasScroll(pr[0], &#x27;left&#x27;) /* TODO - jump height */ ? 0 : that.sizeDiff.height,
						soffsetw = ista ? 0 : that.sizeDiff.width;

		var style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
					left = (parseInt(that.element.css(&#x27;left&#x27;), 10) + (that.position.left - that.originalPosition.left)) || null,
						top = (parseInt(that.element.css(&#x27;top&#x27;), 10) + (that.position.top - that.originalPosition.top)) || null;

		that.element.animate(
			$.extend(style, top &amp;&amp; left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(that.element.css(&#x27;width&#x27;), 10),
						height: parseInt(that.element.css(&#x27;height&#x27;), 10),
						top: parseInt(that.element.css(&#x27;top&#x27;), 10),
						left: parseInt(that.element.css(&#x27;left&#x27;), 10)
					};

					if (pr &amp;&amp; pr.length) $(pr[0]).css({ width: data.width, height: data.height });

					// propagating resize, and updating values for each animation step
					that._updateCache(data);
					that._propagate(&quot;resize&quot;, event);

				}
			}
		);
	}

});

$.ui.plugin.add(&quot;resizable&quot;, &quot;containment&quot;, {

	start: function(event, ui) {
		var that = $(this).data(&quot;resizable&quot;), o = that.options, el = that.element;
		var oc = o.containment,	ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;
		if (!ce) return;

		that.containerElement = $(ce);

		if (/document/.test(oc) || oc == document) {
			that.containerOffset = { left: 0, top: 0 };
			that.containerPosition = { left: 0, top: 0 };

			that.parentData = {
				element: $(document), left: 0, top: 0,
				width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
			};
		}

		// i&#x27;m a node, so compute top, left, right, bottom
		else {
			var element = $(ce), p = [];
			$([ &quot;Top&quot;, &quot;Right&quot;, &quot;Left&quot;, &quot;Bottom&quot; ]).each(function(i, name) { p[i] = num(element.css(&quot;padding&quot; + name)); });

			that.containerOffset = element.offset();
			that.containerPosition = element.position();
			that.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

			var co = that.containerOffset, ch = that.containerSize.height,	cw = that.containerSize.width,
						width = ($.ui.hasScroll(ce, &quot;left&quot;) ? ce.scrollWidth : cw ), height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

			that.parentData = {
				element: ce, left: co.left, top: co.top, width: width, height: height
			};
		}
	},

	resize: function(event, ui) {
		var that = $(this).data(&quot;resizable&quot;), o = that.options,
				ps = that.containerSize, co = that.containerOffset, cs = that.size, cp = that.position,
				pRatio = that._aspectRatio || event.shiftKey, cop = { top:0, left:0 }, ce = that.containerElement;

		if (ce[0] != document &amp;&amp; (/static/).test(ce.css(&#x27;position&#x27;))) cop = co;

		if (cp.left &lt; (that._helper ? co.left : 0)) {
			that.size.width = that.size.width + (that._helper ? (that.position.left - co.left) : (that.position.left - cop.left));
			if (pRatio) that.size.height = that.size.width / that.aspectRatio;
			that.position.left = o.helper ? co.left : 0;
		}

		if (cp.top &lt; (that._helper ? co.top : 0)) {
			that.size.height = that.size.height + (that._helper ? (that.position.top - co.top) : that.position.top);
			if (pRatio) that.size.width = that.size.height * that.aspectRatio;
			that.position.top = that._helper ? co.top : 0;
		}

		that.offset.left = that.parentData.left+that.position.left;
		that.offset.top = that.parentData.top+that.position.top;

		var woset = Math.abs( (that._helper ? that.offset.left - cop.left : (that.offset.left - cop.left)) + that.sizeDiff.width ),
					hoset = Math.abs( (that._helper ? that.offset.top - cop.top : (that.offset.top - co.top)) + that.sizeDiff.height );

		var isParent = that.containerElement.get(0) == that.element.parent().get(0),
			isOffsetRelative = /relative|absolute/.test(that.containerElement.css(&#x27;position&#x27;));

		if(isParent &amp;&amp; isOffsetRelative) woset -= that.parentData.left;

		if (woset + that.size.width &gt;= that.parentData.width) {
			that.size.width = that.parentData.width - woset;
			if (pRatio) that.size.height = that.size.width / that.aspectRatio;
		}

		if (hoset + that.size.height &gt;= that.parentData.height) {
			that.size.height = that.parentData.height - hoset;
			if (pRatio) that.size.width = that.size.height * that.aspectRatio;
		}
	},

	stop: function(event, ui){
		var that = $(this).data(&quot;resizable&quot;), o = that.options, cp = that.position,
				co = that.containerOffset, cop = that.containerPosition, ce = that.containerElement;

		var helper = $(that.helper), ho = helper.offset(), w = helper.outerWidth() - that.sizeDiff.width, h = helper.outerHeight() - that.sizeDiff.height;

		if (that._helper &amp;&amp; !o.animate &amp;&amp; (/relative/).test(ce.css(&#x27;position&#x27;)))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

		if (that._helper &amp;&amp; !o.animate &amp;&amp; (/static/).test(ce.css(&#x27;position&#x27;)))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

	}
});

$.ui.plugin.add(&quot;resizable&quot;, &quot;ghost&quot;, {

	start: function(event, ui) {

		var that = $(this).data(&quot;resizable&quot;), o = that.options, cs = that.size;

		that.ghost = that.originalElement.clone();
		that.ghost
			.css({ opacity: .25, display: &#x27;block&#x27;, position: &#x27;relative&#x27;, height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
			.addClass(&#x27;ui-resizable-ghost&#x27;)
			.addClass(typeof o.ghost == &#x27;string&#x27; ? o.ghost : &#x27;&#x27;);

		that.ghost.appendTo(that.helper);

	},

	resize: function(event, ui){
		var that = $(this).data(&quot;resizable&quot;), o = that.options;
		if (that.ghost) that.ghost.css({ position: &#x27;relative&#x27;, height: that.size.height, width: that.size.width });
	},

	stop: function(event, ui){
		var that = $(this).data(&quot;resizable&quot;), o = that.options;
		if (that.ghost &amp;&amp; that.helper) that.helper.get(0).removeChild(that.ghost.get(0));
	}

});

$.ui.plugin.add(&quot;resizable&quot;, &quot;grid&quot;, {

	resize: function(event, ui) {
		var that = $(this).data(&quot;resizable&quot;), o = that.options, cs = that.size, os = that.originalSize, op = that.originalPosition, a = that.axis, ratio = o._aspectRatio || event.shiftKey;
		o.grid = typeof o.grid == &quot;number&quot; ? [o.grid, o.grid] : o.grid;
		var ox = Math.round((cs.width - os.width) / (o.grid[0]||1)) * (o.grid[0]||1), oy = Math.round((cs.height - os.height) / (o.grid[1]||1)) * (o.grid[1]||1);

		if (/^(se|s|e)$/.test(a)) {
			that.size.width = os.width + ox;
			that.size.height = os.height + oy;
		}
		else if (/^(ne)$/.test(a)) {
			that.size.width = os.width + ox;
			that.size.height = os.height + oy;
			that.position.top = op.top - oy;
		}
		else if (/^(sw)$/.test(a)) {
			that.size.width = os.width + ox;
			that.size.height = os.height + oy;
			that.position.left = op.left - ox;
		}
		else {
			that.size.width = os.width + ox;
			that.size.height = os.height + oy;
			that.position.top = op.top - oy;
			that.position.left = op.left - ox;
		}
	}

});

var num = function(v) {
	return parseInt(v, 10) || 0;
};

var isNumber = function(value) {
	return !isNaN(parseInt(value, 10));
};

})(jQuery);

(function( $, undefined ) {

$.widget(&quot;ui.selectable&quot;, $.ui.mouse, {
	version: &quot;1.9.1&quot;,
	options: {
		appendTo: &#x27;body&#x27;,
		autoRefresh: true,
		distance: 0,
		filter: &#x27;*&#x27;,
		tolerance: &#x27;touch&#x27;
	},
	_create: function() {
		var that = this;

		this.element.addClass(&quot;ui-selectable&quot;);

		this.dragged = false;

		// cache selectee children based on filter
		var selectees;
		this.refresh = function() {
			selectees = $(that.options.filter, that.element[0]);
			selectees.addClass(&quot;ui-selectee&quot;);
			selectees.each(function() {
				var $this = $(this);
				var pos = $this.offset();
				$.data(this, &quot;selectable-item&quot;, {
					element: this,
					$element: $this,
					left: pos.left,
					top: pos.top,
					right: pos.left + $this.outerWidth(),
					bottom: pos.top + $this.outerHeight(),
					startselected: false,
					selected: $this.hasClass(&#x27;ui-selected&#x27;),
					selecting: $this.hasClass(&#x27;ui-selecting&#x27;),
					unselecting: $this.hasClass(&#x27;ui-unselecting&#x27;)
				});
			});
		};
		this.refresh();

		this.selectees = selectees.addClass(&quot;ui-selectee&quot;);

		this._mouseInit();

		this.helper = $(&quot;&lt;div class=&#x27;ui-selectable-helper&#x27;&gt;&lt;/div&gt;&quot;);
	},

	_destroy: function() {
		this.selectees
			.removeClass(&quot;ui-selectee&quot;)
			.removeData(&quot;selectable-item&quot;);
		this.element
			.removeClass(&quot;ui-selectable ui-selectable-disabled&quot;);
		this._mouseDestroy();
	},

	_mouseStart: function(event) {
		var that = this;

		this.opos = [event.pageX, event.pageY];

		if (this.options.disabled)
			return;

		var options = this.options;

		this.selectees = $(options.filter, this.element[0]);

		this._trigger(&quot;start&quot;, event);

		$(options.appendTo).append(this.helper);
		// position helper (lasso)
		this.helper.css({
			&quot;left&quot;: event.clientX,
			&quot;top&quot;: event.clientY,
			&quot;width&quot;: 0,
			&quot;height&quot;: 0
		});

		if (options.autoRefresh) {
			this.refresh();
		}

		this.selectees.filter(&#x27;.ui-selected&#x27;).each(function() {
			var selectee = $.data(this, &quot;selectable-item&quot;);
			selectee.startselected = true;
			if (!event.metaKey &amp;&amp; !event.ctrlKey) {
				selectee.$element.removeClass(&#x27;ui-selected&#x27;);
				selectee.selected = false;
				selectee.$element.addClass(&#x27;ui-unselecting&#x27;);
				selectee.unselecting = true;
				// selectable UNSELECTING callback
				that._trigger(&quot;unselecting&quot;, event, {
					unselecting: selectee.element
				});
			}
		});

		$(event.target).parents().andSelf().each(function() {
			var selectee = $.data(this, &quot;selectable-item&quot;);
			if (selectee) {
				var doSelect = (!event.metaKey &amp;&amp; !event.ctrlKey) || !selectee.$element.hasClass(&#x27;ui-selected&#x27;);
				selectee.$element
					.removeClass(doSelect ? &quot;ui-unselecting&quot; : &quot;ui-selected&quot;)
					.addClass(doSelect ? &quot;ui-selecting&quot; : &quot;ui-unselecting&quot;);
				selectee.unselecting = !doSelect;
				selectee.selecting = doSelect;
				selectee.selected = doSelect;
				// selectable (UN)SELECTING callback
				if (doSelect) {
					that._trigger(&quot;selecting&quot;, event, {
						selecting: selectee.element
					});
				} else {
					that._trigger(&quot;unselecting&quot;, event, {
						unselecting: selectee.element
					});
				}
				return false;
			}
		});

	},

	_mouseDrag: function(event) {
		var that = this;
		this.dragged = true;

		if (this.options.disabled)
			return;

		var options = this.options;

		var x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY;
		if (x1 &gt; x2) { var tmp = x2; x2 = x1; x1 = tmp; }
		if (y1 &gt; y2) { var tmp = y2; y2 = y1; y1 = tmp; }
		this.helper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});

		this.selectees.each(function() {
			var selectee = $.data(this, &quot;selectable-item&quot;);
			//prevent helper from being selected if appendTo: selectable
			if (!selectee || selectee.element == that.element[0])
				return;
			var hit = false;
			if (options.tolerance == &#x27;touch&#x27;) {
				hit = ( !(selectee.left &gt; x2 || selectee.right &lt; x1 || selectee.top &gt; y2 || selectee.bottom &lt; y1) );
			} else if (options.tolerance == &#x27;fit&#x27;) {
				hit = (selectee.left &gt; x1 &amp;&amp; selectee.right &lt; x2 &amp;&amp; selectee.top &gt; y1 &amp;&amp; selectee.bottom &lt; y2);
			}

			if (hit) {
				// SELECT
				if (selectee.selected) {
					selectee.$element.removeClass(&#x27;ui-selected&#x27;);
					selectee.selected = false;
				}
				if (selectee.unselecting) {
					selectee.$element.removeClass(&#x27;ui-unselecting&#x27;);
					selectee.unselecting = false;
				}
				if (!selectee.selecting) {
					selectee.$element.addClass(&#x27;ui-selecting&#x27;);
					selectee.selecting = true;
					// selectable SELECTING callback
					that._trigger(&quot;selecting&quot;, event, {
						selecting: selectee.element
					});
				}
			} else {
				// UNSELECT
				if (selectee.selecting) {
					if ((event.metaKey || event.ctrlKey) &amp;&amp; selectee.startselected) {
						selectee.$element.removeClass(&#x27;ui-selecting&#x27;);
						selectee.selecting = false;
						selectee.$element.addClass(&#x27;ui-selected&#x27;);
						selectee.selected = true;
					} else {
						selectee.$element.removeClass(&#x27;ui-selecting&#x27;);
						selectee.selecting = false;
						if (selectee.startselected) {
							selectee.$element.addClass(&#x27;ui-unselecting&#x27;);
							selectee.unselecting = true;
						}
						// selectable UNSELECTING callback
						that._trigger(&quot;unselecting&quot;, event, {
							unselecting: selectee.element
						});
					}
				}
				if (selectee.selected) {
					if (!event.metaKey &amp;&amp; !event.ctrlKey &amp;&amp; !selectee.startselected) {
						selectee.$element.removeClass(&#x27;ui-selected&#x27;);
						selectee.selected = false;

						selectee.$element.addClass(&#x27;ui-unselecting&#x27;);
						selectee.unselecting = true;
						// selectable UNSELECTING callback
						that._trigger(&quot;unselecting&quot;, event, {
							unselecting: selectee.element
						});
					}
				}
			}
		});

		return false;
	},

	_mouseStop: function(event) {
		var that = this;

		this.dragged = false;

		var options = this.options;

		$(&#x27;.ui-unselecting&#x27;, this.element[0]).each(function() {
			var selectee = $.data(this, &quot;selectable-item&quot;);
			selectee.$element.removeClass(&#x27;ui-unselecting&#x27;);
			selectee.unselecting = false;
			selectee.startselected = false;
			that._trigger(&quot;unselected&quot;, event, {
				unselected: selectee.element
			});
		});
		$(&#x27;.ui-selecting&#x27;, this.element[0]).each(function() {
			var selectee = $.data(this, &quot;selectable-item&quot;);
			selectee.$element.removeClass(&#x27;ui-selecting&#x27;).addClass(&#x27;ui-selected&#x27;);
			selectee.selecting = false;
			selectee.selected = true;
			selectee.startselected = true;
			that._trigger(&quot;selected&quot;, event, {
				selected: selectee.element
			});
		});
		this._trigger(&quot;stop&quot;, event);

		this.helper.remove();

		return false;
	}

});

})(jQuery);

(function( $, undefined ) {

$.widget(&quot;ui.sortable&quot;, $.ui.mouse, {
	version: &quot;1.9.1&quot;,
	widgetEventPrefix: &quot;sort&quot;,
	ready: false,
	options: {
		appendTo: &quot;parent&quot;,
		axis: false,
		connectWith: false,
		containment: false,
		cursor: &#x27;auto&#x27;,
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: &quot;original&quot;,
		items: &#x27;&gt; *&#x27;,
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: &quot;default&quot;,
		tolerance: &quot;intersect&quot;,
		zIndex: 1000
	},
	_create: function() {

		var o = this.options;
		this.containerCache = {};
		this.element.addClass(&quot;ui-sortable&quot;);

		//Get the items
		this.refresh();

		//Let&#x27;s determine if the items are being displayed horizontally
		this.floating = this.items.length ? o.axis === &#x27;x&#x27; || (/left|right/).test(this.items[0].item.css(&#x27;float&#x27;)) || (/inline|table-cell/).test(this.items[0].item.css(&#x27;display&#x27;)) : false;

		//Let&#x27;s determine the parent&#x27;s offset
		this.offset = this.element.offset();

		//Initialize mouse events for interaction
		this._mouseInit();

		//We&#x27;re ready to go
		this.ready = true

	},

	_destroy: function() {
		this.element
			.removeClass(&quot;ui-sortable ui-sortable-disabled&quot;);
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i &gt;= 0; i-- )
			this.items[i].item.removeData(this.widgetName + &quot;-item&quot;);

		return this;
	},

	_setOption: function(key, value){
		if ( key === &quot;disabled&quot; ) {
			this.options[ key ] = value;

			this.widget().toggleClass( &quot;ui-sortable-disabled&quot;, !!value );
		} else {
			// Don&#x27;t call widget base _setOption for disable as it adds ui-state-disabled class
			$.Widget.prototype._setOption.apply(this, arguments);
		}
	},

	_mouseCapture: function(event, overrideHandle) {
		var that = this;

		if (this.reverting) {
			return false;
		}

		if(this.options.disabled || this.options.type == &#x27;static&#x27;) return false;

		//We have to refresh the items data once first
		this._refreshItems(event);

		//Find out if the clicked node (or one of its parents) is a actual item in this.items
		var currentItem = null, nodes = $(event.target).parents().each(function() {
			if($.data(this, that.widgetName + &#x27;-item&#x27;) == that) {
				currentItem = $(this);
				return false;
			}
		});
		if($.data(event.target, that.widgetName + &#x27;-item&#x27;) == that) currentItem = $(event.target);

		if(!currentItem) return false;
		if(this.options.handle &amp;&amp; !overrideHandle) {
			var validHandle = false;

			$(this.options.handle, currentItem).find(&quot;*&quot;).andSelf().each(function() { if(this == event.target) validHandle = true; });
			if(!validHandle) return false;
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function(event, overrideHandle, noActivation) {

		var o = this.options;
		this.currentContainer = this;

		//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
		this.refreshPositions();

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		//Cache the helper size
		this._cacheHelperProportions();

		/*
		 * - Position generation -
		 * This block generates everything position related - it&#x27;s the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Get the next scrolling parent
		this.scrollParent = this.helper.scrollParent();

		//The element&#x27;s absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		// Only after we got the offset, we can change the helper&#x27;s position to absolute
		// TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css(&quot;position&quot;, &quot;absolute&quot;);
		this.cssPosition = this.helper.css(&quot;position&quot;);

		//Generate the original position
		this.originalPosition = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if &#x27;cursorAt&#x27; is supplied
		(o.cursorAt &amp;&amp; this._adjustOffsetFromHelper(o.cursorAt));

		//Cache the former DOM position
		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

		//If the helper is not the original, hide the original so it&#x27;s not playing any role during the drag, won&#x27;t cause anything bad this way
		if(this.helper[0] != this.currentItem[0]) {
			this.currentItem.hide();
		}

		//Create the placeholder
		this._createPlaceholder();

		//Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		if(o.cursor) { // cursor option
			if ($(&#x27;body&#x27;).css(&quot;cursor&quot;)) this._storedCursor = $(&#x27;body&#x27;).css(&quot;cursor&quot;);
			$(&#x27;body&#x27;).css(&quot;cursor&quot;, o.cursor);
		}

		if(o.opacity) { // opacity option
			if (this.helper.css(&quot;opacity&quot;)) this._storedOpacity = this.helper.css(&quot;opacity&quot;);
			this.helper.css(&quot;opacity&quot;, o.opacity);
		}

		if(o.zIndex) { // zIndex option
			if (this.helper.css(&quot;zIndex&quot;)) this._storedZIndex = this.helper.css(&quot;zIndex&quot;);
			this.helper.css(&quot;zIndex&quot;, o.zIndex);
		}

		//Prepare scrolling
		if(this.scrollParent[0] != document &amp;&amp; this.scrollParent[0].tagName != &#x27;HTML&#x27;)
			this.overflowOffset = this.scrollParent.offset();

		//Call callbacks
		this._trigger(&quot;start&quot;, event, this._uiHash());

		//Recache the helper size
		if(!this._preserveHelperProportions)
			this._cacheHelperProportions();


		//Post &#x27;activate&#x27; events to possible containers
		if(!noActivation) {
			 for (var i = this.containers.length - 1; i &gt;= 0; i--) { this.containers[i]._trigger(&quot;activate&quot;, event, this._uiHash(this)); }
		}

		//Prepare possible droppables
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		if ($.ui.ddmanager &amp;&amp; !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);

		this.dragging = true;

		this.helper.addClass(&quot;ui-sortable-helper&quot;);
		this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		return true;

	},

	_mouseDrag: function(event) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo(&quot;absolute&quot;);

		if (!this.lastPositionAbs) {
			this.lastPositionAbs = this.positionAbs;
		}

		//Do scrolling
		if(this.options.scroll) {
			var o = this.options, scrolled = false;
			if(this.scrollParent[0] != document &amp;&amp; this.scrollParent[0].tagName != &#x27;HTML&#x27;) {

				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY &lt; o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - this.overflowOffset.top &lt; o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;

				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX &lt; o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - this.overflowOffset.left &lt; o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;

			} else {

				if(event.pageY - $(document).scrollTop() &lt; o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) &lt; o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);

				if(event.pageX - $(document).scrollLeft() &lt; o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) &lt; o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);

			}

			if(scrolled !== false &amp;&amp; $.ui.ddmanager &amp;&amp; !o.dropBehaviour)
				$.ui.ddmanager.prepareOffsets(this, event);
		}

		//Regenerate the absolute position used for position checks
		this.positionAbs = this._convertPositionTo(&quot;absolute&quot;);

		//Set the helper position
		if(!this.options.axis || this.options.axis != &quot;y&quot;) this.helper[0].style.left = this.position.left+&#x27;px&#x27;;
		if(!this.options.axis || this.options.axis != &quot;x&quot;) this.helper[0].style.top = this.position.top+&#x27;px&#x27;;

		//Rearrange
		for (var i = this.items.length - 1; i &gt;= 0; i--) {

			//Cache variables and intersection, continue if no intersection
			var item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item);
			if (!intersection) continue;

			// Only put the placeholder inside the current Container, skip all
			// items form other containers. This works because when moving
			// an item from one container to another the
			// currentContainer is switched before the placeholder is moved.
			//
			// Without this moving items in &quot;sub-sortables&quot; can cause the placeholder to jitter
			// beetween the outer and inner container.
			if (item.instance !== this.currentContainer) continue;

			if (itemElement != this.currentItem[0] //cannot intersect with itself
				&amp;&amp;	this.placeholder[intersection == 1 ? &quot;next&quot; : &quot;prev&quot;]()[0] != itemElement //no useless actions that have been done before
				&amp;&amp;	!$.contains(this.placeholder[0], itemElement) //no action if the item moved is the parent of the item checked
				&amp;&amp; (this.options.type == &#x27;semi-dynamic&#x27; ? !$.contains(this.element[0], itemElement) : true)
				//&amp;&amp; itemElement.parentNode == this.placeholder[0].parentNode // only rearrange items within the same container
			) {

				this.direction = intersection == 1 ? &quot;down&quot; : &quot;up&quot;;

				if (this.options.tolerance == &quot;pointer&quot; || this._intersectsWithSides(item)) {
					this._rearrange(event, item);
				} else {
					break;
				}

				this._trigger(&quot;change&quot;, event, this._uiHash());
				break;
			}
		}

		//Post events to containers
		this._contactContainers(event);

		//Interconnect with droppables
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		//Call callbacks
		this._trigger(&#x27;sort&#x27;, event, this._uiHash());

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function(event, noPropagation) {

		if(!event) return;

		//If we are using droppables, inform the manager about the drop
		if ($.ui.ddmanager &amp;&amp; !this.options.dropBehaviour)
			$.ui.ddmanager.drop(this, event);

		if(this.options.revert) {
			var that = this;
			var cur = this.placeholder.offset();

			this.reverting = true;

			$(this.helper).animate({
				left: cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft),
				top: cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop)
			}, parseInt(this.options.revert, 10) || 500, function() {
				that._clear(event);
			});
		} else {
			this._clear(event, noPropagation);
		}

		return false;

	},

	cancel: function() {

		if(this.dragging) {

			this._mouseUp({ target: null });

			if(this.options.helper == &quot;original&quot;)
				this.currentItem.css(this._storedCSS).removeClass(&quot;ui-sortable-helper&quot;);
			else
				this.currentItem.show();

			//Post deactivating events to containers
			for (var i = this.containers.length - 1; i &gt;= 0; i--){
				this.containers[i]._trigger(&quot;deactivate&quot;, null, this._uiHash(this));
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger(&quot;out&quot;, null, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		if (this.placeholder) {
			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
			if(this.placeholder[0].parentNode) this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
			if(this.options.helper != &quot;original&quot; &amp;&amp; this.helper &amp;&amp; this.helper[0].parentNode) this.helper.remove();

			$.extend(this, {
				helper: null,
				dragging: false,
				reverting: false,
				_noFinalSort: null
			});

			if(this.domPosition.prev) {
				$(this.domPosition.prev).after(this.currentItem);
			} else {
				$(this.domPosition.parent).prepend(this.currentItem);
			}
		}

		return this;

	},

	serialize: function(o) {

		var items = this._getItemsAsjQuery(o &amp;&amp; o.connected);
		var str = []; o = o || {};

		$(items).each(function() {
			var res = ($(o.item || this).attr(o.attribute || &#x27;id&#x27;) || &#x27;&#x27;).match(o.expression || (/(.+)[-=_](.+)/));
			if(res) str.push((o.key || res[1]+&#x27;[]&#x27;)+&#x27;=&#x27;+(o.key &amp;&amp; o.expression ? res[1] : res[2]));
		});

		if(!str.length &amp;&amp; o.key) {
			str.push(o.key + &#x27;=&#x27;);
		}

		return str.join(&#x27;&amp;&#x27;);

	},

	toArray: function(o) {

		var items = this._getItemsAsjQuery(o &amp;&amp; o.connected);
		var ret = []; o = o || {};

		items.each(function() { ret.push($(o.item || this).attr(o.attribute || &#x27;id&#x27;) || &#x27;&#x27;); });
		return ret;

	},

	/* Be careful with the following core functions */
	_intersectsWith: function(item) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height;

		var l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height;

		var dyClick = this.offset.click.top,
			dxClick = this.offset.click.left;

		var isOverElement = (y1 + dyClick) &gt; t &amp;&amp; (y1 + dyClick) &lt; b &amp;&amp; (x1 + dxClick) &gt; l &amp;&amp; (x1 + dxClick) &lt; r;

		if(	   this.options.tolerance == &quot;pointer&quot;
			|| this.options.forcePointerForContainers
			|| (this.options.tolerance != &quot;pointer&quot; &amp;&amp; this.helperProportions[this.floating ? &#x27;width&#x27; : &#x27;height&#x27;] &gt; item[this.floating ? &#x27;width&#x27; : &#x27;height&#x27;])
		) {
			return isOverElement;
		} else {

			return (l &lt; x1 + (this.helperProportions.width / 2) // Right Half
				&amp;&amp; x2 - (this.helperProportions.width / 2) &lt; r // Left Half
				&amp;&amp; t &lt; y1 + (this.helperProportions.height / 2) // Bottom Half
				&amp;&amp; y2 - (this.helperProportions.height / 2) &lt; b ); // Top Half

		}
	},

	_intersectsWithPointer: function(item) {

		var isOverElementHeight = (this.options.axis === &#x27;x&#x27;) || $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
			isOverElementWidth = (this.options.axis === &#x27;y&#x27;) || $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
			isOverElement = isOverElementHeight &amp;&amp; isOverElementWidth,
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (!isOverElement)
			return false;

		return this.floating ?
			( ((horizontalDirection &amp;&amp; horizontalDirection == &quot;right&quot;) || verticalDirection == &quot;down&quot;) ? 2 : 1 )
			: ( verticalDirection &amp;&amp; (verticalDirection == &quot;down&quot; ? 2 : 1) );

	},

	_intersectsWithSides: function(item) {

		var isOverBottomHalf = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
			isOverRightHalf = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (this.floating &amp;&amp; horizontalDirection) {
			return ((horizontalDirection == &quot;right&quot; &amp;&amp; isOverRightHalf) || (horizontalDirection == &quot;left&quot; &amp;&amp; !isOverRightHalf));
		} else {
			return verticalDirection &amp;&amp; ((verticalDirection == &quot;down&quot; &amp;&amp; isOverBottomHalf) || (verticalDirection == &quot;up&quot; &amp;&amp; !isOverBottomHalf));
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta != 0 &amp;&amp; (delta &gt; 0 ? &quot;down&quot; : &quot;up&quot;);
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta != 0 &amp;&amp; (delta &gt; 0 ? &quot;right&quot; : &quot;left&quot;);
	},

	refresh: function(event) {
		this._refreshItems(event);
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor == String
			? [options.connectWith]
			: options.connectWith;
	},

	_getItemsAsjQuery: function(connected) {

		var items = [];
		var queries = [];
		var connectWith = this._connectWith();

		if(connectWith &amp;&amp; connected) {
			for (var i = connectWith.length - 1; i &gt;= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j &gt;= 0; j--){
					var inst = $.data(cur[j], this.widgetName);
					if(inst &amp;&amp; inst != this &amp;&amp; !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(&quot;.ui-sortable-helper&quot;).not(&#x27;.ui-sortable-placeholder&#x27;), inst]);
					}
				};
			};
		}

		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(&quot;.ui-sortable-helper&quot;).not(&#x27;.ui-sortable-placeholder&#x27;), this]);

		for (var i = queries.length - 1; i &gt;= 0; i--){
			queries[i][0].each(function() {
				items.push(this);
			});
		};

		return $(items);

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find(&quot;:data(&quot; + this.widgetName + &quot;-item)&quot;);

		this.items = $.grep(this.items, function (item) {
			for (var j=0; j &lt; list.length; j++) {
				if(list[j] == item.item[0])
					return false;
			};
			return true;
		});

	},

	_refreshItems: function(event) {

		this.items = [];
		this.containers = [this];
		var items = this.items;
		var queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]];
		var connectWith = this._connectWith();

		if(connectWith &amp;&amp; this.ready) { //Shouldn&#x27;t be run the first time through due to massive slow-down
			for (var i = connectWith.length - 1; i &gt;= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j &gt;= 0; j--){
					var inst = $.data(cur[j], this.widgetName);
					if(inst &amp;&amp; inst != this &amp;&amp; !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
						this.containers.push(inst);
					}
				};
			};
		}

		for (var i = queries.length - 1; i &gt;= 0; i--) {
			var targetData = queries[i][1];
			var _queries = queries[i][0];

			for (var j=0, queriesLength = _queries.length; j &lt; queriesLength; j++) {
				var item = $(_queries[j]);

				item.data(this.widgetName + &#x27;-item&#x27;, targetData); // Data for target checking (mouse manager)

				items.push({
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				});
			};
		};

	},

	refreshPositions: function(fast) {

		//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent&#x27;s position will change
		if(this.offsetParent &amp;&amp; this.helper) {
			this.offset.parent = this._getParentOffset();
		}

		for (var i = this.items.length - 1; i &gt;= 0; i--){
			var item = this.items[i];

			//We ignore calculating positions of all connected containers when we&#x27;re not over them
			if(item.instance != this.currentContainer &amp;&amp; this.currentContainer &amp;&amp; item.item[0] != this.currentItem[0])
				continue;

			var t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

			if (!fast) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}

			var p = t.offset();
			item.left = p.left;
			item.top = p.top;
		};

		if(this.options.custom &amp;&amp; this.options.custom.refreshContainers) {
			this.options.custom.refreshContainers.call(this);
		} else {
			for (var i = this.containers.length - 1; i &gt;= 0; i--){
				var p = this.containers[i].element.offset();
				this.containers[i].containerCache.left = p.left;
				this.containers[i].containerCache.top = p.top;
				this.containers[i].containerCache.width	= this.containers[i].element.outerWidth();
				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
			};
		}

		return this;
	},

	_createPlaceholder: function(that) {
		that = that || this;
		var o = that.options;

		if(!o.placeholder || o.placeholder.constructor == String) {
			var className = o.placeholder;
			o.placeholder = {
				element: function() {

					var el = $(document.createElement(that.currentItem[0].nodeName))
						.addClass(className || that.currentItem[0].className+&quot; ui-sortable-placeholder&quot;)
						.removeClass(&quot;ui-sortable-helper&quot;)[0];

					if(!className)
						el.style.visibility = &quot;hidden&quot;;

					return el;
				},
				update: function(container, p) {

					// 1. If a className is set as &#x27;placeholder option, we don&#x27;t force sizes - the class is responsible for that
					// 2. The option &#x27;forcePlaceholderSize can be enabled to force it even if a class name is specified
					if(className &amp;&amp; !o.forcePlaceholderSize) return;

					//If the element doesn&#x27;t have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
					if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css(&#x27;paddingTop&#x27;)||0, 10) - parseInt(that.currentItem.css(&#x27;paddingBottom&#x27;)||0, 10)); };
					if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css(&#x27;paddingLeft&#x27;)||0, 10) - parseInt(that.currentItem.css(&#x27;paddingRight&#x27;)||0, 10)); };
				}
			};
		}

		//Create the placeholder
		that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));

		//Append it after the actual current item
		that.currentItem.after(that.placeholder);

		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
		o.placeholder.update(that, that.placeholder);

	},

	_contactContainers: function(event) {

		// get innermost container that intersects with item
		var innermostContainer = null, innermostIndex = null;


		for (var i = this.containers.length - 1; i &gt;= 0; i--){

			// never consider a container that&#x27;s located within the item itself
			if($.contains(this.currentItem[0], this.containers[i].element[0]))
				continue;

			if(this._intersectsWith(this.containers[i].containerCache)) {

				// if we&#x27;ve already found a container and it&#x27;s more &quot;inner&quot; than this, then continue
				if(innermostContainer &amp;&amp; $.contains(this.containers[i].element[0], innermostContainer.element[0]))
					continue;

				innermostContainer = this.containers[i];
				innermostIndex = i;

			} else {
				// container doesn&#x27;t intersect. trigger &quot;out&quot; event if necessary
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger(&quot;out&quot;, event, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		// if no intersecting containers found, return
		if(!innermostContainer) return;

		// move the item into the container if it&#x27;s not there already
		if(this.containers.length === 1) {
			this.containers[innermostIndex]._trigger(&quot;over&quot;, event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		} else {

			//When entering a new container, we will find the item with the least distance and append our item near it
			var dist = 10000; var itemWithLeastDistance = null;
			var posProperty = this.containers[innermostIndex].floating ? &#x27;left&#x27; : &#x27;top&#x27;;
			var sizeProperty = this.containers[innermostIndex].floating ? &#x27;width&#x27; : &#x27;height&#x27;;
			var base = this.positionAbs[posProperty] + this.offset.click[posProperty];
			for (var j = this.items.length - 1; j &gt;= 0; j--) {
				if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) continue;
				if(this.items[j].item[0] == this.currentItem[0]) continue;
				var cur = this.items[j].item.offset()[posProperty];
				var nearBottom = false;
				if(Math.abs(cur - base) &gt; Math.abs(cur + this.items[j][sizeProperty] - base)){
					nearBottom = true;
					cur += this.items[j][sizeProperty];
				}

				if(Math.abs(cur - base) &lt; dist) {
					dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];
					this.direction = nearBottom ? &quot;up&quot;: &quot;down&quot;;
				}
			}

			if(!itemWithLeastDistance &amp;&amp; !this.options.dropOnEmpty) //Check if dropOnEmpty is enabled
				return;

			this.currentContainer = this.containers[innermostIndex];
			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
			this._trigger(&quot;change&quot;, event, this._uiHash());
			this.containers[innermostIndex]._trigger(&quot;change&quot;, event, this._uiHash(this));

			//Update the placeholder
			this.options.placeholder.update(this.currentContainer, this.placeholder);

			this.containers[innermostIndex]._trigger(&quot;over&quot;, event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		}


	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper == &#x27;clone&#x27; ? this.currentItem.clone() : this.currentItem);

		if(!helper.parents(&#x27;body&#x27;).length) //Add the helper to the DOM if that didn&#x27;t happen already
			$(o.appendTo != &#x27;parent&#x27; ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);

		if(helper[0] == this.currentItem[0])
			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css(&quot;position&quot;), top: this.currentItem.css(&quot;top&quot;), left: this.currentItem.css(&quot;left&quot;) };

		if(helper[0].style.width == &#x27;&#x27; || o.forceHelperSize) helper.width(this.currentItem.width());
		if(helper[0].style.height == &#x27;&#x27; || o.forceHelperSize) helper.height(this.currentItem.height());

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == &#x27;string&#x27;) {
			obj = obj.split(&#x27; &#x27;);
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if (&#x27;left&#x27; in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if (&#x27;right&#x27; in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if (&#x27;top&#x27; in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if (&#x27;bottom&#x27; in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {


		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it&#x27;s position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn&#x27;t the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == &#x27;absolute&#x27; &amp;&amp; this.scrollParent[0] != document &amp;&amp; $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
		|| (this.offsetParent[0].tagName &amp;&amp; this.offsetParent[0].tagName.toLowerCase() == &#x27;html&#x27; &amp;&amp; $.ui.ie)) //Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css(&quot;borderTopWidth&quot;),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css(&quot;borderLeftWidth&quot;),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == &quot;relative&quot;) {
			var p = this.currentItem.position();
			return {
				top: p.top - (parseInt(this.helper.css(&quot;top&quot;),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css(&quot;left&quot;),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.currentItem.css(&quot;marginLeft&quot;),10) || 0),
			top: (parseInt(this.currentItem.css(&quot;marginTop&quot;),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == &#x27;parent&#x27;) o.containment = this.helper[0].parentNode;
		if(o.containment == &#x27;document&#x27; || o.containment == &#x27;window&#x27;) this.containment = [
			0 - this.offset.relative.left - this.offset.parent.left,
			0 - this.offset.relative.top - this.offset.parent.top,
			$(o.containment == &#x27;document&#x27; ? document : window).width() - this.helperProportions.width - this.margins.left,
			($(o.containment == &#x27;document&#x27; ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(/^(document|window|parent)$/).test(o.containment)) {
			var ce = $(o.containment)[0];
			var co = $(o.containment).offset();
			var over = ($(ce).css(&quot;overflow&quot;) != &#x27;hidden&#x27;);

			this.containment = [
				co.left + (parseInt($(ce).css(&quot;borderLeftWidth&quot;),10) || 0) + (parseInt($(ce).css(&quot;paddingLeft&quot;),10) || 0) - this.margins.left,
				co.top + (parseInt($(ce).css(&quot;borderTopWidth&quot;),10) || 0) + (parseInt($(ce).css(&quot;paddingTop&quot;),10) || 0) - this.margins.top,
				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css(&quot;borderLeftWidth&quot;),10) || 0) - (parseInt($(ce).css(&quot;paddingRight&quot;),10) || 0) - this.helperProportions.width - this.margins.left,
				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css(&quot;borderTopWidth&quot;),10) || 0) - (parseInt($(ce).css(&quot;paddingBottom&quot;),10) || 0) - this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == &quot;absolute&quot; ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == &#x27;absolute&#x27; &amp;&amp; !(this.scrollParent[0] != document &amp;&amp; $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	// The absolute mouse position
				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											// The offsetParent&#x27;s offset without borders (offset + border)
				- ( ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																// The absolute mouse position
				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											// The offsetParent&#x27;s offset without borders (offset + border)
				- ( ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == &#x27;absolute&#x27; &amp;&amp; !(this.scrollParent[0] != document &amp;&amp; $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		// This is another very weird special case that only happens for relative elements:
		// 1. If the css position is relative
		// 2. and the scroll parent is the document or similar to the offset parent
		// we have to refresh the relative offset during the scroll so there are no jumps
		if(this.cssPosition == &#x27;relative&#x27; &amp;&amp; !(this.scrollParent[0] != document &amp;&amp; this.scrollParent[0] != this.offsetParent[0])) {
			this.offset.relative = this._getRelativeOffset();
		}

		var pageX = event.pageX;
		var pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won&#x27;t check for options

			if(this.containment) {
				if(event.pageX - this.offset.click.left &lt; this.containment[0]) pageX = this.containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top &lt; this.containment[1]) pageY = this.containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left &gt; this.containment[2]) pageX = this.containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top &gt; this.containment[3]) pageY = this.containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				var top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
				pageY = this.containment ? (!(top - this.offset.click.top &lt; this.containment[1] || top - this.offset.click.top &gt; this.containment[3]) ? top : (!(top - this.offset.click.top &lt; this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
				pageX = this.containment ? (!(left - this.offset.click.left &lt; this.containment[0] || left - this.offset.click.left &gt; this.containment[2]) ? left : (!(left - this.offset.click.left &lt; this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																// The absolute mouse position
				- this.offset.click.top													// Click offset (relative to the element)
				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												// The offsetParent&#x27;s offset without borders (offset + border)
				+ ( ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																// The absolute mouse position
				- this.offset.click.left												// Click offset (relative to the element)
				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												// The offsetParent&#x27;s offset without borders (offset + border)
				+ ( ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_rearrange: function(event, i, a, hardRefresh) {

		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction == &#x27;down&#x27; ? i.item[0] : i.item[0].nextSibling));

		//Various things done here to improve the performance:
		// 1. we create a setTimeout, that calls refreshPositions
		// 2. on the instance, we have a counter variable, that get&#x27;s higher after every append
		// 3. on the local scope, we copy the counter variable, and check in the timeout, if it&#x27;s still the same
		// 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var counter = this.counter;

		this._delay(function() {
			if(counter == this.counter) this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
		});

	},

	_clear: function(event, noPropagation) {

		this.reverting = false;
		// We delay all events that have to be triggered to after the point where the placeholder has been removed and
		// everything else normalized again
		var delayedTriggers = [];

		// We first have to update the dom position of the actual currentItem
		// Note: don&#x27;t do it if the current item is already removed (by a user), or it gets reappended (see #4088)
		if(!this._noFinalSort &amp;&amp; this.currentItem.parent().length) this.placeholder.before(this.currentItem);
		this._noFinalSort = null;

		if(this.helper[0] == this.currentItem[0]) {
			for(var i in this._storedCSS) {
				if(this._storedCSS[i] == &#x27;auto&#x27; || this._storedCSS[i] == &#x27;static&#x27;) this._storedCSS[i] = &#x27;&#x27;;
			}
			this.currentItem.css(this._storedCSS).removeClass(&quot;ui-sortable-helper&quot;);
		} else {
			this.currentItem.show();
		}

		if(this.fromOutside &amp;&amp; !noPropagation) delayedTriggers.push(function(event) { this._trigger(&quot;receive&quot;, event, this._uiHash(this.fromOutside)); });
		if((this.fromOutside || this.domPosition.prev != this.currentItem.prev().not(&quot;.ui-sortable-helper&quot;)[0] || this.domPosition.parent != this.currentItem.parent()[0]) &amp;&amp; !noPropagation) delayedTriggers.push(function(event) { this._trigger(&quot;update&quot;, event, this._uiHash()); }); //Trigger update callback if the DOM position has changed

		// Check if the items Container has Changed and trigger appropriate
		// events.
		if (this !== this.currentContainer) {
			if(!noPropagation) {
				delayedTriggers.push(function(event) { this._trigger(&quot;remove&quot;, event, this._uiHash()); });
				delayedTriggers.push((function(c) { return function(event) { c._trigger(&quot;receive&quot;, event, this._uiHash(this)); };  }).call(this, this.currentContainer));
				delayedTriggers.push((function(c) { return function(event) { c._trigger(&quot;update&quot;, event, this._uiHash(this));  }; }).call(this, this.currentContainer));
			}
		}


		//Post events to containers
		for (var i = this.containers.length - 1; i &gt;= 0; i--){
			if(!noPropagation) delayedTriggers.push((function(c) { return function(event) { c._trigger(&quot;deactivate&quot;, event, this._uiHash(this)); };  }).call(this, this.containers[i]));
			if(this.containers[i].containerCache.over) {
				delayedTriggers.push((function(c) { return function(event) { c._trigger(&quot;out&quot;, event, this._uiHash(this)); };  }).call(this, this.containers[i]));
				this.containers[i].containerCache.over = 0;
			}
		}

		//Do what was originally in plugins
		if(this._storedCursor) $(&#x27;body&#x27;).css(&quot;cursor&quot;, this._storedCursor); //Reset cursor
		if(this._storedOpacity) this.helper.css(&quot;opacity&quot;, this._storedOpacity); //Reset opacity
		if(this._storedZIndex) this.helper.css(&quot;zIndex&quot;, this._storedZIndex == &#x27;auto&#x27; ? &#x27;&#x27; : this._storedZIndex); //Reset z-index

		this.dragging = false;
		if(this.cancelHelperRemoval) {
			if(!noPropagation) {
				this._trigger(&quot;beforeStop&quot;, event, this._uiHash());
				for (var i=0; i &lt; delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
				this._trigger(&quot;stop&quot;, event, this._uiHash());
			}

			this.fromOutside = false;
			return false;
		}

		if(!noPropagation) this._trigger(&quot;beforeStop&quot;, event, this._uiHash());

		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

		if(this.helper[0] != this.currentItem[0]) this.helper.remove(); this.helper = null;

		if(!noPropagation) {
			for (var i=0; i &lt; delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
			this._trigger(&quot;stop&quot;, event, this._uiHash());
		}

		this.fromOutside = false;
		return true;

	},

	_trigger: function() {
		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
			this.cancel();
		}
	},

	_uiHash: function(_inst) {
		var inst = _inst || this;
		return {
			helper: inst.helper,
			placeholder: inst.placeholder || $([]),
			position: inst.position,
			originalPosition: inst.originalPosition,
			offset: inst.positionAbs,
			item: inst.currentItem,
			sender: _inst ? _inst.element : null
		};
	}

});

})(jQuery);

;(jQuery.effects || (function($, undefined) {

var backCompat = $.uiBackCompat !== false,
	// prefix used for storing data on .data()
	dataSpace = &quot;ui-effects-&quot;;

$.effects = {
	effect: {}
};

/*!
 * jQuery Color Animations v2.0.0
 * http://jquery.com/
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Mon Aug 13 13:41:02 2012 -0500
 */
(function( jQuery, undefined ) {

	var stepHooks = &quot;backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor&quot;.split(&quot; &quot;),

	// plusequals test for += 100 -= 100
	rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
	// a set of RE&#x27;s that can match strings and generate color tuples.
	stringParsers = [{
			re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ],
					execResult[ 3 ],
					execResult[ 4 ]
				];
			}
		}, {
			re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ] * 2.55,
					execResult[ 2 ] * 2.55,
					execResult[ 3 ] * 2.55,
					execResult[ 4 ]
				];
			}
		}, {
			// this regex ignores A-F because it&#x27;s compared against an already lowercased string
			re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ], 16 )
				];
			}
		}, {
			// this regex ignores A-F because it&#x27;s compared against an already lowercased string
			re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
				];
			}
		}, {
			re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
			space: &quot;hsla&quot;,
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ] / 100,
					execResult[ 3 ] / 100,
					execResult[ 4 ]
				];
			}
		}],

	// jQuery.Color( )
	color = jQuery.Color = function( color, green, blue, alpha ) {
		return new jQuery.Color.fn.parse( color, green, blue, alpha );
	},
	spaces = {
		rgba: {
			props: {
				red: {
					idx: 0,
					type: &quot;byte&quot;
				},
				green: {
					idx: 1,
					type: &quot;byte&quot;
				},
				blue: {
					idx: 2,
					type: &quot;byte&quot;
				}
			}
		},

		hsla: {
			props: {
				hue: {
					idx: 0,
					type: &quot;degrees&quot;
				},
				saturation: {
					idx: 1,
					type: &quot;percent&quot;
				},
				lightness: {
					idx: 2,
					type: &quot;percent&quot;
				}
			}
		}
	},
	propTypes = {
		&quot;byte&quot;: {
			floor: true,
			max: 255
		},
		&quot;percent&quot;: {
			max: 1
		},
		&quot;degrees&quot;: {
			mod: 360,
			floor: true
		}
	},
	support = color.support = {},

	// element for support tests
	supportElem = jQuery( &quot;&lt;p&gt;&quot; )[ 0 ],

	// colors = jQuery.Color.names
	colors,

	// local aliases of functions called often
	each = jQuery.each;

// determine rgba support immediately
supportElem.style.cssText = &quot;background-color:rgba(1,1,1,.5)&quot;;
support.rgba = supportElem.style.backgroundColor.indexOf( &quot;rgba&quot; ) &gt; -1;

// define cache name and alpha properties
// for rgba and hsla spaces
each( spaces, function( spaceName, space ) {
	space.cache = &quot;_&quot; + spaceName;
	space.props.alpha = {
		idx: 3,
		type: &quot;percent&quot;,
		def: 1
	};
});

function clamp( value, prop, allowEmpty ) {
	var type = propTypes[ prop.type ] || {};

	if ( value == null ) {
		return (allowEmpty || !prop.def) ? null : prop.def;
	}

	// ~~ is an short way of doing floor for positive numbers
	value = type.floor ? ~~value : parseFloat( value );

	// IE will pass in empty strings as value for alpha,
	// which will hit this case
	if ( isNaN( value ) ) {
		return prop.def;
	}

	if ( type.mod ) {
		// we add mod before modding to make sure that negatives values
		// get converted properly: -10 -&gt; 350
		return (value + type.mod) % type.mod;
	}

	// for now all property types without mod have min and max
	return 0 &gt; value ? 0 : type.max &lt; value ? type.max : value;
}

function stringParse( string ) {
	var inst = color(),
		rgba = inst._rgba = [];

	string = string.toLowerCase();

	each( stringParsers, function( i, parser ) {
		var parsed,
			match = parser.re.exec( string ),
			values = match &amp;&amp; parser.parse( match ),
			spaceName = parser.space || &quot;rgba&quot;;

		if ( values ) {
			parsed = inst[ spaceName ]( values );

			// if this was an rgba parse the assignment might happen twice
			// oh well....
			inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
			rgba = inst._rgba = parsed._rgba;

			// exit each( stringParsers ) here because we matched
			return false;
		}
	});

	// Found a stringParser that handled it
	if ( rgba.length ) {

		// if this came from a parsed string, force &quot;transparent&quot; when alpha is 0
		// chrome, (and maybe others) return &quot;transparent&quot; as rgba(0,0,0,0)
		if ( rgba.join() === &quot;0,0,0,0&quot; ) {
			jQuery.extend( rgba, colors.transparent );
		}
		return inst;
	}

	// named colors
	return colors[ string ];
}

color.fn = jQuery.extend( color.prototype, {
	parse: function( red, green, blue, alpha ) {
		if ( red === undefined ) {
			this._rgba = [ null, null, null, null ];
			return this;
		}
		if ( red.jquery || red.nodeType ) {
			red = jQuery( red ).css( green );
			green = undefined;
		}

		var inst = this,
			type = jQuery.type( red ),
			rgba = this._rgba = [];

		// more than 1 argument specified - assume ( red, green, blue, alpha )
		if ( green !== undefined ) {
			red = [ red, green, blue, alpha ];
			type = &quot;array&quot;;
		}

		if ( type === &quot;string&quot; ) {
			return this.parse( stringParse( red ) || colors._default );
		}

		if ( type === &quot;array&quot; ) {
			each( spaces.rgba.props, function( key, prop ) {
				rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
			});
			return this;
		}

		if ( type === &quot;object&quot; ) {
			if ( red instanceof color ) {
				each( spaces, function( spaceName, space ) {
					if ( red[ space.cache ] ) {
						inst[ space.cache ] = red[ space.cache ].slice();
					}
				});
			} else {
				each( spaces, function( spaceName, space ) {
					var cache = space.cache;
					each( space.props, function( key, prop ) {

						// if the cache doesn&#x27;t exist, and we know how to convert
						if ( !inst[ cache ] &amp;&amp; space.to ) {

							// if the value was null, we don&#x27;t need to copy it
							// if the key was alpha, we don&#x27;t need to copy it either
							if ( key === &quot;alpha&quot; || red[ key ] == null ) {
								return;
							}
							inst[ cache ] = space.to( inst._rgba );
						}

						// this is the only case where we allow nulls for ALL properties.
						// call clamp with alwaysAllowEmpty
						inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
					});

					// everything defined but alpha?
					if ( inst[ cache ] &amp;&amp; $.inArray( null, inst[ cache ].slice( 0, 3 ) ) &lt; 0 ) {
						// use the default of 1
						inst[ cache ][ 3 ] = 1;
						if ( space.from ) {
							inst._rgba = space.from( inst[ cache ] );
						}
					}
				});
			}
			return this;
		}
	},
	is: function( compare ) {
		var is = color( compare ),
			same = true,
			inst = this;

		each( spaces, function( _, space ) {
			var localCache,
				isCache = is[ space.cache ];
			if (isCache) {
				localCache = inst[ space.cache ] || space.to &amp;&amp; space.to( inst._rgba ) || [];
				each( space.props, function( _, prop ) {
					if ( isCache[ prop.idx ] != null ) {
						same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
						return same;
					}
				});
			}
			return same;
		});
		return same;
	},
	_space: function() {
		var used = [],
			inst = this;
		each( spaces, function( spaceName, space ) {
			if ( inst[ space.cache ] ) {
				used.push( spaceName );
			}
		});
		return used.pop();
	},
	transition: function( other, distance ) {
		var end = color( other ),
			spaceName = end._space(),
			space = spaces[ spaceName ],
			startColor = this.alpha() === 0 ? color( &quot;transparent&quot; ) : this,
			start = startColor[ space.cache ] || space.to( startColor._rgba ),
			result = start.slice();

		end = end[ space.cache ];
		each( space.props, function( key, prop ) {
			var index = prop.idx,
				startValue = start[ index ],
				endValue = end[ index ],
				type = propTypes[ prop.type ] || {};

			// if null, don&#x27;t override start value
			if ( endValue === null ) {
				return;
			}
			// if null - use end
			if ( startValue === null ) {
				result[ index ] = endValue;
			} else {
				if ( type.mod ) {
					if ( endValue - startValue &gt; type.mod / 2 ) {
						startValue += type.mod;
					} else if ( startValue - endValue &gt; type.mod / 2 ) {
						startValue -= type.mod;
					}
				}
				result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
			}
		});
		return this[ spaceName ]( result );
	},
	blend: function( opaque ) {
		// if we are already opaque - return ourself
		if ( this._rgba[ 3 ] === 1 ) {
			return this;
		}

		var rgb = this._rgba.slice(),
			a = rgb.pop(),
			blend = color( opaque )._rgba;

		return color( jQuery.map( rgb, function( v, i ) {
			return ( 1 - a ) * blend[ i ] + a * v;
		}));
	},
	toRgbaString: function() {
		var prefix = &quot;rgba(&quot;,
			rgba = jQuery.map( this._rgba, function( v, i ) {
				return v == null ? ( i &gt; 2 ? 1 : 0 ) : v;
			});

		if ( rgba[ 3 ] === 1 ) {
			rgba.pop();
			prefix = &quot;rgb(&quot;;
		}

		return prefix + rgba.join() + &quot;)&quot;;
	},
	toHslaString: function() {
		var prefix = &quot;hsla(&quot;,
			hsla = jQuery.map( this.hsla(), function( v, i ) {
				if ( v == null ) {
					v = i &gt; 2 ? 1 : 0;
				}

				// catch 1 and 2
				if ( i &amp;&amp; i &lt; 3 ) {
					v = Math.round( v * 100 ) + &quot;%&quot;;
				}
				return v;
			});

		if ( hsla[ 3 ] === 1 ) {
			hsla.pop();
			prefix = &quot;hsl(&quot;;
		}
		return prefix + hsla.join() + &quot;)&quot;;
	},
	toHexString: function( includeAlpha ) {
		var rgba = this._rgba.slice(),
			alpha = rgba.pop();

		if ( includeAlpha ) {
			rgba.push( ~~( alpha * 255 ) );
		}

		return &quot;#&quot; + jQuery.map( rgba, function( v ) {

			// default to 0 when nulls exist
			v = ( v || 0 ).toString( 16 );
			return v.length === 1 ? &quot;0&quot; + v : v;
		}).join(&quot;&quot;);
	},
	toString: function() {
		return this._rgba[ 3 ] === 0 ? &quot;transparent&quot; : this.toRgbaString();
	}
});
color.fn.parse.prototype = color.fn;

// hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

function hue2rgb( p, q, h ) {
	h = ( h + 1 ) % 1;
	if ( h * 6 &lt; 1 ) {
		return p + (q - p) * h * 6;
	}
	if ( h * 2 &lt; 1) {
		return q;
	}
	if ( h * 3 &lt; 2 ) {
		return p + (q - p) * ((2/3) - h) * 6;
	}
	return p;
}

spaces.hsla.to = function ( rgba ) {
	if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
		return [ null, null, null, rgba[ 3 ] ];
	}
	var r = rgba[ 0 ] / 255,
		g = rgba[ 1 ] / 255,
		b = rgba[ 2 ] / 255,
		a = rgba[ 3 ],
		max = Math.max( r, g, b ),
		min = Math.min( r, g, b ),
		diff = max - min,
		add = max + min,
		l = add * 0.5,
		h, s;

	if ( min === max ) {
		h = 0;
	} else if ( r === max ) {
		h = ( 60 * ( g - b ) / diff ) + 360;
	} else if ( g === max ) {
		h = ( 60 * ( b - r ) / diff ) + 120;
	} else {
		h = ( 60 * ( r - g ) / diff ) + 240;
	}

	if ( l === 0 || l === 1 ) {
		s = l;
	} else if ( l &lt;= 0.5 ) {
		s = diff / add;
	} else {
		s = diff / ( 2 - add );
	}
	return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
};

spaces.hsla.from = function ( hsla ) {
	if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
		return [ null, null, null, hsla[ 3 ] ];
	}
	var h = hsla[ 0 ] / 360,
		s = hsla[ 1 ],
		l = hsla[ 2 ],
		a = hsla[ 3 ],
		q = l &lt;= 0.5 ? l * ( 1 + s ) : l + s - l * s,
		p = 2 * l - q;

	return [
		Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
		Math.round( hue2rgb( p, q, h ) * 255 ),
		Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
		a
	];
};


each( spaces, function( spaceName, space ) {
	var props = space.props,
		cache = space.cache,
		to = space.to,
		from = space.from;

	// makes rgba() and hsla()
	color.fn[ spaceName ] = function( value ) {

		// generate a cache for this space if it doesn&#x27;t exist
		if ( to &amp;&amp; !this[ cache ] ) {
			this[ cache ] = to( this._rgba );
		}
		if ( value === undefined ) {
			return this[ cache ].slice();
		}

		var ret,
			type = jQuery.type( value ),
			arr = ( type === &quot;array&quot; || type === &quot;object&quot; ) ? value : arguments,
			local = this[ cache ].slice();

		each( props, function( key, prop ) {
			var val = arr[ type === &quot;object&quot; ? key : prop.idx ];
			if ( val == null ) {
				val = local[ prop.idx ];
			}
			local[ prop.idx ] = clamp( val, prop );
		});

		if ( from ) {
			ret = color( from( local ) );
			ret[ cache ] = local;
			return ret;
		} else {
			return color( local );
		}
	};

	// makes red() green() blue() alpha() hue() saturation() lightness()
	each( props, function( key, prop ) {
		// alpha is included in more than one space
		if ( color.fn[ key ] ) {
			return;
		}
		color.fn[ key ] = function( value ) {
			var vtype = jQuery.type( value ),
				fn = ( key === &quot;alpha&quot; ? ( this._hsla ? &quot;hsla&quot; : &quot;rgba&quot; ) : spaceName ),
				local = this[ fn ](),
				cur = local[ prop.idx ],
				match;

			if ( vtype === &quot;undefined&quot; ) {
				return cur;
			}

			if ( vtype === &quot;function&quot; ) {
				value = value.call( this, cur );
				vtype = jQuery.type( value );
			}
			if ( value == null &amp;&amp; prop.empty ) {
				return this;
			}
			if ( vtype === &quot;string&quot; ) {
				match = rplusequals.exec( value );
				if ( match ) {
					value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === &quot;+&quot; ? 1 : -1 );
				}
			}
			local[ prop.idx ] = value;
			return this[ fn ]( local );
		};
	});
});

// add .fx.step functions
each( stepHooks, function( i, hook ) {
	jQuery.cssHooks[ hook ] = {
		set: function( elem, value ) {
			var parsed, curElem,
				backgroundColor = &quot;&quot;;

			if ( jQuery.type( value ) !== &quot;string&quot; || ( parsed = stringParse( value ) ) ) {
				value = color( parsed || value );
				if ( !support.rgba &amp;&amp; value._rgba[ 3 ] !== 1 ) {
					curElem = hook === &quot;backgroundColor&quot; ? elem.parentNode : elem;
					while (
						(backgroundColor === &quot;&quot; || backgroundColor === &quot;transparent&quot;) &amp;&amp;
						curElem &amp;&amp; curElem.style
					) {
						try {
							backgroundColor = jQuery.css( curElem, &quot;backgroundColor&quot; );
							curElem = curElem.parentNode;
						} catch ( e ) {
						}
					}

					value = value.blend( backgroundColor &amp;&amp; backgroundColor !== &quot;transparent&quot; ?
						backgroundColor :
						&quot;_default&quot; );
				}

				value = value.toRgbaString();
			}
			try {
				elem.style[ hook ] = value;
			} catch( error ) {
				// wrapped to prevent IE from throwing errors on &quot;invalid&quot; values like &#x27;auto&#x27; or &#x27;inherit&#x27;
			}
		}
	};
	jQuery.fx.step[ hook ] = function( fx ) {
		if ( !fx.colorInit ) {
			fx.start = color( fx.elem, hook );
			fx.end = color( fx.end );
			fx.colorInit = true;
		}
		jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
	};
});

jQuery.cssHooks.borderColor = {
	expand: function( value ) {
		var expanded = {};

		each( [ &quot;Top&quot;, &quot;Right&quot;, &quot;Bottom&quot;, &quot;Left&quot; ], function( i, part ) {
			expanded[ &quot;border&quot; + part + &quot;Color&quot; ] = value;
		});
		return expanded;
	}
};

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
colors = jQuery.Color.names = {
	// 4.1. Basic color keywords
	aqua: &quot;#00ffff&quot;,
	black: &quot;#000000&quot;,
	blue: &quot;#0000ff&quot;,
	fuchsia: &quot;#ff00ff&quot;,
	gray: &quot;#808080&quot;,
	green: &quot;#008000&quot;,
	lime: &quot;#00ff00&quot;,
	maroon: &quot;#800000&quot;,
	navy: &quot;#000080&quot;,
	olive: &quot;#808000&quot;,
	purple: &quot;#800080&quot;,
	red: &quot;#ff0000&quot;,
	silver: &quot;#c0c0c0&quot;,
	teal: &quot;#008080&quot;,
	white: &quot;#ffffff&quot;,
	yellow: &quot;#ffff00&quot;,

	// 4.2.3. &quot;transparent&quot; color keyword
	transparent: [ null, null, null, 0 ],

	_default: &quot;#ffffff&quot;
};

})( jQuery );



/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/
(function() {

var classAnimationActions = [ &quot;add&quot;, &quot;remove&quot;, &quot;toggle&quot; ],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

$.each([ &quot;borderLeftStyle&quot;, &quot;borderRightStyle&quot;, &quot;borderBottomStyle&quot;, &quot;borderTopStyle&quot; ], function( _, prop ) {
	$.fx.step[ prop ] = function( fx ) {
		if ( fx.end !== &quot;none&quot; &amp;&amp; !fx.setAttr || fx.pos === 1 &amp;&amp; !fx.setAttr ) {
			jQuery.style( fx.elem, prop, fx.end );
			fx.setAttr = true;
		}
	};
});

function getElementStyles() {
	var style = this.ownerDocument.defaultView ?
			this.ownerDocument.defaultView.getComputedStyle( this, null ) :
			this.currentStyle,
		newStyle = {},
		key,
		len;

	// webkit enumerates style porperties
	if ( style &amp;&amp; style.length &amp;&amp; style[ 0 ] &amp;&amp; style[ style[ 0 ] ] ) {
		len = style.length;
		while ( len-- ) {
			key = style[ len ];
			if ( typeof style[ key ] === &quot;string&quot; ) {
				newStyle[ $.camelCase( key ) ] = style[ key ];
			}
		}
	} else {
		for ( key in style ) {
			if ( typeof style[ key ] === &quot;string&quot; ) {
				newStyle[ key ] = style[ key ];
			}
		}
	}

	return newStyle;
}


function styleDifference( oldStyle, newStyle ) {
	var diff = {},
		name, value;

	for ( name in newStyle ) {
		value = newStyle[ name ];
		if ( oldStyle[ name ] !== value ) {
			if ( !shorthandStyles[ name ] ) {
				if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
					diff[ name ] = value;
				}
			}
		}
	}

	return diff;
}

$.effects.animateClass = function( value, duration, easing, callback ) {
	var o = $.speed( duration, easing, callback );

	return this.queue( function() {
		var animated = $( this ),
			baseClass = animated.attr( &quot;class&quot; ) || &quot;&quot;,
			applyClassChange,
			allAnimations = o.children ? animated.find( &quot;*&quot; ).andSelf() : animated;

		// map the animated objects to store the original styles.
		allAnimations = allAnimations.map(function() {
			var el = $( this );
			return {
				el: el,
				start: getElementStyles.call( this )
			};
		});

		// apply class change
		applyClassChange = function() {
			$.each( classAnimationActions, function(i, action) {
				if ( value[ action ] ) {
					animated[ action + &quot;Class&quot; ]( value[ action ] );
				}
			});
		};
		applyClassChange();

		// map all animated objects again - calculate new styles and diff
		allAnimations = allAnimations.map(function() {
			this.end = getElementStyles.call( this.el[ 0 ] );
			this.diff = styleDifference( this.start, this.end );
			return this;
		});

		// apply original class
		animated.attr( &quot;class&quot;, baseClass );

		// map all animated objects again - this time collecting a promise
		allAnimations = allAnimations.map(function() {
			var styleInfo = this,
				dfd = $.Deferred(),
				opts = jQuery.extend({}, o, {
					queue: false,
					complete: function() {
						dfd.resolve( styleInfo );
					}
				});

			this.el.animate( this.diff, opts );
			return dfd.promise();
		});

		// once all animations have completed:
		$.when.apply( $, allAnimations.get() ).done(function() {

			// set the final class
			applyClassChange();

			// for each animated element,
			// clear all css properties that were animated
			$.each( arguments, function() {
				var el = this.el;
				$.each( this.diff, function(key) {
					el.css( key, &#x27;&#x27; );
				});
			});

			// this is guarnteed to be there if you use jQuery.speed()
			// it also handles dequeuing the next anim...
			o.complete.call( animated[ 0 ] );
		});
	});
};

$.fn.extend({
	_addClass: $.fn.addClass,
	addClass: function( classNames, speed, easing, callback ) {
		return speed ?
			$.effects.animateClass.call( this,
				{ add: classNames }, speed, easing, callback ) :
			this._addClass( classNames );
	},

	_removeClass: $.fn.removeClass,
	removeClass: function( classNames, speed, easing, callback ) {
		return speed ?
			$.effects.animateClass.call( this,
				{ remove: classNames }, speed, easing, callback ) :
			this._removeClass( classNames );
	},

	_toggleClass: $.fn.toggleClass,
	toggleClass: function( classNames, force, speed, easing, callback ) {
		if ( typeof force === &quot;boolean&quot; || force === undefined ) {
			if ( !speed ) {
				// without speed parameter
				return this._toggleClass( classNames, force );
			} else {
				return $.effects.animateClass.call( this,
					(force ? { add: classNames } : { remove: classNames }),
					speed, easing, callback );
			}
		} else {
			// without force parameter
			return $.effects.animateClass.call( this,
				{ toggle: classNames }, force, speed, easing );
		}
	},

	switchClass: function( remove, add, speed, easing, callback) {
		return $.effects.animateClass.call( this, {
			add: add,
			remove: remove
		}, speed, easing, callback );
	}
});

})();

/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

(function() {

$.extend( $.effects, {
	version: &quot;1.9.1&quot;,

	// Saves a set of properties in a data storage
	save: function( element, set ) {
		for( var i=0; i &lt; set.length; i++ ) {
			if ( set[ i ] !== null ) {
				element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
			}
		}
	},

	// Restores a set of previously saved properties from a data storage
	restore: function( element, set ) {
		var val, i;
		for( i=0; i &lt; set.length; i++ ) {
			if ( set[ i ] !== null ) {
				val = element.data( dataSpace + set[ i ] );
				// support: jQuery 1.6.2
				// http://bugs.jquery.com/ticket/9917
				// jQuery 1.6.2 incorrectly returns undefined for any falsy value.
				// We can&#x27;t differentiate between &quot;&quot; and 0 here, so we just assume
				// empty string since it&#x27;s likely to be a more common value...
				if ( val === undefined ) {
					val = &quot;&quot;;
				}
				element.css( set[ i ], val );
			}
		}
	},

	setMode: function( el, mode ) {
		if (mode === &quot;toggle&quot;) {
			mode = el.is( &quot;:hidden&quot; ) ? &quot;show&quot; : &quot;hide&quot;;
		}
		return mode;
	},

	// Translates a [top,left] array into a baseline value
	// this should be a little more flexible in the future to handle a string &amp; hash
	getBaseline: function( origin, original ) {
		var y, x;
		switch ( origin[ 0 ] ) {
			case &quot;top&quot;: y = 0; break;
			case &quot;middle&quot;: y = 0.5; break;
			case &quot;bottom&quot;: y = 1; break;
			default: y = origin[ 0 ] / original.height;
		}
		switch ( origin[ 1 ] ) {
			case &quot;left&quot;: x = 0; break;
			case &quot;center&quot;: x = 0.5; break;
			case &quot;right&quot;: x = 1; break;
			default: x = origin[ 1 ] / original.width;
		}
		return {
			x: x,
			y: y
		};
	},

	// Wraps the element around a wrapper that copies position properties
	createWrapper: function( element ) {

		// if the element is already wrapped, return it
		if ( element.parent().is( &quot;.ui-effects-wrapper&quot; )) {
			return element.parent();
		}

		// wrap the element
		var props = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				&quot;float&quot;: element.css( &quot;float&quot; )
			},
			wrapper = $( &quot;&lt;div&gt;&lt;/div&gt;&quot; )
				.addClass( &quot;ui-effects-wrapper&quot; )
				.css({
					fontSize: &quot;100%&quot;,
					background: &quot;transparent&quot;,
					border: &quot;none&quot;,
					margin: 0,
					padding: 0
				}),
			// Store the size in case width/height are defined in % - Fixes #5245
			size = {
				width: element.width(),
				height: element.height()
			},
			active = document.activeElement;

		// support: Firefox
		// Firefox incorrectly exposes anonymous content
		// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
		try {
			active.id;
		} catch( e ) {
			active = document.body;
		}

		element.wrap( wrapper );

		// Fixes #7595 - Elements lose focus when wrapped.
		if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
			$( active ).focus();
		}

		wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element

		// transfer positioning properties to the wrapper
		if ( element.css( &quot;position&quot; ) === &quot;static&quot; ) {
			wrapper.css({ position: &quot;relative&quot; });
			element.css({ position: &quot;relative&quot; });
		} else {
			$.extend( props, {
				position: element.css( &quot;position&quot; ),
				zIndex: element.css( &quot;z-index&quot; )
			});
			$.each([ &quot;top&quot;, &quot;left&quot;, &quot;bottom&quot;, &quot;right&quot; ], function(i, pos) {
				props[ pos ] = element.css( pos );
				if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
					props[ pos ] = &quot;auto&quot;;
				}
			});
			element.css({
				position: &quot;relative&quot;,
				top: 0,
				left: 0,
				right: &quot;auto&quot;,
				bottom: &quot;auto&quot;
			});
		}
		element.css(size);

		return wrapper.css( props ).show();
	},

	removeWrapper: function( element ) {
		var active = document.activeElement;

		if ( element.parent().is( &quot;.ui-effects-wrapper&quot; ) ) {
			element.parent().replaceWith( element );

			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
		}


		return element;
	},

	setTransition: function( element, list, factor, value ) {
		value = value || {};
		$.each( list, function( i, x ) {
			var unit = element.cssUnit( x );
			if ( unit[ 0 ] &gt; 0 ) {
				value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
			}
		});
		return value;
	}
});

// return an effect options object for the given parameters:
function _normalizeArguments( effect, options, speed, callback ) {

	// allow passing all options as the first parameter
	if ( $.isPlainObject( effect ) ) {
		options = effect;
		effect = effect.effect;
	}

	// convert to an object
	effect = { effect: effect };

	// catch (effect, null, ...)
	if ( options == null ) {
		options = {};
	}

	// catch (effect, callback)
	if ( $.isFunction( options ) ) {
		callback = options;
		speed = null;
		options = {};
	}

	// catch (effect, speed, ?)
	if ( typeof options === &quot;number&quot; || $.fx.speeds[ options ] ) {
		callback = speed;
		speed = options;
		options = {};
	}

	// catch (effect, options, callback)
	if ( $.isFunction( speed ) ) {
		callback = speed;
		speed = null;
	}

	// add options to effect
	if ( options ) {
		$.extend( effect, options );
	}

	speed = speed || options.duration;
	effect.duration = $.fx.off ? 0 :
		typeof speed === &quot;number&quot; ? speed :
		speed in $.fx.speeds ? $.fx.speeds[ speed ] :
		$.fx.speeds._default;

	effect.complete = callback || options.complete;

	return effect;
}

function standardSpeed( speed ) {
	// valid standard speeds
	if ( !speed || typeof speed === &quot;number&quot; || $.fx.speeds[ speed ] ) {
		return true;
	}

	// invalid strings - treat as &quot;normal&quot; speed
	if ( typeof speed === &quot;string&quot; &amp;&amp; !$.effects.effect[ speed ] ) {
		// TODO: remove in 2.0 (#7115)
		if ( backCompat &amp;&amp; $.effects[ speed ] ) {
			return false;
		}
		return true;
	}

	return false;
}

$.fn.extend({
	effect: function( /* effect, options, speed, callback */ ) {
		var args = _normalizeArguments.apply( this, arguments ),
			mode = args.mode,
			queue = args.queue,
			effectMethod = $.effects.effect[ args.effect ],

			// DEPRECATED: remove in 2.0 (#7115)
			oldEffectMethod = !effectMethod &amp;&amp; backCompat &amp;&amp; $.effects[ args.effect ];

		if ( $.fx.off || !( effectMethod || oldEffectMethod ) ) {
			// delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args.duration, args.complete );
			} else {
				return this.each( function() {
					if ( args.complete ) {
						args.complete.call( this );
					}
				});
			}
		}

		function run( next ) {
			var elem = $( this ),
				complete = args.complete,
				mode = args.mode;

			function done() {
				if ( $.isFunction( complete ) ) {
					complete.call( elem[0] );
				}
				if ( $.isFunction( next ) ) {
					next();
				}
			}

			// if the element is hiddden and mode is hide,
			// or element is visible and mode is show
			if ( elem.is( &quot;:hidden&quot; ) ? mode === &quot;hide&quot; : mode === &quot;show&quot; ) {
				done();
			} else {
				effectMethod.call( elem[0], args, done );
			}
		}

		// TODO: remove this check in 2.0, effectMethod will always be true
		if ( effectMethod ) {
			return queue === false ? this.each( run ) : this.queue( queue || &quot;fx&quot;, run );
		} else {
			// DEPRECATED: remove in 2.0 (#7115)
			return oldEffectMethod.call(this, {
				options: args,
				duration: args.duration,
				callback: args.complete,
				mode: args.mode
			});
		}
	},

	_show: $.fn.show,
	show: function( speed ) {
		if ( standardSpeed( speed ) ) {
			return this._show.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = &quot;show&quot;;
			return this.effect.call( this, args );
		}
	},

	_hide: $.fn.hide,
	hide: function( speed ) {
		if ( standardSpeed( speed ) ) {
			return this._hide.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = &quot;hide&quot;;
			return this.effect.call( this, args );
		}
	},

	// jQuery core overloads toggle and creates _toggle
	__toggle: $.fn.toggle,
	toggle: function( speed ) {
		if ( standardSpeed( speed ) || typeof speed === &quot;boolean&quot; || $.isFunction( speed ) ) {
			return this.__toggle.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = &quot;toggle&quot;;
			return this.effect.call( this, args );
		}
	},

	// helper functions
	cssUnit: function(key) {
		var style = this.css( key ),
			val = [];

		$.each( [ &quot;em&quot;, &quot;px&quot;, &quot;%&quot;, &quot;pt&quot; ], function( i, unit ) {
			if ( style.indexOf( unit ) &gt; 0 ) {
				val = [ parseFloat( style ), unit ];
			}
		});
		return val;
	}
});

})();

/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

(function() {

// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

var baseEasings = {};

$.each( [ &quot;Quad&quot;, &quot;Cubic&quot;, &quot;Quart&quot;, &quot;Quint&quot;, &quot;Expo&quot; ], function( i, name ) {
	baseEasings[ name ] = function( p ) {
		return Math.pow( p, i + 2 );
	};
});

$.extend( baseEasings, {
	Sine: function ( p ) {
		return 1 - Math.cos( p * Math.PI / 2 );
	},
	Circ: function ( p ) {
		return 1 - Math.sqrt( 1 - p * p );
	},
	Elastic: function( p ) {
		return p === 0 || p === 1 ? p :
			-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
	},
	Back: function( p ) {
		return p * p * ( 3 * p - 2 );
	},
	Bounce: function ( p ) {
		var pow2,
			bounce = 4;

		while ( p &lt; ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
		return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
	}
});

$.each( baseEasings, function( name, easeIn ) {
	$.easing[ &quot;easeIn&quot; + name ] = easeIn;
	$.easing[ &quot;easeOut&quot; + name ] = function( p ) {
		return 1 - easeIn( 1 - p );
	};
	$.easing[ &quot;easeInOut&quot; + name ] = function( p ) {
		return p &lt; 0.5 ?
			easeIn( p * 2 ) / 2 :
			1 - easeIn( p * -2 + 2 ) / 2;
	};
});

})();

})(jQuery));

(function( $, undefined ) {

var uid = 0,
	hideProps = {},
	showProps = {};

hideProps.height = hideProps.paddingTop = hideProps.paddingBottom =
	hideProps.borderTopWidth = hideProps.borderBottomWidth = &quot;hide&quot;;
showProps.height = showProps.paddingTop = showProps.paddingBottom =
	showProps.borderTopWidth = showProps.borderBottomWidth = &quot;show&quot;;

$.widget( &quot;ui.accordion&quot;, {
	version: &quot;1.9.1&quot;,
	options: {
		active: 0,
		animate: {},
		collapsible: false,
		event: &quot;click&quot;,
		header: &quot;&gt; li &gt; :first-child,&gt; :not(li):even&quot;,
		heightStyle: &quot;auto&quot;,
		icons: {
			activeHeader: &quot;ui-icon-triangle-1-s&quot;,
			header: &quot;ui-icon-triangle-1-e&quot;
		},

		// callbacks
		activate: null,
		beforeActivate: null
	},

	_create: function() {
		var accordionId = this.accordionId = &quot;ui-accordion-&quot; +
				(this.element.attr( &quot;id&quot; ) || ++uid),
			options = this.options;

		this.prevShow = this.prevHide = $();
		this.element.addClass( &quot;ui-accordion ui-widget ui-helper-reset&quot; );

		this.headers = this.element.find( options.header )
			.addClass( &quot;ui-accordion-header ui-helper-reset ui-state-default ui-corner-all&quot; );
		this._hoverable( this.headers );
		this._focusable( this.headers );

		this.headers.next()
			.addClass( &quot;ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom&quot; )
			.hide();

		// don&#x27;t allow collapsible: false and active: false / null
		if ( !options.collapsible &amp;&amp; (options.active === false || options.active == null) ) {
			options.active = 0;
		}
		// handle negative values
		if ( options.active &lt; 0 ) {
			options.active += this.headers.length;
		}
		this.active = this._findActive( options.active )
			.addClass( &quot;ui-accordion-header-active ui-state-active&quot; )
			.toggleClass( &quot;ui-corner-all ui-corner-top&quot; );
		this.active.next()
			.addClass( &quot;ui-accordion-content-active&quot; )
			.show();

		this._createIcons();
		this.refresh();

		// ARIA
		this.element.attr( &quot;role&quot;, &quot;tablist&quot; );

		this.headers
			.attr( &quot;role&quot;, &quot;tab&quot; )
			.each(function( i ) {
				var header = $( this ),
					headerId = header.attr( &quot;id&quot; ),
					panel = header.next(),
					panelId = panel.attr( &quot;id&quot; );
				if ( !headerId ) {
					headerId = accordionId + &quot;-header-&quot; + i;
					header.attr( &quot;id&quot;, headerId );
				}
				if ( !panelId ) {
					panelId = accordionId + &quot;-panel-&quot; + i;
					panel.attr( &quot;id&quot;, panelId );
				}
				header.attr( &quot;aria-controls&quot;, panelId );
				panel.attr( &quot;aria-labelledby&quot;, headerId );
			})
			.next()
				.attr( &quot;role&quot;, &quot;tabpanel&quot; );

		this.headers
			.not( this.active )
			.attr({
				&quot;aria-selected&quot;: &quot;false&quot;,
				tabIndex: -1
			})
			.next()
				.attr({
					&quot;aria-expanded&quot;: &quot;false&quot;,
					&quot;aria-hidden&quot;: &quot;true&quot;
				})
				.hide();

		// make sure at least one header is in the tab order
		if ( !this.active.length ) {
			this.headers.eq( 0 ).attr( &quot;tabIndex&quot;, 0 );
		} else {
			this.active.attr({
				&quot;aria-selected&quot;: &quot;true&quot;,
				tabIndex: 0
			})
			.next()
				.attr({
					&quot;aria-expanded&quot;: &quot;true&quot;,
					&quot;aria-hidden&quot;: &quot;false&quot;
				});
		}

		this._on( this.headers, { keydown: &quot;_keydown&quot; });
		this._on( this.headers.next(), { keydown: &quot;_panelKeyDown&quot; });
		this._setupEvents( options.event );
	},

	_getCreateEventData: function() {
		return {
			header: this.active,
			content: !this.active.length ? $() : this.active.next()
		};
	},

	_createIcons: function() {
		var icons = this.options.icons;
		if ( icons ) {
			$( &quot;&lt;span&gt;&quot; )
				.addClass( &quot;ui-accordion-header-icon ui-icon &quot; + icons.header )
				.prependTo( this.headers );
			this.active.children( &quot;.ui-accordion-header-icon&quot; )
				.removeClass( icons.header )
				.addClass( icons.activeHeader );
			this.headers.addClass( &quot;ui-accordion-icons&quot; );
		}
	},

	_destroyIcons: function() {
		this.headers
			.removeClass( &quot;ui-accordion-icons&quot; )
			.children( &quot;.ui-accordion-header-icon&quot; )
				.remove();
	},

	_destroy: function() {
		var contents;

		// clean up main element
		this.element
			.removeClass( &quot;ui-accordion ui-widget ui-helper-reset&quot; )
			.removeAttr( &quot;role&quot; );

		// clean up headers
		this.headers
			.removeClass( &quot;ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top&quot; )
			.removeAttr( &quot;role&quot; )
			.removeAttr( &quot;aria-selected&quot; )
			.removeAttr( &quot;aria-controls&quot; )
			.removeAttr( &quot;tabIndex&quot; )
			.each(function() {
				if ( /^ui-accordion/.test( this.id ) ) {
					this.removeAttribute( &quot;id&quot; );
				}
			});
		this._destroyIcons();

		// clean up content panels
		contents = this.headers.next()
			.css( &quot;display&quot;, &quot;&quot; )
			.removeAttr( &quot;role&quot; )
			.removeAttr( &quot;aria-expanded&quot; )
			.removeAttr( &quot;aria-hidden&quot; )
			.removeAttr( &quot;aria-labelledby&quot; )
			.removeClass( &quot;ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled&quot; )
			.each(function() {
				if ( /^ui-accordion/.test( this.id ) ) {
					this.removeAttribute( &quot;id&quot; );
				}
			});
		if ( this.options.heightStyle !== &quot;content&quot; ) {
			contents.css( &quot;height&quot;, &quot;&quot; );
		}
	},

	_setOption: function( key, value ) {
		if ( key === &quot;active&quot; ) {
			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === &quot;event&quot; ) {
			if ( this.options.event ) {
				this._off( this.headers, this.options.event );
			}
			this._setupEvents( value );
		}

		this._super( key, value );

		// setting collapsible: false while collapsed; open first panel
		if ( key === &quot;collapsible&quot; &amp;&amp; !value &amp;&amp; this.options.active === false ) {
			this._activate( 0 );
		}

		if ( key === &quot;icons&quot; ) {
			this._destroyIcons();
			if ( value ) {
				this._createIcons();
			}
		}

		// #5332 - opacity doesn&#x27;t cascade to positioned elements in IE
		// so we need to add the disabled class to the headers and panels
		if ( key === &quot;disabled&quot; ) {
			this.headers.add( this.headers.next() )
				.toggleClass( &quot;ui-state-disabled&quot;, !!value );
		}
	},

	_keydown: function( event ) {
		if ( event.altKey || event.ctrlKey ) {
			return;
		}

		var keyCode = $.ui.keyCode,
			length = this.headers.length,
			currentIndex = this.headers.index( event.target ),
			toFocus = false;

		switch ( event.keyCode ) {
			case keyCode.RIGHT:
			case keyCode.DOWN:
				toFocus = this.headers[ ( currentIndex + 1 ) % length ];
				break;
			case keyCode.LEFT:
			case keyCode.UP:
				toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
				break;
			case keyCode.SPACE:
			case keyCode.ENTER:
				this._eventHandler( event );
				break;
			case keyCode.HOME:
				toFocus = this.headers[ 0 ];
				break;
			case keyCode.END:
				toFocus = this.headers[ length - 1 ];
				break;
		}

		if ( toFocus ) {
			$( event.target ).attr( &quot;tabIndex&quot;, -1 );
			$( toFocus ).attr( &quot;tabIndex&quot;, 0 );
			toFocus.focus();
			event.preventDefault();
		}
	},

	_panelKeyDown : function( event ) {
		if ( event.keyCode === $.ui.keyCode.UP &amp;&amp; event.ctrlKey ) {
			$( event.currentTarget ).prev().focus();
		}
	},

	refresh: function() {
		var maxHeight, overflow,
			heightStyle = this.options.heightStyle,
			parent = this.element.parent();


		if ( heightStyle === &quot;fill&quot; ) {
			// IE 6 treats height like minHeight, so we need to turn off overflow
			// in order to get a reliable height
			// we use the minHeight support test because we assume that only
			// browsers that don&#x27;t support minHeight will treat height as minHeight
			if ( !$.support.minHeight ) {
				overflow = parent.css( &quot;overflow&quot; );
				parent.css( &quot;overflow&quot;, &quot;hidden&quot;);
			}
			maxHeight = parent.height();
			this.element.siblings( &quot;:visible&quot; ).each(function() {
				var elem = $( this ),
					position = elem.css( &quot;position&quot; );

				if ( position === &quot;absolute&quot; || position === &quot;fixed&quot; ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			});
			if ( overflow ) {
				parent.css( &quot;overflow&quot;, overflow );
			}

			this.headers.each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.headers.next()
				.each(function() {
					$( this ).height( Math.max( 0, maxHeight -
						$( this ).innerHeight() + $( this ).height() ) );
				})
				.css( &quot;overflow&quot;, &quot;auto&quot; );
		} else if ( heightStyle === &quot;auto&quot; ) {
			maxHeight = 0;
			this.headers.next()
				.each(function() {
					maxHeight = Math.max( maxHeight, $( this ).height( &quot;&quot; ).height() );
				})
				.height( maxHeight );
		}
	},

	_activate: function( index ) {
		var active = this._findActive( index )[ 0 ];

		// trying to activate the already active panel
		if ( active === this.active[ 0 ] ) {
			return;
		}

		// trying to collapse, simulate a click on the currently active header
		active = active || this.active[ 0 ];

		this._eventHandler({
			target: active,
			currentTarget: active,
			preventDefault: $.noop
		});
	},

	_findActive: function( selector ) {
		return typeof selector === &quot;number&quot; ? this.headers.eq( selector ) : $();
	},

	_setupEvents: function( event ) {
		var events = {};
		if ( !event ) {
			return;
		}
		$.each( event.split(&quot; &quot;), function( index, eventName ) {
			events[ eventName ] = &quot;_eventHandler&quot;;
		});
		this._on( this.headers, events );
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			clicked = $( event.currentTarget ),
			clickedIsActive = clicked[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive &amp;&amp; options.collapsible,
			toShow = collapsing ? $() : clicked.next(),
			toHide = active.next(),
			eventData = {
				oldHeader: active,
				oldPanel: toHide,
				newHeader: collapsing ? $() : clicked,
				newPanel: toShow
			};

		event.preventDefault();

		if (
				// click on active header, but not collapsible
				( clickedIsActive &amp;&amp; !options.collapsible ) ||
				// allow canceling activation
				( this._trigger( &quot;beforeActivate&quot;, event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.headers.index( clicked );

		// when the call to ._toggle() comes after the class changes
		// it causes a very odd bug in IE 8 (see #6720)
		this.active = clickedIsActive ? $() : clicked;
		this._toggle( eventData );

		// switch classes
		// corner classes on the previously active header stay after the animation
		active.removeClass( &quot;ui-accordion-header-active ui-state-active&quot; );
		if ( options.icons ) {
			active.children( &quot;.ui-accordion-header-icon&quot; )
				.removeClass( options.icons.activeHeader )
				.addClass( options.icons.header );
		}

		if ( !clickedIsActive ) {
			clicked
				.removeClass( &quot;ui-corner-all&quot; )
				.addClass( &quot;ui-accordion-header-active ui-state-active ui-corner-top&quot; );
			if ( options.icons ) {
				clicked.children( &quot;.ui-accordion-header-icon&quot; )
					.removeClass( options.icons.header )
					.addClass( options.icons.activeHeader );
			}

			clicked
				.next()
				.addClass( &quot;ui-accordion-content-active&quot; );
		}
	},

	_toggle: function( data ) {
		var toShow = data.newPanel,
			toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

		// handle activating a panel during the animation for another activation
		this.prevShow.add( this.prevHide ).stop( true, true );
		this.prevShow = toShow;
		this.prevHide = toHide;

		if ( this.options.animate ) {
			this._animate( toShow, toHide, data );
		} else {
			toHide.hide();
			toShow.show();
			this._toggleComplete( data );
		}

		toHide.attr({
			&quot;aria-expanded&quot;: &quot;false&quot;,
			&quot;aria-hidden&quot;: &quot;true&quot;
		});
		toHide.prev().attr( &quot;aria-selected&quot;, &quot;false&quot; );
		// if we&#x27;re switching panels, remove the old header from the tab order
		// if we&#x27;re opening from collapsed state, remove the previous header from the tab order
		// if we&#x27;re collapsing, then keep the collapsing header in the tab order
		if ( toShow.length &amp;&amp; toHide.length ) {
			toHide.prev().attr( &quot;tabIndex&quot;, -1 );
		} else if ( toShow.length ) {
			this.headers.filter(function() {
				return $( this ).attr( &quot;tabIndex&quot; ) === 0;
			})
			.attr( &quot;tabIndex&quot;, -1 );
		}

		toShow
			.attr({
				&quot;aria-expanded&quot;: &quot;true&quot;,
				&quot;aria-hidden&quot;: &quot;false&quot;
			})
			.prev()
				.attr({
					&quot;aria-selected&quot;: &quot;true&quot;,
					tabIndex: 0
				});
	},

	_animate: function( toShow, toHide, data ) {
		var total, easing, duration,
			that = this,
			adjust = 0,
			down = toShow.length &amp;&amp;
				( !toHide.length || ( toShow.index() &lt; toHide.index() ) ),
			animate = this.options.animate || {},
			options = down &amp;&amp; animate.down || animate,
			complete = function() {
				that._toggleComplete( data );
			};

		if ( typeof options === &quot;number&quot; ) {
			duration = options;
		}
		if ( typeof options === &quot;string&quot; ) {
			easing = options;
		}
		// fall back from options to animation in case of partial down settings
		easing = easing || options.easing || animate.easing;
		duration = duration || options.duration || animate.duration;

		if ( !toHide.length ) {
			return toShow.animate( showProps, duration, easing, complete );
		}
		if ( !toShow.length ) {
			return toHide.animate( hideProps, duration, easing, complete );
		}

		total = toShow.show().outerHeight();
		toHide.animate( hideProps, {
			duration: duration,
			easing: easing,
			step: function( now, fx ) {
				fx.now = Math.round( now );
			}
		});
		toShow
			.hide()
			.animate( showProps, {
				duration: duration,
				easing: easing,
				complete: complete,
				step: function( now, fx ) {
					fx.now = Math.round( now );
					if ( fx.prop !== &quot;height&quot; ) {
						adjust += fx.now;
					} else if ( that.options.heightStyle !== &quot;content&quot; ) {
						fx.now = Math.round( total - toHide.outerHeight() - adjust );
						adjust = 0;
					}
				}
			});
	},

	_toggleComplete: function( data ) {
		var toHide = data.oldPanel;

		toHide
			.removeClass( &quot;ui-accordion-content-active&quot; )
			.prev()
				.removeClass( &quot;ui-corner-top&quot; )
				.addClass( &quot;ui-corner-all&quot; );

		// Work around for rendering bug in IE (#5421)
		if ( toHide.length ) {
			toHide.parent()[0].className = toHide.parent()[0].className;
		}

		this._trigger( &quot;activate&quot;, null, data );
	}
});



// DEPRECATED
if ( $.uiBackCompat !== false ) {
	// navigation options
	(function( $, prototype ) {
		$.extend( prototype.options, {
			navigation: false,
			navigationFilter: function() {
				return this.href.toLowerCase() === location.href.toLowerCase();
			}
		});

		var _create = prototype._create;
		prototype._create = function() {
			if ( this.options.navigation ) {
				var that = this,
					headers = this.element.find( this.options.header ),
					content = headers.next(),
					current = headers.add( content )
						.find( &quot;a&quot; )
						.filter( this.options.navigationFilter )
						[ 0 ];
				if ( current ) {
					headers.add( content ).each( function( index ) {
						if ( $.contains( this, current ) ) {
							that.options.active = Math.floor( index / 2 );
							return false;
						}
					});
				}
			}
			_create.call( this );
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// height options
	(function( $, prototype ) {
		$.extend( prototype.options, {
			heightStyle: null, // remove default so we fall back to old values
			autoHeight: true, // use heightStyle: &quot;auto&quot;
			clearStyle: false, // use heightStyle: &quot;content&quot;
			fillSpace: false // use heightStyle: &quot;fill&quot;
		});

		var _create = prototype._create,
			_setOption = prototype._setOption;

		$.extend( prototype, {
			_create: function() {
				this.options.heightStyle = this.options.heightStyle ||
					this._mergeHeightStyle();

				_create.call( this );
			},

			_setOption: function( key ) {
				if ( key === &quot;autoHeight&quot; || key === &quot;clearStyle&quot; || key === &quot;fillSpace&quot; ) {
					this.options.heightStyle = this._mergeHeightStyle();
				}
				_setOption.apply( this, arguments );
			},

			_mergeHeightStyle: function() {
				var options = this.options;

				if ( options.fillSpace ) {
					return &quot;fill&quot;;
				}

				if ( options.clearStyle ) {
					return &quot;content&quot;;
				}

				if ( options.autoHeight ) {
					return &quot;auto&quot;;
				}
			}
		});
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// icon options
	(function( $, prototype ) {
		$.extend( prototype.options.icons, {
			activeHeader: null, // remove default so we fall back to old values
			headerSelected: &quot;ui-icon-triangle-1-s&quot;
		});

		var _createIcons = prototype._createIcons;
		prototype._createIcons = function() {
			if ( this.options.icons ) {
				this.options.icons.activeHeader = this.options.icons.activeHeader ||
					this.options.icons.headerSelected;
			}
			_createIcons.call( this );
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// expanded active option, activate method
	(function( $, prototype ) {
		prototype.activate = prototype._activate;

		var _findActive = prototype._findActive;
		prototype._findActive = function( index ) {
			if ( index === -1 ) {
				index = false;
			}
			if ( index &amp;&amp; typeof index !== &quot;number&quot; ) {
				index = this.headers.index( this.headers.filter( index ) );
				if ( index === -1 ) {
					index = false;
				}
			}
			return _findActive.call( this, index );
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// resize method
	jQuery.ui.accordion.prototype.resize = jQuery.ui.accordion.prototype.refresh;

	// change events
	(function( $, prototype ) {
		$.extend( prototype.options, {
			change: null,
			changestart: null
		});

		var _trigger = prototype._trigger;
		prototype._trigger = function( type, event, data ) {
			var ret = _trigger.apply( this, arguments );
			if ( !ret ) {
				return false;
			}

			if ( type === &quot;beforeActivate&quot; ) {
				ret = _trigger.call( this, &quot;changestart&quot;, event, {
					oldHeader: data.oldHeader,
					oldContent: data.oldPanel,
					newHeader: data.newHeader,
					newContent: data.newPanel
				});
			} else if ( type === &quot;activate&quot; ) {
				ret = _trigger.call( this, &quot;change&quot;, event, {
					oldHeader: data.oldHeader,
					oldContent: data.oldPanel,
					newHeader: data.newHeader,
					newContent: data.newPanel
				});
			}
			return ret;
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// animated option
	// NOTE: this only provides support for &quot;slide&quot;, &quot;bounceslide&quot;, and easings
	// not the full $.ui.accordion.animations API
	(function( $, prototype ) {
		$.extend( prototype.options, {
			animate: null,
			animated: &quot;slide&quot;
		});

		var _create = prototype._create;
		prototype._create = function() {
			var options = this.options;
			if ( options.animate === null ) {
				if ( !options.animated ) {
					options.animate = false;
				} else if ( options.animated === &quot;slide&quot; ) {
					options.animate = 300;
				} else if ( options.animated === &quot;bounceslide&quot; ) {
					options.animate = {
						duration: 200,
						down: {
							easing: &quot;easeOutBounce&quot;,
							duration: 1000
						}
					};
				} else {
					options.animate = options.animated;
				}
			}

			_create.call( this );
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );
}

})( jQuery );

(function( $, undefined ) {

// used to prevent race conditions with remote data sources
var requestIndex = 0;

$.widget( &quot;ui.autocomplete&quot;, {
	version: &quot;1.9.1&quot;,
	defaultElement: &quot;&lt;input&gt;&quot;,
	options: {
		appendTo: &quot;body&quot;,
		autoFocus: false,
		delay: 300,
		minLength: 1,
		position: {
			my: &quot;left top&quot;,
			at: &quot;left bottom&quot;,
			collision: &quot;none&quot;
		},
		source: null,

		// callbacks
		change: null,
		close: null,
		focus: null,
		open: null,
		response: null,
		search: null,
		select: null
	},

	pending: 0,

	_create: function() {
		// Some browsers only repeat keydown events, not keypress events,
		// so we use the suppressKeyPress flag to determine if we&#x27;ve already
		// handled the keydown event. #7269
		// Unfortunately the code for &amp; in keypress is the same as the up arrow,
		// so we use the suppressKeyPressRepeat flag to avoid handling keypress
		// events when we know the keydown event was used to modify the
		// search term. #7799
		var suppressKeyPress, suppressKeyPressRepeat, suppressInput;

		this.isMultiLine = this._isMultiLine();
		this.valueMethod = this.element[ this.element.is( &quot;input,textarea&quot; ) ? &quot;val&quot; : &quot;text&quot; ];
		this.isNewMenu = true;

		this.element
			.addClass( &quot;ui-autocomplete-input&quot; )
			.attr( &quot;autocomplete&quot;, &quot;off&quot; );

		this._on( this.element, {
			keydown: function( event ) {
				if ( this.element.prop( &quot;readOnly&quot; ) ) {
					suppressKeyPress = true;
					suppressInput = true;
					suppressKeyPressRepeat = true;
					return;
				}

				suppressKeyPress = false;
				suppressInput = false;
				suppressKeyPressRepeat = false;
				var keyCode = $.ui.keyCode;
				switch( event.keyCode ) {
				case keyCode.PAGE_UP:
					suppressKeyPress = true;
					this._move( &quot;previousPage&quot;, event );
					break;
				case keyCode.PAGE_DOWN:
					suppressKeyPress = true;
					this._move( &quot;nextPage&quot;, event );
					break;
				case keyCode.UP:
					suppressKeyPress = true;
					this._keyEvent( &quot;previous&quot;, event );
					break;
				case keyCode.DOWN:
					suppressKeyPress = true;
					this._keyEvent( &quot;next&quot;, event );
					break;
				case keyCode.ENTER:
				case keyCode.NUMPAD_ENTER:
					// when menu is open and has focus
					if ( this.menu.active ) {
						// #6055 - Opera still allows the keypress to occur
						// which causes forms to submit
						suppressKeyPress = true;
						event.preventDefault();
						this.menu.select( event );
					}
					break;
				case keyCode.TAB:
					if ( this.menu.active ) {
						this.menu.select( event );
					}
					break;
				case keyCode.ESCAPE:
					if ( this.menu.element.is( &quot;:visible&quot; ) ) {
						this._value( this.term );
						this.close( event );
						// Different browsers have different default behavior for escape
						// Single press can mean undo or clear
						// Double press in IE means clear the whole form
						event.preventDefault();
					}
					break;
				default:
					suppressKeyPressRepeat = true;
					// search timeout should be triggered before the input value is changed
					this._searchTimeout( event );
					break;
				}
			},
			keypress: function( event ) {
				if ( suppressKeyPress ) {
					suppressKeyPress = false;
					event.preventDefault();
					return;
				}
				if ( suppressKeyPressRepeat ) {
					return;
				}

				// replicate some key handlers to allow them to repeat in Firefox and Opera
				var keyCode = $.ui.keyCode;
				switch( event.keyCode ) {
				case keyCode.PAGE_UP:
					this._move( &quot;previousPage&quot;, event );
					break;
				case keyCode.PAGE_DOWN:
					this._move( &quot;nextPage&quot;, event );
					break;
				case keyCode.UP:
					this._keyEvent( &quot;previous&quot;, event );
					break;
				case keyCode.DOWN:
					this._keyEvent( &quot;next&quot;, event );
					break;
				}
			},
			input: function( event ) {
				if ( suppressInput ) {
					suppressInput = false;
					event.preventDefault();
					return;
				}
				this._searchTimeout( event );
			},
			focus: function() {
				this.selectedItem = null;
				this.previous = this._value();
			},
			blur: function( event ) {
				if ( this.cancelBlur ) {
					delete this.cancelBlur;
					return;
				}

				clearTimeout( this.searching );
				this.close( event );
				this._change( event );
			}
		});

		this._initSource();
		this.menu = $( &quot;&lt;ul&gt;&quot; )
			.addClass( &quot;ui-autocomplete&quot; )
			.appendTo( this.document.find( this.options.appendTo || &quot;body&quot; )[ 0 ] )
			.menu({
				// custom key handling for now
				input: $(),
				// disable ARIA support, the live region takes care of that
				role: null
			})
			.zIndex( this.element.zIndex() + 1 )
			.hide()
			.data( &quot;menu&quot; );

		this._on( this.menu.element, {
			mousedown: function( event ) {
				// prevent moving focus out of the text field
				event.preventDefault();

				// IE doesn&#x27;t prevent moving focus even with event.preventDefault()
				// so we set a flag to know when we should ignore the blur event
				this.cancelBlur = true;
				this._delay(function() {
					delete this.cancelBlur;
				});

				// clicking on the scrollbar causes focus to shift to the body
				// but we can&#x27;t detect a mouseup or a click immediately afterward
				// so we have to track the next mousedown and close the menu if
				// the user clicks somewhere outside of the autocomplete
				var menuElement = this.menu.element[ 0 ];
				if ( !$( event.target ).closest( &quot;.ui-menu-item&quot; ).length ) {
					this._delay(function() {
						var that = this;
						this.document.one( &quot;mousedown&quot;, function( event ) {
							if ( event.target !== that.element[ 0 ] &amp;&amp;
									event.target !== menuElement &amp;&amp;
									!$.contains( menuElement, event.target ) ) {
								that.close();
							}
						});
					});
				}
			},
			menufocus: function( event, ui ) {
				// #7024 - Prevent accidental activation of menu items in Firefox
				if ( this.isNewMenu ) {
					this.isNewMenu = false;
					if ( event.originalEvent &amp;&amp; /^mouse/.test( event.originalEvent.type ) ) {
						this.menu.blur();

						this.document.one( &quot;mousemove&quot;, function() {
							$( event.target ).trigger( event.originalEvent );
						});

						return;
					}
				}

				// back compat for _renderItem using item.autocomplete, via #7810
				// TODO remove the fallback, see #8156
				var item = ui.item.data( &quot;ui-autocomplete-item&quot; ) || ui.item.data( &quot;item.autocomplete&quot; );
				if ( false !== this._trigger( &quot;focus&quot;, event, { item: item } ) ) {
					// use value to match what will end up in the input, if it was a key event
					if ( event.originalEvent &amp;&amp; /^key/.test( event.originalEvent.type ) ) {
						this._value( item.value );
					}
				} else {
					// Normally the input is populated with the item&#x27;s value as the
					// menu is navigated, causing screen readers to notice a change and
					// announce the item. Since the focus event was canceled, this doesn&#x27;t
					// happen, so we update the live region so that screen readers can
					// still notice the change and announce it.
					this.liveRegion.text( item.value );
				}
			},
			menuselect: function( event, ui ) {
				// back compat for _renderItem using item.autocomplete, via #7810
				// TODO remove the fallback, see #8156
				var item = ui.item.data( &quot;ui-autocomplete-item&quot; ) || ui.item.data( &quot;item.autocomplete&quot; ),
					previous = this.previous;

				// only trigger when focus was lost (click on menu)
				if ( this.element[0] !== this.document[0].activeElement ) {
					this.element.focus();
					this.previous = previous;
					// #6109 - IE triggers two focus events and the second
					// is asynchronous, so we need to reset the previous
					// term synchronously and asynchronously :-(
					this._delay(function() {
						this.previous = previous;
						this.selectedItem = item;
					});
				}

				if ( false !== this._trigger( &quot;select&quot;, event, { item: item } ) ) {
					this._value( item.value );
				}
				// reset the term after the select event
				// this allows custom select handling to work properly
				this.term = this._value();

				this.close( event );
				this.selectedItem = item;
			}
		});

		this.liveRegion = $( &quot;&lt;span&gt;&quot;, {
				role: &quot;status&quot;,
				&quot;aria-live&quot;: &quot;polite&quot;
			})
			.addClass( &quot;ui-helper-hidden-accessible&quot; )
			.insertAfter( this.element );

		if ( $.fn.bgiframe ) {
			this.menu.element.bgiframe();
		}

		// turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( &quot;autocomplete&quot; );
			}
		});
	},

	_destroy: function() {
		clearTimeout( this.searching );
		this.element
			.removeClass( &quot;ui-autocomplete-input&quot; )
			.removeAttr( &quot;autocomplete&quot; );
		this.menu.element.remove();
		this.liveRegion.remove();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === &quot;source&quot; ) {
			this._initSource();
		}
		if ( key === &quot;appendTo&quot; ) {
			this.menu.element.appendTo( this.document.find( value || &quot;body&quot; )[0] );
		}
		if ( key === &quot;disabled&quot; &amp;&amp; value &amp;&amp; this.xhr ) {
			this.xhr.abort();
		}
	},

	_isMultiLine: function() {
		// Textareas are always multi-line
		if ( this.element.is( &quot;textarea&quot; ) ) {
			return true;
		}
		// Inputs are always single-line, even if inside a contentEditable element
		// IE also treats inputs as contentEditable
		if ( this.element.is( &quot;input&quot; ) ) {
			return false;
		}
		// All other element types are determined by whether or not they&#x27;re contentEditable
		return this.element.prop( &quot;isContentEditable&quot; );
	},

	_initSource: function() {
		var array, url,
			that = this;
		if ( $.isArray(this.options.source) ) {
			array = this.options.source;
			this.source = function( request, response ) {
				response( $.ui.autocomplete.filter( array, request.term ) );
			};
		} else if ( typeof this.options.source === &quot;string&quot; ) {
			url = this.options.source;
			this.source = function( request, response ) {
				if ( that.xhr ) {
					that.xhr.abort();
				}
				that.xhr = $.ajax({
					url: url,
					data: request,
					dataType: &quot;json&quot;,
					success: function( data ) {
						response( data );
					},
					error: function() {
						response( [] );
					}
				});
			};
		} else {
			this.source = this.options.source;
		}
	},

	_searchTimeout: function( event ) {
		clearTimeout( this.searching );
		this.searching = this._delay(function() {
			// only search if the value has changed
			if ( this.term !== this._value() ) {
				this.selectedItem = null;
				this.search( null, event );
			}
		}, this.options.delay );
	},

	search: function( value, event ) {
		value = value != null ? value : this._value();

		// always save the actual value, not the one passed as an argument
		this.term = this._value();

		if ( value.length &lt; this.options.minLength ) {
			return this.close( event );
		}

		if ( this._trigger( &quot;search&quot;, event ) === false ) {
			return;
		}

		return this._search( value );
	},

	_search: function( value ) {
		this.pending++;
		this.element.addClass( &quot;ui-autocomplete-loading&quot; );
		this.cancelSearch = false;

		this.source( { term: value }, this._response() );
	},

	_response: function() {
		var that = this,
			index = ++requestIndex;

		return function( content ) {
			if ( index === requestIndex ) {
				that.__response( content );
			}

			that.pending--;
			if ( !that.pending ) {
				that.element.removeClass( &quot;ui-autocomplete-loading&quot; );
			}
		};
	},

	__response: function( content ) {
		if ( content ) {
			content = this._normalize( content );
		}
		this._trigger( &quot;response&quot;, null, { content: content } );
		if ( !this.options.disabled &amp;&amp; content &amp;&amp; content.length &amp;&amp; !this.cancelSearch ) {
			this._suggest( content );
			this._trigger( &quot;open&quot; );
		} else {
			// use ._close() instead of .close() so we don&#x27;t cancel future searches
			this._close();
		}
	},

	close: function( event ) {
		this.cancelSearch = true;
		this._close( event );
	},

	_close: function( event ) {
		if ( this.menu.element.is( &quot;:visible&quot; ) ) {
			this.menu.element.hide();
			this.menu.blur();
			this.isNewMenu = true;
			this._trigger( &quot;close&quot;, event );
		}
	},

	_change: function( event ) {
		if ( this.previous !== this._value() ) {
			this._trigger( &quot;change&quot;, event, { item: this.selectedItem } );
		}
	},

	_normalize: function( items ) {
		// assume all items have the right format when the first item is complete
		if ( items.length &amp;&amp; items[0].label &amp;&amp; items[0].value ) {
			return items;
		}
		return $.map( items, function( item ) {
			if ( typeof item === &quot;string&quot; ) {
				return {
					label: item,
					value: item
				};
			}
			return $.extend({
				label: item.label || item.value,
				value: item.value || item.label
			}, item );
		});
	},

	_suggest: function( items ) {
		var ul = this.menu.element
			.empty()
			.zIndex( this.element.zIndex() + 1 );
		this._renderMenu( ul, items );
		this.menu.refresh();

		// size and position menu
		ul.show();
		this._resizeMenu();
		ul.position( $.extend({
			of: this.element
		}, this.options.position ));

		if ( this.options.autoFocus ) {
			this.menu.next();
		}
	},

	_resizeMenu: function() {
		var ul = this.menu.element;
		ul.outerWidth( Math.max(
			// Firefox wraps long text (possibly a rounding bug)
			// so we add 1px to avoid the wrapping (#7513)
			ul.width( &quot;&quot; ).outerWidth() + 1,
			this.element.outerWidth()
		) );
	},

	_renderMenu: function( ul, items ) {
		var that = this;
		$.each( items, function( index, item ) {
			that._renderItemData( ul, item );
		});
	},

	_renderItemData: function( ul, item ) {
		return this._renderItem( ul, item ).data( &quot;ui-autocomplete-item&quot;, item );
	},

	_renderItem: function( ul, item ) {
		return $( &quot;&lt;li&gt;&quot; )
			.append( $( &quot;&lt;a&gt;&quot; ).text( item.label ) )
			.appendTo( ul );
	},

	_move: function( direction, event ) {
		if ( !this.menu.element.is( &quot;:visible&quot; ) ) {
			this.search( null, event );
			return;
		}
		if ( this.menu.isFirstItem() &amp;&amp; /^previous/.test( direction ) ||
				this.menu.isLastItem() &amp;&amp; /^next/.test( direction ) ) {
			this._value( this.term );
			this.menu.blur();
			return;
		}
		this.menu[ direction ]( event );
	},

	widget: function() {
		return this.menu.element;
	},

	_value: function() {
		return this.valueMethod.apply( this.element, arguments );
	},

	_keyEvent: function( keyEvent, event ) {
		if ( !this.isMultiLine || this.menu.element.is( &quot;:visible&quot; ) ) {
			this._move( keyEvent, event );

			// prevents moving cursor to beginning/end of the text field in some browsers
			event.preventDefault();
		}
	}
});

$.extend( $.ui.autocomplete, {
	escapeRegex: function( value ) {
		return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, &quot;\\$&amp;&quot;);
	},
	filter: function(array, term) {
		var matcher = new RegExp( $.ui.autocomplete.escapeRegex(term), &quot;i&quot; );
		return $.grep( array, function(value) {
			return matcher.test( value.label || value.value || value );
		});
	}
});


// live region extension, adding a &#x60;messages&#x60; option
// NOTE: This is an experimental API. We are still investigating
// a full solution for string manipulation and internationalization.
$.widget( &quot;ui.autocomplete&quot;, $.ui.autocomplete, {
	options: {
		messages: {
			noResults: &quot;No search results.&quot;,
			results: function( amount ) {
				return amount + ( amount &gt; 1 ? &quot; results are&quot; : &quot; result is&quot; ) +
					&quot; available, use up and down arrow keys to navigate.&quot;;
			}
		}
	},

	__response: function( content ) {
		var message;
		this._superApply( arguments );
		if ( this.options.disabled || this.cancelSearch ) {
			return;
		}
		if ( content &amp;&amp; content.length ) {
			message = this.options.messages.results( content.length );
		} else {
			message = this.options.messages.noResults;
		}
		this.liveRegion.text( message );
	}
});


}( jQuery ));

(function( $, undefined ) {

var lastActive, startXPos, startYPos, clickDragged,
	baseClasses = &quot;ui-button ui-widget ui-state-default ui-corner-all&quot;,
	stateClasses = &quot;ui-state-hover ui-state-active &quot;,
	typeClasses = &quot;ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only&quot;,
	formResetHandler = function() {
		var buttons = $( this ).find( &quot;:ui-button&quot; );
		setTimeout(function() {
			buttons.button( &quot;refresh&quot; );
		}, 1 );
	},
	radioGroup = function( radio ) {
		var name = radio.name,
			form = radio.form,
			radios = $( [] );
		if ( name ) {
			if ( form ) {
				radios = $( form ).find( &quot;[name=&#x27;&quot; + name + &quot;&#x27;]&quot; );
			} else {
				radios = $( &quot;[name=&#x27;&quot; + name + &quot;&#x27;]&quot;, radio.ownerDocument )
					.filter(function() {
						return !this.form;
					});
			}
		}
		return radios;
	};

$.widget( &quot;ui.button&quot;, {
	version: &quot;1.9.1&quot;,
	defaultElement: &quot;&lt;button&gt;&quot;,
	options: {
		disabled: null,
		text: true,
		label: null,
		icons: {
			primary: null,
			secondary: null
		}
	},
	_create: function() {
		this.element.closest( &quot;form&quot; )
			.unbind( &quot;reset&quot; + this.eventNamespace )
			.bind( &quot;reset&quot; + this.eventNamespace, formResetHandler );

		if ( typeof this.options.disabled !== &quot;boolean&quot; ) {
			this.options.disabled = !!this.element.prop( &quot;disabled&quot; );
		} else {
			this.element.prop( &quot;disabled&quot;, this.options.disabled );
		}

		this._determineButtonType();
		this.hasTitle = !!this.buttonElement.attr( &quot;title&quot; );

		var that = this,
			options = this.options,
			toggleButton = this.type === &quot;checkbox&quot; || this.type === &quot;radio&quot;,
			hoverClass = &quot;ui-state-hover&quot; + ( !toggleButton ? &quot; ui-state-active&quot; : &quot;&quot; ),
			focusClass = &quot;ui-state-focus&quot;;

		if ( options.label === null ) {
			options.label = (this.type === &quot;input&quot; ? this.buttonElement.val() : this.buttonElement.html());
		}

		this.buttonElement
			.addClass( baseClasses )
			.attr( &quot;role&quot;, &quot;button&quot; )
			.bind( &quot;mouseenter&quot; + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).addClass( &quot;ui-state-hover&quot; );
				if ( this === lastActive ) {
					$( this ).addClass( &quot;ui-state-active&quot; );
				}
			})
			.bind( &quot;mouseleave&quot; + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( hoverClass );
			})
			.bind( &quot;click&quot; + this.eventNamespace, function( event ) {
				if ( options.disabled ) {
					event.preventDefault();
					event.stopImmediatePropagation();
				}
			});

		this.element
			.bind( &quot;focus&quot; + this.eventNamespace, function() {
				// no need to check disabled, focus won&#x27;t be triggered anyway
				that.buttonElement.addClass( focusClass );
			})
			.bind( &quot;blur&quot; + this.eventNamespace, function() {
				that.buttonElement.removeClass( focusClass );
			});

		if ( toggleButton ) {
			this.element.bind( &quot;change&quot; + this.eventNamespace, function() {
				if ( clickDragged ) {
					return;
				}
				that.refresh();
			});
			// if mouse moves between mousedown and mouseup (drag) set clickDragged flag
			// prevents issue where button state changes but checkbox/radio checked state
			// does not in Firefox (see ticket #6970)
			this.buttonElement
				.bind( &quot;mousedown&quot; + this.eventNamespace, function( event ) {
					if ( options.disabled ) {
						return;
					}
					clickDragged = false;
					startXPos = event.pageX;
					startYPos = event.pageY;
				})
				.bind( &quot;mouseup&quot; + this.eventNamespace, function( event ) {
					if ( options.disabled ) {
						return;
					}
					if ( startXPos !== event.pageX || startYPos !== event.pageY ) {
						clickDragged = true;
					}
			});
		}

		if ( this.type === &quot;checkbox&quot; ) {
			this.buttonElement.bind( &quot;click&quot; + this.eventNamespace, function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
				$( this ).toggleClass( &quot;ui-state-active&quot; );
				that.buttonElement.attr( &quot;aria-pressed&quot;, that.element[0].checked );
			});
		} else if ( this.type === &quot;radio&quot; ) {
			this.buttonElement.bind( &quot;click&quot; + this.eventNamespace, function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
				$( this ).addClass( &quot;ui-state-active&quot; );
				that.buttonElement.attr( &quot;aria-pressed&quot;, &quot;true&quot; );

				var radio = that.element[ 0 ];
				radioGroup( radio )
					.not( radio )
					.map(function() {
						return $( this ).button( &quot;widget&quot; )[ 0 ];
					})
					.removeClass( &quot;ui-state-active&quot; )
					.attr( &quot;aria-pressed&quot;, &quot;false&quot; );
			});
		} else {
			this.buttonElement
				.bind( &quot;mousedown&quot; + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).addClass( &quot;ui-state-active&quot; );
					lastActive = this;
					that.document.one( &quot;mouseup&quot;, function() {
						lastActive = null;
					});
				})
				.bind( &quot;mouseup&quot; + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).removeClass( &quot;ui-state-active&quot; );
				})
				.bind( &quot;keydown&quot; + this.eventNamespace, function(event) {
					if ( options.disabled ) {
						return false;
					}
					if ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {
						$( this ).addClass( &quot;ui-state-active&quot; );
					}
				})
				.bind( &quot;keyup&quot; + this.eventNamespace, function() {
					$( this ).removeClass( &quot;ui-state-active&quot; );
				});

			if ( this.buttonElement.is(&quot;a&quot;) ) {
				this.buttonElement.keyup(function(event) {
					if ( event.keyCode === $.ui.keyCode.SPACE ) {
						// TODO pass through original event correctly (just as 2nd argument doesn&#x27;t work)
						$( this ).click();
					}
				});
			}
		}

		// TODO: pull out $.Widget&#x27;s handling for the disabled option into
		// $.Widget.prototype._setOptionDisabled so it&#x27;s easy to proxy and can
		// be overridden by individual plugins
		this._setOption( &quot;disabled&quot;, options.disabled );
		this._resetButton();
	},

	_determineButtonType: function() {
		var ancestor, labelSelector, checked;

		if ( this.element.is(&quot;[type=checkbox]&quot;) ) {
			this.type = &quot;checkbox&quot;;
		} else if ( this.element.is(&quot;[type=radio]&quot;) ) {
			this.type = &quot;radio&quot;;
		} else if ( this.element.is(&quot;input&quot;) ) {
			this.type = &quot;input&quot;;
		} else {
			this.type = &quot;button&quot;;
		}

		if ( this.type === &quot;checkbox&quot; || this.type === &quot;radio&quot; ) {
			// we don&#x27;t search against the document in case the element
			// is disconnected from the DOM
			ancestor = this.element.parents().last();
			labelSelector = &quot;label[for=&#x27;&quot; + this.element.attr(&quot;id&quot;) + &quot;&#x27;]&quot;;
			this.buttonElement = ancestor.find( labelSelector );
			if ( !this.buttonElement.length ) {
				ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
				this.buttonElement = ancestor.filter( labelSelector );
				if ( !this.buttonElement.length ) {
					this.buttonElement = ancestor.find( labelSelector );
				}
			}
			this.element.addClass( &quot;ui-helper-hidden-accessible&quot; );

			checked = this.element.is( &quot;:checked&quot; );
			if ( checked ) {
				this.buttonElement.addClass( &quot;ui-state-active&quot; );
			}
			this.buttonElement.prop( &quot;aria-pressed&quot;, checked );
		} else {
			this.buttonElement = this.element;
		}
	},

	widget: function() {
		return this.buttonElement;
	},

	_destroy: function() {
		this.element
			.removeClass( &quot;ui-helper-hidden-accessible&quot; );
		this.buttonElement
			.removeClass( baseClasses + &quot; &quot; + stateClasses + &quot; &quot; + typeClasses )
			.removeAttr( &quot;role&quot; )
			.removeAttr( &quot;aria-pressed&quot; )
			.html( this.buttonElement.find(&quot;.ui-button-text&quot;).html() );

		if ( !this.hasTitle ) {
			this.buttonElement.removeAttr( &quot;title&quot; );
		}
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === &quot;disabled&quot; ) {
			if ( value ) {
				this.element.prop( &quot;disabled&quot;, true );
			} else {
				this.element.prop( &quot;disabled&quot;, false );
			}
			return;
		}
		this._resetButton();
	},

	refresh: function() {
		var isDisabled = this.element.is( &quot;:disabled&quot; ) || this.element.hasClass( &quot;ui-button-disabled&quot; );
		if ( isDisabled !== this.options.disabled ) {
			this._setOption( &quot;disabled&quot;, isDisabled );
		}
		if ( this.type === &quot;radio&quot; ) {
			radioGroup( this.element[0] ).each(function() {
				if ( $( this ).is( &quot;:checked&quot; ) ) {
					$( this ).button( &quot;widget&quot; )
						.addClass( &quot;ui-state-active&quot; )
						.attr( &quot;aria-pressed&quot;, &quot;true&quot; );
				} else {
					$( this ).button( &quot;widget&quot; )
						.removeClass( &quot;ui-state-active&quot; )
						.attr( &quot;aria-pressed&quot;, &quot;false&quot; );
				}
			});
		} else if ( this.type === &quot;checkbox&quot; ) {
			if ( this.element.is( &quot;:checked&quot; ) ) {
				this.buttonElement
					.addClass( &quot;ui-state-active&quot; )
					.attr( &quot;aria-pressed&quot;, &quot;true&quot; );
			} else {
				this.buttonElement
					.removeClass( &quot;ui-state-active&quot; )
					.attr( &quot;aria-pressed&quot;, &quot;false&quot; );
			}
		}
	},

	_resetButton: function() {
		if ( this.type === &quot;input&quot; ) {
			if ( this.options.label ) {
				this.element.val( this.options.label );
			}
			return;
		}
		var buttonElement = this.buttonElement.removeClass( typeClasses ),
			buttonText = $( &quot;&lt;span&gt;&lt;/span&gt;&quot;, this.document[0] )
				.addClass( &quot;ui-button-text&quot; )
				.html( this.options.label )
				.appendTo( buttonElement.empty() )
				.text(),
			icons = this.options.icons,
			multipleIcons = icons.primary &amp;&amp; icons.secondary,
			buttonClasses = [];

		if ( icons.primary || icons.secondary ) {
			if ( this.options.text ) {
				buttonClasses.push( &quot;ui-button-text-icon&quot; + ( multipleIcons ? &quot;s&quot; : ( icons.primary ? &quot;-primary&quot; : &quot;-secondary&quot; ) ) );
			}

			if ( icons.primary ) {
				buttonElement.prepend( &quot;&lt;span class=&#x27;ui-button-icon-primary ui-icon &quot; + icons.primary + &quot;&#x27;&gt;&lt;/span&gt;&quot; );
			}

			if ( icons.secondary ) {
				buttonElement.append( &quot;&lt;span class=&#x27;ui-button-icon-secondary ui-icon &quot; + icons.secondary + &quot;&#x27;&gt;&lt;/span&gt;&quot; );
			}

			if ( !this.options.text ) {
				buttonClasses.push( multipleIcons ? &quot;ui-button-icons-only&quot; : &quot;ui-button-icon-only&quot; );

				if ( !this.hasTitle ) {
					buttonElement.attr( &quot;title&quot;, $.trim( buttonText ) );
				}
			}
		} else {
			buttonClasses.push( &quot;ui-button-text-only&quot; );
		}
		buttonElement.addClass( buttonClasses.join( &quot; &quot; ) );
	}
});

$.widget( &quot;ui.buttonset&quot;, {
	version: &quot;1.9.1&quot;,
	options: {
		items: &quot;button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(button)&quot;
	},

	_create: function() {
		this.element.addClass( &quot;ui-buttonset&quot; );
	},

	_init: function() {
		this.refresh();
	},

	_setOption: function( key, value ) {
		if ( key === &quot;disabled&quot; ) {
			this.buttons.button( &quot;option&quot;, key, value );
		}

		this._super( key, value );
	},

	refresh: function() {
		var rtl = this.element.css( &quot;direction&quot; ) === &quot;rtl&quot;;

		this.buttons = this.element.find( this.options.items )
			.filter( &quot;:ui-button&quot; )
				.button( &quot;refresh&quot; )
			.end()
			.not( &quot;:ui-button&quot; )
				.button()
			.end()
			.map(function() {
				return $( this ).button( &quot;widget&quot; )[ 0 ];
			})
				.removeClass( &quot;ui-corner-all ui-corner-left ui-corner-right&quot; )
				.filter( &quot;:first&quot; )
					.addClass( rtl ? &quot;ui-corner-right&quot; : &quot;ui-corner-left&quot; )
				.end()
				.filter( &quot;:last&quot; )
					.addClass( rtl ? &quot;ui-corner-left&quot; : &quot;ui-corner-right&quot; )
				.end()
			.end();
	},

	_destroy: function() {
		this.element.removeClass( &quot;ui-buttonset&quot; );
		this.buttons
			.map(function() {
				return $( this ).button( &quot;widget&quot; )[ 0 ];
			})
				.removeClass( &quot;ui-corner-left ui-corner-right&quot; )
			.end()
			.button( &quot;destroy&quot; );
	}
});

}( jQuery ) );

(function( $, undefined ) {

$.extend($.ui, { datepicker: { version: &quot;1.9.1&quot; } });

var PROP_NAME = &#x27;datepicker&#x27;;
var dpuuid = new Date().getTime();
var instActive;

/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this.debug = false; // Change this to true to start debugging
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a &quot;dialog&quot;, false if not
	this._mainDivId = &#x27;ui-datepicker-div&#x27;; // The ID of the main datepicker division
	this._inlineClass = &#x27;ui-datepicker-inline&#x27;; // The name of the inline marker class
	this._appendClass = &#x27;ui-datepicker-append&#x27;; // The name of the append marker class
	this._triggerClass = &#x27;ui-datepicker-trigger&#x27;; // The name of the trigger marker class
	this._dialogClass = &#x27;ui-datepicker-dialog&#x27;; // The name of the dialog marker class
	this._disableClass = &#x27;ui-datepicker-disabled&#x27;; // The name of the disabled covering marker class
	this._unselectableClass = &#x27;ui-datepicker-unselectable&#x27;; // The name of the unselectable cell marker class
	this._currentClass = &#x27;ui-datepicker-current-day&#x27;; // The name of the current day marker class
	this._dayOverClass = &#x27;ui-datepicker-days-cell-over&#x27;; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[&#x27;&#x27;] = { // Default regional settings
		closeText: &#x27;Done&#x27;, // Display text for close link
		prevText: &#x27;Prev&#x27;, // Display text for previous month link
		nextText: &#x27;Next&#x27;, // Display text for next month link
		currentText: &#x27;Today&#x27;, // Display text for current month link
		monthNames: [&#x27;January&#x27;,&#x27;February&#x27;,&#x27;March&#x27;,&#x27;April&#x27;,&#x27;May&#x27;,&#x27;June&#x27;,
			&#x27;July&#x27;,&#x27;August&#x27;,&#x27;September&#x27;,&#x27;October&#x27;,&#x27;November&#x27;,&#x27;December&#x27;], // Names of months for drop-down and formatting
		monthNamesShort: [&#x27;Jan&#x27;, &#x27;Feb&#x27;, &#x27;Mar&#x27;, &#x27;Apr&#x27;, &#x27;May&#x27;, &#x27;Jun&#x27;, &#x27;Jul&#x27;, &#x27;Aug&#x27;, &#x27;Sep&#x27;, &#x27;Oct&#x27;, &#x27;Nov&#x27;, &#x27;Dec&#x27;], // For formatting
		dayNames: [&#x27;Sunday&#x27;, &#x27;Monday&#x27;, &#x27;Tuesday&#x27;, &#x27;Wednesday&#x27;, &#x27;Thursday&#x27;, &#x27;Friday&#x27;, &#x27;Saturday&#x27;], // For formatting
		dayNamesShort: [&#x27;Sun&#x27;, &#x27;Mon&#x27;, &#x27;Tue&#x27;, &#x27;Wed&#x27;, &#x27;Thu&#x27;, &#x27;Fri&#x27;, &#x27;Sat&#x27;], // For formatting
		dayNamesMin: [&#x27;Su&#x27;,&#x27;Mo&#x27;,&#x27;Tu&#x27;,&#x27;We&#x27;,&#x27;Th&#x27;,&#x27;Fr&#x27;,&#x27;Sa&#x27;], // Column headings for days starting at Sunday
		weekHeader: &#x27;Wk&#x27;, // Column header for week of the year
		dateFormat: &#x27;mm/dd/yy&#x27;, // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: &#x27;&#x27; // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: &#x27;focus&#x27;, // &#x27;focus&#x27; for popup on focus,
			// &#x27;button&#x27; for trigger button, or &#x27;both&#x27; for either
		showAnim: &#x27;fadeIn&#x27;, // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: &#x27;&#x27;, // Display text following the input box, e.g. showing the format
		buttonText: &#x27;...&#x27;, // Text for trigger button
		buttonImage: &#x27;&#x27;, // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: &#x27;c-10:c+10&#x27;, // Range of years to display in drop-down,
			// either relative to today&#x27;s year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: &#x27;+10&#x27;, // Short year values &lt; this are in the current century,
			// &gt; this are in the previous century,
			// string value starting with &#x27;+&#x27; for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: &#x27;fast&#x27;, // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or &#x27;&#x27;,
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: &#x27;&#x27;, // Selector for an alternate field to store selected dates into
		altFormat: &#x27;&#x27;, // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend(this._defaults, this.regional[&#x27;&#x27;]);
	this.dpDiv = bindHover($(&#x27;&lt;div id=&quot;&#x27; + this._mainDivId + &#x27;&quot; class=&quot;ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all&quot;&gt;&lt;/div&gt;&#x27;));
}

$.extend(Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: &#x27;hasDatepicker&#x27;,

	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	/* Debug logging (if enabled). */
	log: function () {
		if (this.debug)
			console.log.apply(&#x27;&#x27;, arguments);
	},

	// TODO rename to &quot;widget&quot; when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	   @param  settings  object - the new settings to use as defaults (anonymous object)
	   @return the manager object */
	setDefaults: function(settings) {
		extendRemove(this._defaults, settings || {});
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span
	   @param  settings  object - the new settings to use for this date picker instance (anonymous) */
	_attachDatepicker: function(target, settings) {
		// check for settings on the control itself - in namespace &#x27;date:&#x27;
		var inlineSettings = null;
		for (var attrName in this._defaults) {
			var attrValue = target.getAttribute(&#x27;date:&#x27; + attrName);
			if (attrValue) {
				inlineSettings = inlineSettings || {};
				try {
					inlineSettings[attrName] = eval(attrValue);
				} catch (err) {
					inlineSettings[attrName] = attrValue;
				}
			}
		}
		var nodeName = target.nodeName.toLowerCase();
		var inline = (nodeName == &#x27;div&#x27; || nodeName == &#x27;span&#x27;);
		if (!target.id) {
			this.uuid += 1;
			target.id = &#x27;dp&#x27; + this.uuid;
		}
		var inst = this._newInst($(target), inline);
		inst.settings = $.extend({}, settings || {}, inlineSettings || {});
		if (nodeName == &#x27;input&#x27;) {
			this._connectDatepicker(target, inst);
		} else if (inline) {
			this._inlineDatepicker(target, inst);
		}
	},

	/* Create a new instance object. */
	_newInst: function(target, inline) {
		var id = target[0].id.replace(/([^A-Za-z0-9_-])/g, &#x27;\\\\$1&#x27;); // escape jQuery meta chars
		return {id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: (!inline ? this.dpDiv : // presentation div
			bindHover($(&#x27;&lt;div class=&quot;&#x27; + this._inlineClass + &#x27; ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all&quot;&gt;&lt;/div&gt;&#x27;)))};
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function(target, inst) {
		var input = $(target);
		inst.append = $([]);
		inst.trigger = $([]);
		if (input.hasClass(this.markerClassName))
			return;
		this._attachments(input, inst);
		input.addClass(this.markerClassName).keydown(this._doKeyDown).
			keypress(this._doKeyPress).keyup(this._doKeyUp).
			bind(&quot;setData.datepicker&quot;, function(event, key, value) {
				inst.settings[key] = value;
			}).bind(&quot;getData.datepicker&quot;, function(event, key) {
				return this._get(inst, key);
			});
		this._autoSize(inst);
		$.data(target, PROP_NAME, inst);
		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function(input, inst) {
		var appendText = this._get(inst, &#x27;appendText&#x27;);
		var isRTL = this._get(inst, &#x27;isRTL&#x27;);
		if (inst.append)
			inst.append.remove();
		if (appendText) {
			inst.append = $(&#x27;&lt;span class=&quot;&#x27; + this._appendClass + &#x27;&quot;&gt;&#x27; + appendText + &#x27;&lt;/span&gt;&#x27;);
			input[isRTL ? &#x27;before&#x27; : &#x27;after&#x27;](inst.append);
		}
		input.unbind(&#x27;focus&#x27;, this._showDatepicker);
		if (inst.trigger)
			inst.trigger.remove();
		var showOn = this._get(inst, &#x27;showOn&#x27;);
		if (showOn == &#x27;focus&#x27; || showOn == &#x27;both&#x27;) // pop-up date picker when in the marked field
			input.focus(this._showDatepicker);
		if (showOn == &#x27;button&#x27; || showOn == &#x27;both&#x27;) { // pop-up date picker when button clicked
			var buttonText = this._get(inst, &#x27;buttonText&#x27;);
			var buttonImage = this._get(inst, &#x27;buttonImage&#x27;);
			inst.trigger = $(this._get(inst, &#x27;buttonImageOnly&#x27;) ?
				$(&#x27;&lt;img/&gt;&#x27;).addClass(this._triggerClass).
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
				$(&#x27;&lt;button type=&quot;button&quot;&gt;&lt;/button&gt;&#x27;).addClass(this._triggerClass).
					html(buttonImage == &#x27;&#x27; ? buttonText : $(&#x27;&lt;img/&gt;&#x27;).attr(
					{ src:buttonImage, alt:buttonText, title:buttonText })));
			input[isRTL ? &#x27;before&#x27; : &#x27;after&#x27;](inst.trigger);
			inst.trigger.click(function() {
				if ($.datepicker._datepickerShowing &amp;&amp; $.datepicker._lastInput == input[0])
					$.datepicker._hideDatepicker();
				else if ($.datepicker._datepickerShowing &amp;&amp; $.datepicker._lastInput != input[0]) {
					$.datepicker._hideDatepicker();
					$.datepicker._showDatepicker(input[0]);
				} else
					$.datepicker._showDatepicker(input[0]);
				return false;
			});
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function(inst) {
		if (this._get(inst, &#x27;autoSize&#x27;) &amp;&amp; !inst.inline) {
			var date = new Date(2009, 12 - 1, 20); // Ensure double digits
			var dateFormat = this._get(inst, &#x27;dateFormat&#x27;);
			if (dateFormat.match(/[DM]/)) {
				var findMax = function(names) {
					var max = 0;
					var maxI = 0;
					for (var i = 0; i &lt; names.length; i++) {
						if (names[i].length &gt; max) {
							max = names[i].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
					&#x27;monthNames&#x27; : &#x27;monthNamesShort&#x27;))));
				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
					&#x27;dayNames&#x27; : &#x27;dayNamesShort&#x27;))) + 20 - date.getDay());
			}
			inst.input.attr(&#x27;size&#x27;, this._formatDate(inst, date).length);
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function(target, inst) {
		var divSpan = $(target);
		if (divSpan.hasClass(this.markerClassName))
			return;
		divSpan.addClass(this.markerClassName).append(inst.dpDiv).
			bind(&quot;setData.datepicker&quot;, function(event, key, value){
				inst.settings[key] = value;
			}).bind(&quot;getData.datepicker&quot;, function(event, key){
				return this._get(inst, key);
			});
		$.data(target, PROP_NAME, inst);
		this._setDate(inst, this._getDefaultDate(inst), true);
		this._updateDatepicker(inst);
		this._updateAlternate(inst);
		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
		// Set display:block in place of inst.dpDiv.show() which won&#x27;t work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( &quot;display&quot;, &quot;block&quot; );
	},

	/* Pop-up the date picker in a &quot;dialog&quot; box.
	   @param  input     element - ignored
	   @param  date      string or Date - the initial date to display
	   @param  onSelect  function - the function to call when a date is selected
	   @param  settings  object - update the dialog date picker instance&#x27;s settings (anonymous object)
	   @param  pos       int[2] - coordinates for the dialog&#x27;s position within the screen or
	                     event - with x/y coordinates or
	                     leave empty for default (screen centre)
	   @return the manager object */
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
		var inst = this._dialogInst; // internal instance
		if (!inst) {
			this.uuid += 1;
			var id = &#x27;dp&#x27; + this.uuid;
			this._dialogInput = $(&#x27;&lt;input type=&quot;text&quot; id=&quot;&#x27; + id +
				&#x27;&quot; style=&quot;position: absolute; top: -100px; width: 0px;&quot;/&gt;&#x27;);
			this._dialogInput.keydown(this._doKeyDown);
			$(&#x27;body&#x27;).append(this._dialogInput);
			inst = this._dialogInst = this._newInst(this._dialogInput, false);
			inst.settings = {};
			$.data(this._dialogInput[0], PROP_NAME, inst);
		}
		extendRemove(inst.settings, settings || {});
		date = (date &amp;&amp; date.constructor == Date ? this._formatDate(inst, date) : date);
		this._dialogInput.val(date);

		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
		if (!this._pos) {
			var browserWidth = document.documentElement.clientWidth;
			var browserHeight = document.documentElement.clientHeight;
			var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
		}

		// move input on screen for focus, but hidden behind dialog
		this._dialogInput.css(&#x27;left&#x27;, (this._pos[0] + 20) + &#x27;px&#x27;).css(&#x27;top&#x27;, this._pos[1] + &#x27;px&#x27;);
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass(this._dialogClass);
		this._showDatepicker(this._dialogInput[0]);
		if ($.blockUI)
			$.blockUI(this.dpDiv);
		$.data(this._dialogInput[0], PROP_NAME, inst);
		return this;
	},

	/* Detach a datepicker from its control.
	   @param  target    element - the target input field or division or span */
	_destroyDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		$.removeData(target, PROP_NAME);
		if (nodeName == &#x27;input&#x27;) {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass(this.markerClassName).
				unbind(&#x27;focus&#x27;, this._showDatepicker).
				unbind(&#x27;keydown&#x27;, this._doKeyDown).
				unbind(&#x27;keypress&#x27;, this._doKeyPress).
				unbind(&#x27;keyup&#x27;, this._doKeyUp);
		} else if (nodeName == &#x27;div&#x27; || nodeName == &#x27;span&#x27;)
			$target.removeClass(this.markerClassName).empty();
	},

	/* Enable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span */
	_enableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == &#x27;input&#x27;) {
			target.disabled = false;
			inst.trigger.filter(&#x27;button&#x27;).
				each(function() { this.disabled = false; }).end().
				filter(&#x27;img&#x27;).css({opacity: &#x27;1.0&#x27;, cursor: &#x27;&#x27;});
		}
		else if (nodeName == &#x27;div&#x27; || nodeName == &#x27;span&#x27;) {
			var inline = $target.children(&#x27;.&#x27; + this._inlineClass);
			inline.children().removeClass(&#x27;ui-state-disabled&#x27;);
			inline.find(&quot;select.ui-datepicker-month, select.ui-datepicker-year&quot;).
				prop(&quot;disabled&quot;, false);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span */
	_disableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == &#x27;input&#x27;) {
			target.disabled = true;
			inst.trigger.filter(&#x27;button&#x27;).
				each(function() { this.disabled = true; }).end().
				filter(&#x27;img&#x27;).css({opacity: &#x27;0.5&#x27;, cursor: &#x27;default&#x27;});
		}
		else if (nodeName == &#x27;div&#x27; || nodeName == &#x27;span&#x27;) {
			var inline = $target.children(&#x27;.&#x27; + this._inlineClass);
			inline.children().addClass(&#x27;ui-state-disabled&#x27;);
			inline.find(&quot;select.ui-datepicker-month, select.ui-datepicker-year&quot;).
				prop(&quot;disabled&quot;, true);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); // delete entry
		this._disabledInputs[this._disabledInputs.length] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	   @param  target    element - the target input field or division or span
	   @return boolean - true if disabled, false if enabled */
	_isDisabledDatepicker: function(target) {
		if (!target) {
			return false;
		}
		for (var i = 0; i &lt; this._disabledInputs.length; i++) {
			if (this._disabledInputs[i] == target)
				return true;
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	   @param  target  element - the target input field or division or span
	   @return  object - the associated instance data
	   @throws  error if a jQuery problem getting data */
	_getInst: function(target) {
		try {
			return $.data(target, PROP_NAME);
		}
		catch (err) {
			throw &#x27;Missing instance data for this datepicker&#x27;;
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span
	   @param  name    object - the new settings to update or
	                   string - the name of the setting to change or retrieve,
	                   when retrieving also &#x27;all&#x27; for all instance settings or
	                   &#x27;defaults&#x27; for all global defaults
	   @param  value   any - the new value for the setting
	                   (omit if above is an object or to retrieve a value) */
	_optionDatepicker: function(target, name, value) {
		var inst = this._getInst(target);
		if (arguments.length == 2 &amp;&amp; typeof name == &#x27;string&#x27;) {
			return (name == &#x27;defaults&#x27; ? $.extend({}, $.datepicker._defaults) :
				(inst ? (name == &#x27;all&#x27; ? $.extend({}, inst.settings) :
				this._get(inst, name)) : null));
		}
		var settings = name || {};
		if (typeof name == &#x27;string&#x27;) {
			settings = {};
			settings[name] = value;
		}
		if (inst) {
			if (this._curInst == inst) {
				this._hideDatepicker();
			}
			var date = this._getDateDatepicker(target, true);
			var minDate = this._getMinMaxDate(inst, &#x27;min&#x27;);
			var maxDate = this._getMinMaxDate(inst, &#x27;max&#x27;);
			extendRemove(inst.settings, settings);
			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn&#x27;t provided
			if (minDate !== null &amp;&amp; settings[&#x27;dateFormat&#x27;] !== undefined &amp;&amp; settings[&#x27;minDate&#x27;] === undefined)
				inst.settings.minDate = this._formatDate(inst, minDate);
			if (maxDate !== null &amp;&amp; settings[&#x27;dateFormat&#x27;] !== undefined &amp;&amp; settings[&#x27;maxDate&#x27;] === undefined)
				inst.settings.maxDate = this._formatDate(inst, maxDate);
			this._attachments($(target), inst);
			this._autoSize(inst);
			this._setDate(inst, date);
			this._updateAlternate(inst);
			this._updateDatepicker(inst);
		}
	},

	// change method deprecated
	_changeDatepicker: function(target, name, value) {
		this._optionDatepicker(target, name, value);
	},

	/* Redraw the date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span */
	_refreshDatepicker: function(target) {
		var inst = this._getInst(target);
		if (inst) {
			this._updateDatepicker(inst);
		}
	},

	/* Set the dates for a jQuery selection.
	   @param  target   element - the target input field or division or span
	   @param  date     Date - the new date */
	_setDateDatepicker: function(target, date) {
		var inst = this._getInst(target);
		if (inst) {
			this._setDate(inst, date);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	   @param  target     element - the target input field or division or span
	   @param  noDefault  boolean - true if no default date is to be used
	   @return Date - the current date */
	_getDateDatepicker: function(target, noDefault) {
		var inst = this._getInst(target);
		if (inst &amp;&amp; !inst.inline)
			this._setDateFromField(inst, noDefault);
		return (inst ? this._getDate(inst) : null);
	},

	/* Handle keystrokes. */
	_doKeyDown: function(event) {
		var inst = $.datepicker._getInst(event.target);
		var handled = true;
		var isRTL = inst.dpDiv.is(&#x27;.ui-datepicker-rtl&#x27;);
		inst._keyEvent = true;
		if ($.datepicker._datepickerShowing)
			switch (event.keyCode) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: var sel = $(&#x27;td.&#x27; + $.datepicker._dayOverClass + &#x27;:not(.&#x27; +
									$.datepicker._currentClass + &#x27;)&#x27;, inst.dpDiv);
						if (sel[0])
							$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
							var onSelect = $.datepicker._get(inst, &#x27;onSelect&#x27;);
							if (onSelect) {
								var dateStr = $.datepicker._formatDate(inst);

								// trigger custom callback
								onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
							}
						else
							$.datepicker._hideDatepicker();
						return false; // don&#x27;t submit the form
						break; // select the value on enter
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							-$.datepicker._get(inst, &#x27;stepBigMonths&#x27;) :
							-$.datepicker._get(inst, &#x27;stepMonths&#x27;)), &#x27;M&#x27;);
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							+$.datepicker._get(inst, &#x27;stepBigMonths&#x27;) :
							+$.datepicker._get(inst, &#x27;stepMonths&#x27;)), &#x27;M&#x27;);
						break; // next month/year on page down/+ ctrl
				case 35: if (event.ctrlKey || event.metaKey) $.datepicker._clearDate(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if (event.ctrlKey || event.metaKey) $.datepicker._gotoToday(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), &#x27;D&#x27;);
						handled = event.ctrlKey || event.metaKey;
						// -1 day on ctrl or command +left
						if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
									-$.datepicker._get(inst, &#x27;stepBigMonths&#x27;) :
									-$.datepicker._get(inst, &#x27;stepMonths&#x27;)), &#x27;M&#x27;);
						// next month/year on alt +left on Mac
						break;
				case 38: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, -7, &#x27;D&#x27;);
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), &#x27;D&#x27;);
						handled = event.ctrlKey || event.metaKey;
						// +1 day on ctrl or command +right
						if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
									+$.datepicker._get(inst, &#x27;stepBigMonths&#x27;) :
									+$.datepicker._get(inst, &#x27;stepMonths&#x27;)), &#x27;M&#x27;);
						// next month/year on alt +right
						break;
				case 40: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, +7, &#x27;D&#x27;);
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		else if (event.keyCode == 36 &amp;&amp; event.ctrlKey) // display the date picker on ctrl+home
			$.datepicker._showDatepicker(this);
		else {
			handled = false;
		}
		if (handled) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function(event) {
		var inst = $.datepicker._getInst(event.target);
		if ($.datepicker._get(inst, &#x27;constrainInput&#x27;)) {
			var chars = $.datepicker._possibleChars($.datepicker._get(inst, &#x27;dateFormat&#x27;));
			var chr = String.fromCharCode(event.charCode == undefined ? event.keyCode : event.charCode);
			return event.ctrlKey || event.metaKey || (chr &lt; &#x27; &#x27; || !chars || chars.indexOf(chr) &gt; -1);
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function(event) {
		var inst = $.datepicker._getInst(event.target);
		if (inst.input.val() != inst.lastVal) {
			try {
				var date = $.datepicker.parseDate($.datepicker._get(inst, &#x27;dateFormat&#x27;),
					(inst.input ? inst.input.val() : null),
					$.datepicker._getFormatConfig(inst));
				if (date) { // only if valid
					$.datepicker._setDateFromField(inst);
					$.datepicker._updateAlternate(inst);
					$.datepicker._updateDatepicker(inst);
				}
			}
			catch (err) {
				$.datepicker.log(err);
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	   If false returned from beforeShow event handler do not show.
	   @param  input  element - the input field attached to the date picker or
	                  event - if triggered by focus */
	_showDatepicker: function(input) {
		input = input.target || input;
		if (input.nodeName.toLowerCase() != &#x27;input&#x27;) // find from button/image trigger
			input = $(&#x27;input&#x27;, input.parentNode)[0];
		if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput == input) // already here
			return;
		var inst = $.datepicker._getInst(input);
		if ($.datepicker._curInst &amp;&amp; $.datepicker._curInst != inst) {
			$.datepicker._curInst.dpDiv.stop(true, true);
			if ( inst &amp;&amp; $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
			}
		}
		var beforeShow = $.datepicker._get(inst, &#x27;beforeShow&#x27;);
		var beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
		if(beforeShowSettings === false){
			//false
			return;
		}
		extendRemove(inst.settings, beforeShowSettings);
		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField(inst);
		if ($.datepicker._inDialog) // hide cursor
			input.value = &#x27;&#x27;;
		if (!$.datepicker._pos) { // position below input
			$.datepicker._pos = $.datepicker._findPos(input);
			$.datepicker._pos[1] += input.offsetHeight; // add the height
		}
		var isFixed = false;
		$(input).parents().each(function() {
			isFixed |= $(this).css(&#x27;position&#x27;) == &#x27;fixed&#x27;;
			return !isFixed;
		});
		var offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
		$.datepicker._pos = null;
		//to avoid flashes on Firefox
		inst.dpDiv.empty();
		// determine sizing offscreen
		inst.dpDiv.css({position: &#x27;absolute&#x27;, display: &#x27;block&#x27;, top: &#x27;-1000px&#x27;});
		$.datepicker._updateDatepicker(inst);
		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset(inst, offset, isFixed);
		inst.dpDiv.css({position: ($.datepicker._inDialog &amp;&amp; $.blockUI ?
			&#x27;static&#x27; : (isFixed ? &#x27;fixed&#x27; : &#x27;absolute&#x27;)), display: &#x27;none&#x27;,
			left: offset.left + &#x27;px&#x27;, top: offset.top + &#x27;px&#x27;});
		if (!inst.inline) {
			var showAnim = $.datepicker._get(inst, &#x27;showAnim&#x27;);
			var duration = $.datepicker._get(inst, &#x27;duration&#x27;);
			var postProcess = function() {
				var cover = inst.dpDiv.find(&#x27;iframe.ui-datepicker-cover&#x27;); // IE6- only
				if( !! cover.length ){
					var borders = $.datepicker._getBorders(inst.dpDiv);
					cover.css({left: -borders[0], top: -borders[1],
						width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()});
				}
			};
			inst.dpDiv.zIndex($(input).zIndex()+1);
			$.datepicker._datepickerShowing = true;

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects &amp;&amp; ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) )
				inst.dpDiv.show(showAnim, $.datepicker._get(inst, &#x27;showOptions&#x27;), duration, postProcess);
			else
				inst.dpDiv[showAnim || &#x27;show&#x27;]((showAnim ? duration : null), postProcess);
			if (!showAnim || !duration)
				postProcess();
			if (inst.input.is(&#x27;:visible&#x27;) &amp;&amp; !inst.input.is(&#x27;:disabled&#x27;))
				inst.input.focus();
			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function(inst) {
		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		var borders = $.datepicker._getBorders(inst.dpDiv);
		instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append(this._generateHTML(inst));
		this._attachHandlers(inst);
		var cover = inst.dpDiv.find(&#x27;iframe.ui-datepicker-cover&#x27;); // IE6- only
		if( !!cover.length ){ //avoid call to outerXXXX() when not in IE6
			cover.css({left: -borders[0], top: -borders[1], width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()})
		}
		inst.dpDiv.find(&#x27;.&#x27; + this._dayOverClass + &#x27; a&#x27;).mouseover();
		var numMonths = this._getNumberOfMonths(inst);
		var cols = numMonths[1];
		var width = 17;
		inst.dpDiv.removeClass(&#x27;ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4&#x27;).width(&#x27;&#x27;);
		if (cols &gt; 1)
			inst.dpDiv.addClass(&#x27;ui-datepicker-multi-&#x27; + cols).css(&#x27;width&#x27;, (width * cols) + &#x27;em&#x27;);
		inst.dpDiv[(numMonths[0] != 1 || numMonths[1] != 1 ? &#x27;add&#x27; : &#x27;remove&#x27;) +
			&#x27;Class&#x27;](&#x27;ui-datepicker-multi&#x27;);
		inst.dpDiv[(this._get(inst, &#x27;isRTL&#x27;) ? &#x27;add&#x27; : &#x27;remove&#x27;) +
			&#x27;Class&#x27;](&#x27;ui-datepicker-rtl&#x27;);
		if (inst == $.datepicker._curInst &amp;&amp; $.datepicker._datepickerShowing &amp;&amp; inst.input &amp;&amp;
				// #6694 - don&#x27;t focus the input if it&#x27;s already focused
				// this breaks the change event in IE
				inst.input.is(&#x27;:visible&#x27;) &amp;&amp; !inst.input.is(&#x27;:disabled&#x27;) &amp;&amp; inst.input[0] != document.activeElement)
			inst.input.focus();
		// deffered render of the years select (to avoid flashes on Firefox)
		if( inst.yearshtml ){
			var origyearshtml = inst.yearshtml;
			setTimeout(function(){
				//assure that inst.yearshtml didn&#x27;t change.
				if( origyearshtml === inst.yearshtml &amp;&amp; inst.yearshtml ){
					inst.dpDiv.find(&#x27;select.ui-datepicker-year:first&#x27;).replaceWith(inst.yearshtml);
				}
				origyearshtml = inst.yearshtml = null;
			}, 0);
		}
	},

	/* Retrieve the size of left and top borders for an element.
	   @param  elem  (jQuery object) the element of interest
	   @return  (number[2]) the left and top borders */
	_getBorders: function(elem) {
		var convert = function(value) {
			return {thin: 1, medium: 2, thick: 3}[value] || value;
		};
		return [parseFloat(convert(elem.css(&#x27;border-left-width&#x27;))),
			parseFloat(convert(elem.css(&#x27;border-top-width&#x27;)))];
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function(inst, offset, isFixed) {
		var dpWidth = inst.dpDiv.outerWidth();
		var dpHeight = inst.dpDiv.outerHeight();
		var inputWidth = inst.input ? inst.input.outerWidth() : 0;
		var inputHeight = inst.input ? inst.input.outerHeight() : 0;
		var viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft());
		var viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

		offset.left -= (this._get(inst, &#x27;isRTL&#x27;) ? (dpWidth - inputWidth) : 0);
		offset.left -= (isFixed &amp;&amp; offset.left == inst.input.offset().left) ? $(document).scrollLeft() : 0;
		offset.top -= (isFixed &amp;&amp; offset.top == (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

		// now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min(offset.left, (offset.left + dpWidth &gt; viewWidth &amp;&amp; viewWidth &gt; dpWidth) ?
			Math.abs(offset.left + dpWidth - viewWidth) : 0);
		offset.top -= Math.min(offset.top, (offset.top + dpHeight &gt; viewHeight &amp;&amp; viewHeight &gt; dpHeight) ?
			Math.abs(dpHeight + inputHeight) : 0);

		return offset;
	},

	/* Find an object&#x27;s position on the screen. */
	_findPos: function(obj) {
		var inst = this._getInst(obj);
		var isRTL = this._get(inst, &#x27;isRTL&#x27;);
		while (obj &amp;&amp; (obj.type == &#x27;hidden&#x27; || obj.nodeType != 1 || $.expr.filters.hidden(obj))) {
			obj = obj[isRTL ? &#x27;previousSibling&#x27; : &#x27;nextSibling&#x27;];
		}
		var position = $(obj).offset();
		return [position.left, position.top];
	},

	/* Hide the date picker from view.
	   @param  input  element - the input field attached to the date picker */
	_hideDatepicker: function(input) {
		var inst = this._curInst;
		if (!inst || (input &amp;&amp; inst != $.data(input, PROP_NAME)))
			return;
		if (this._datepickerShowing) {
			var showAnim = this._get(inst, &#x27;showAnim&#x27;);
			var duration = this._get(inst, &#x27;duration&#x27;);
			var postProcess = function() {
				$.datepicker._tidyDialog(inst);
			};

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects &amp;&amp; ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) )
				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, &#x27;showOptions&#x27;), duration, postProcess);
			else
				inst.dpDiv[(showAnim == &#x27;slideDown&#x27; ? &#x27;slideUp&#x27; :
					(showAnim == &#x27;fadeIn&#x27; ? &#x27;fadeOut&#x27; : &#x27;hide&#x27;))]((showAnim ? duration : null), postProcess);
			if (!showAnim)
				postProcess();
			this._datepickerShowing = false;
			var onClose = this._get(inst, &#x27;onClose&#x27;);
			if (onClose)
				onClose.apply((inst.input ? inst.input[0] : null),
					[(inst.input ? inst.input.val() : &#x27;&#x27;), inst]);
			this._lastInput = null;
			if (this._inDialog) {
				this._dialogInput.css({ position: &#x27;absolute&#x27;, left: &#x27;0&#x27;, top: &#x27;-100px&#x27; });
				if ($.blockUI) {
					$.unblockUI();
					$(&#x27;body&#x27;).append(this.dpDiv);
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function(inst) {
		inst.dpDiv.removeClass(this._dialogClass).unbind(&#x27;.ui-datepicker-calendar&#x27;);
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function(event) {
		if (!$.datepicker._curInst)
			return;

		var $target = $(event.target),
			inst = $.datepicker._getInst($target[0]);

		if ( ( ( $target[0].id != $.datepicker._mainDivId &amp;&amp;
				$target.parents(&#x27;#&#x27; + $.datepicker._mainDivId).length == 0 &amp;&amp;
				!$target.hasClass($.datepicker.markerClassName) &amp;&amp;
				!$target.closest(&quot;.&quot; + $.datepicker._triggerClass).length &amp;&amp;
				$.datepicker._datepickerShowing &amp;&amp; !($.datepicker._inDialog &amp;&amp; $.blockUI) ) ) ||
			( $target.hasClass($.datepicker.markerClassName) &amp;&amp; $.datepicker._curInst != inst ) )
			$.datepicker._hideDatepicker();
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function(id, offset, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._isDisabledDatepicker(target[0])) {
			return;
		}
		this._adjustInstDate(inst, offset +
			(period == &#x27;M&#x27; ? this._get(inst, &#x27;showCurrentAtPos&#x27;) : 0), // undo positioning
			period);
		this._updateDatepicker(inst);
	},

	/* Action for current link. */
	_gotoToday: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._get(inst, &#x27;gotoCurrent&#x27;) &amp;&amp; inst.currentDay) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		}
		else {
			var date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function(id, select, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		inst[&#x27;selected&#x27; + (period == &#x27;M&#x27; ? &#x27;Month&#x27; : &#x27;Year&#x27;)] =
		inst[&#x27;draw&#x27; + (period == &#x27;M&#x27; ? &#x27;Month&#x27; : &#x27;Year&#x27;)] =
			parseInt(select.options[select.selectedIndex].value,10);
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a day. */
	_selectDay: function(id, month, year, td) {
		var target = $(id);
		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
			return;
		}
		var inst = this._getInst(target[0]);
		inst.selectedDay = inst.currentDay = $(&#x27;a&#x27;, td).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate(id, this._formatDate(inst,
			inst.currentDay, inst.currentMonth, inst.currentYear));
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		this._selectDate(target, &#x27;&#x27;);
	},

	/* Update the input field with the selected date. */
	_selectDate: function(id, dateStr) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input)
			inst.input.val(dateStr);
		this._updateAlternate(inst);
		var onSelect = this._get(inst, &#x27;onSelect&#x27;);
		if (onSelect)
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
		else if (inst.input)
			inst.input.trigger(&#x27;change&#x27;); // fire the change event
		if (inst.inline)
			this._updateDatepicker(inst);
		else {
			this._hideDatepicker();
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) != &#x27;object&#x27;)
				inst.input.focus(); // restore focus
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function(inst) {
		var altField = this._get(inst, &#x27;altField&#x27;);
		if (altField) { // update alternate field too
			var altFormat = this._get(inst, &#x27;altFormat&#x27;) || this._get(inst, &#x27;dateFormat&#x27;);
			var date = this._getDate(inst);
			var dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
			$(altField).each(function() { $(this).val(dateStr); });
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	   @param  date  Date - the date to customise
	   @return [boolean, string] - is this date selectable?, what is its CSS class? */
	noWeekends: function(date) {
		var day = date.getDay();
		return [(day &gt; 0 &amp;&amp; day &lt; 6), &#x27;&#x27;];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	   @param  date  Date - the date to get the week for
	   @return  number - the number of the week within the year that contains this date */
	iso8601Week: function(date) {
		var checkDate = new Date(date.getTime());
		// Find Thursday of this week starting on Monday
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
		var time = checkDate.getTime();
		checkDate.setMonth(0); // Compare with Jan 1
		checkDate.setDate(1);
		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	},

	/* Parse a string value into a date object.
	   See formatDate below for the possible formats.

	   @param  format    string - the expected format of the date
	   @param  value     string - the date in the above format
	   @param  settings  Object - attributes include:
	                     shortYearCutoff  number - the cutoff year for determining the century (optional)
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  Date - the extracted date value or null if value is blank */
	parseDate: function (format, value, settings) {
		if (format == null || value == null)
			throw &#x27;Invalid arguments&#x27;;
		value = (typeof value == &#x27;object&#x27; ? value.toString() : value + &#x27;&#x27;);
		if (value == &#x27;&#x27;)
			return null;
		var shortYearCutoff = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff;
		shortYearCutoff = (typeof shortYearCutoff != &#x27;string&#x27; ? shortYearCutoff :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		var year = -1;
		var month = -1;
		var day = -1;
		var doy = -1;
		var literal = false;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 &lt; format.length &amp;&amp; format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		// Extract a number from the string value
		var getNumber = function(match) {
			var isDoubled = lookAhead(match);
			var size = (match == &#x27;@&#x27; ? 14 : (match == &#x27;!&#x27; ? 20 :
				(match == &#x27;y&#x27; &amp;&amp; isDoubled ? 4 : (match == &#x27;o&#x27; ? 3 : 2))));
			var digits = new RegExp(&#x27;^\\d{1,&#x27; + size + &#x27;}&#x27;);
			var num = value.substring(iValue).match(digits);
			if (!num)
				throw &#x27;Missing number at position &#x27; + iValue;
			iValue += num[0].length;
			return parseInt(num[0], 10);
		};
		// Extract a name from the string value and convert to an index
		var getName = function(match, shortNames, longNames) {
			var names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
				return [ [k, v] ];
			}).sort(function (a, b) {
				return -(a[1].length - b[1].length);
			});
			var index = -1;
			$.each(names, function (i, pair) {
				var name = pair[1];
				if (value.substr(iValue, name.length).toLowerCase() == name.toLowerCase()) {
					index = pair[0];
					iValue += name.length;
					return false;
				}
			});
			if (index != -1)
				return index + 1;
			else
				throw &#x27;Unknown name at position &#x27; + iValue;
		};
		// Confirm that a literal character matches the string value
		var checkLiteral = function() {
			if (value.charAt(iValue) != format.charAt(iFormat))
				throw &#x27;Unexpected literal at position &#x27; + iValue;
			iValue++;
		};
		var iValue = 0;
		for (var iFormat = 0; iFormat &lt; format.length; iFormat++) {
			if (literal)
				if (format.charAt(iFormat) == &quot;&#x27;&quot; &amp;&amp; !lookAhead(&quot;&#x27;&quot;))
					literal = false;
				else
					checkLiteral();
			else
				switch (format.charAt(iFormat)) {
					case &#x27;d&#x27;:
						day = getNumber(&#x27;d&#x27;);
						break;
					case &#x27;D&#x27;:
						getName(&#x27;D&#x27;, dayNamesShort, dayNames);
						break;
					case &#x27;o&#x27;:
						doy = getNumber(&#x27;o&#x27;);
						break;
					case &#x27;m&#x27;:
						month = getNumber(&#x27;m&#x27;);
						break;
					case &#x27;M&#x27;:
						month = getName(&#x27;M&#x27;, monthNamesShort, monthNames);
						break;
					case &#x27;y&#x27;:
						year = getNumber(&#x27;y&#x27;);
						break;
					case &#x27;@&#x27;:
						var date = new Date(getNumber(&#x27;@&#x27;));
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case &#x27;!&#x27;:
						var date = new Date((getNumber(&#x27;!&#x27;) - this._ticksTo1970) / 10000);
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case &quot;&#x27;&quot;:
						if (lookAhead(&quot;&#x27;&quot;))
							checkLiteral();
						else
							literal = true;
						break;
					default:
						checkLiteral();
				}
		}
		if (iValue &lt; value.length){
			var extra = value.substr(iValue);
			if (!/^\s+/.test(extra)) {
				throw &quot;Extra/unparsed characters found in date: &quot; + extra;
			}
		}
		if (year == -1)
			year = new Date().getFullYear();
		else if (year &lt; 100)
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				(year &lt;= shortYearCutoff ? 0 : -100);
		if (doy &gt; -1) {
			month = 1;
			day = doy;
			do {
				var dim = this._getDaysInMonth(year, month - 1);
				if (day &lt;= dim)
					break;
				month++;
				day -= dim;
			} while (true);
		}
		var date = this._daylightSavingAdjust(new Date(year, month - 1, day));
		if (date.getFullYear() != year || date.getMonth() + 1 != month || date.getDate() != day)
			throw &#x27;Invalid date&#x27;; // E.g. 31/02/00
		return date;
	},

	/* Standard date formats. */
	ATOM: &#x27;yy-mm-dd&#x27;, // RFC 3339 (ISO 8601)
	COOKIE: &#x27;D, dd M yy&#x27;,
	ISO_8601: &#x27;yy-mm-dd&#x27;,
	RFC_822: &#x27;D, d M y&#x27;,
	RFC_850: &#x27;DD, dd-M-y&#x27;,
	RFC_1036: &#x27;D, d M y&#x27;,
	RFC_1123: &#x27;D, d M yy&#x27;,
	RFC_2822: &#x27;D, d M yy&#x27;,
	RSS: &#x27;D, d M y&#x27;, // RFC 822
	TICKS: &#x27;!&#x27;,
	TIMESTAMP: &#x27;@&#x27;,
	W3C: &#x27;yy-mm-dd&#x27;, // ISO 8601

	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

	/* Format a date object into a string value.
	   The format can be combinations of the following:
	   d  - day of month (no leading zero)
	   dd - day of month (two digit)
	   o  - day of year (no leading zeros)
	   oo - day of year (three digit)
	   D  - day name short
	   DD - day name long
	   m  - month of year (no leading zero)
	   mm - month of year (two digit)
	   M  - month name short
	   MM - month name long
	   y  - year (two digit)
	   yy - year (four digit)
	   @ - Unix timestamp (ms since 01/01/1970)
	   ! - Windows ticks (100ns since 01/01/0001)
	   &#x27;...&#x27; - literal text
	   &#x27;&#x27; - single quote

	   @param  format    string - the desired format of the date
	   @param  date      Date - the date value to format
	   @param  settings  Object - attributes include:
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  string - the date in the above format */
	formatDate: function (format, date, settings) {
		if (!date)
			return &#x27;&#x27;;
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 &lt; format.length &amp;&amp; format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		// Format a number, with leading zero if necessary
		var formatNumber = function(match, value, len) {
			var num = &#x27;&#x27; + value;
			if (lookAhead(match))
				while (num.length &lt; len)
					num = &#x27;0&#x27; + num;
			return num;
		};
		// Format a name, short or long as requested
		var formatName = function(match, value, shortNames, longNames) {
			return (lookAhead(match) ? longNames[value] : shortNames[value]);
		};
		var output = &#x27;&#x27;;
		var literal = false;
		if (date)
			for (var iFormat = 0; iFormat &lt; format.length; iFormat++) {
				if (literal)
					if (format.charAt(iFormat) == &quot;&#x27;&quot; &amp;&amp; !lookAhead(&quot;&#x27;&quot;))
						literal = false;
					else
						output += format.charAt(iFormat);
				else
					switch (format.charAt(iFormat)) {
						case &#x27;d&#x27;:
							output += formatNumber(&#x27;d&#x27;, date.getDate(), 2);
							break;
						case &#x27;D&#x27;:
							output += formatName(&#x27;D&#x27;, date.getDay(), dayNamesShort, dayNames);
							break;
						case &#x27;o&#x27;:
							output += formatNumber(&#x27;o&#x27;,
								Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
							break;
						case &#x27;m&#x27;:
							output += formatNumber(&#x27;m&#x27;, date.getMonth() + 1, 2);
							break;
						case &#x27;M&#x27;:
							output += formatName(&#x27;M&#x27;, date.getMonth(), monthNamesShort, monthNames);
							break;
						case &#x27;y&#x27;:
							output += (lookAhead(&#x27;y&#x27;) ? date.getFullYear() :
								(date.getYear() % 100 &lt; 10 ? &#x27;0&#x27; : &#x27;&#x27;) + date.getYear() % 100);
							break;
						case &#x27;@&#x27;:
							output += date.getTime();
							break;
						case &#x27;!&#x27;:
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case &quot;&#x27;&quot;:
							if (lookAhead(&quot;&#x27;&quot;))
								output += &quot;&#x27;&quot;;
							else
								literal = true;
							break;
						default:
							output += format.charAt(iFormat);
					}
			}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function (format) {
		var chars = &#x27;&#x27;;
		var literal = false;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 &lt; format.length &amp;&amp; format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		for (var iFormat = 0; iFormat &lt; format.length; iFormat++)
			if (literal)
				if (format.charAt(iFormat) == &quot;&#x27;&quot; &amp;&amp; !lookAhead(&quot;&#x27;&quot;))
					literal = false;
				else
					chars += format.charAt(iFormat);
			else
				switch (format.charAt(iFormat)) {
					case &#x27;d&#x27;: case &#x27;m&#x27;: case &#x27;y&#x27;: case &#x27;@&#x27;:
						chars += &#x27;0123456789&#x27;;
						break;
					case &#x27;D&#x27;: case &#x27;M&#x27;:
						return null; // Accept anything
					case &quot;&#x27;&quot;:
						if (lookAhead(&quot;&#x27;&quot;))
							chars += &quot;&#x27;&quot;;
						else
							literal = true;
						break;
					default:
						chars += format.charAt(iFormat);
				}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function(inst, name) {
		return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function(inst, noDefault) {
		if (inst.input.val() == inst.lastVal) {
			return;
		}
		var dateFormat = this._get(inst, &#x27;dateFormat&#x27;);
		var dates = inst.lastVal = inst.input ? inst.input.val() : null;
		var date, defaultDate;
		date = defaultDate = this._getDefaultDate(inst);
		var settings = this._getFormatConfig(inst);
		try {
			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
		} catch (event) {
			this.log(event);
			dates = (noDefault ? &#x27;&#x27; : dates);
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = (dates ? date.getDate() : 0);
		inst.currentMonth = (dates ? date.getMonth() : 0);
		inst.currentYear = (dates ? date.getFullYear() : 0);
		this._adjustInstDate(inst);
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function(inst) {
		return this._restrictMinMax(inst,
			this._determineDate(inst, this._get(inst, &#x27;defaultDate&#x27;), new Date()));
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function(inst, date, defaultDate) {
		var offsetNumeric = function(offset) {
			var date = new Date();
			date.setDate(date.getDate() + offset);
			return date;
		};
		var offsetString = function(offset) {
			try {
				return $.datepicker.parseDate($.datepicker._get(inst, &#x27;dateFormat&#x27;),
					offset, $.datepicker._getFormatConfig(inst));
			}
			catch (e) {
				// Ignore
			}
			var date = (offset.toLowerCase().match(/^c/) ?
				$.datepicker._getDate(inst) : null) || new Date();
			var year = date.getFullYear();
			var month = date.getMonth();
			var day = date.getDate();
			var pattern = /([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g;
			var matches = pattern.exec(offset);
			while (matches) {
				switch (matches[2] || &#x27;d&#x27;) {
					case &#x27;d&#x27; : case &#x27;D&#x27; :
						day += parseInt(matches[1],10); break;
					case &#x27;w&#x27; : case &#x27;W&#x27; :
						day += parseInt(matches[1],10) * 7; break;
					case &#x27;m&#x27; : case &#x27;M&#x27; :
						month += parseInt(matches[1],10);
						day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
						break;
					case &#x27;y&#x27;: case &#x27;Y&#x27; :
						year += parseInt(matches[1],10);
						day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
						break;
				}
				matches = pattern.exec(offset);
			}
			return new Date(year, month, day);
		};
		var newDate = (date == null || date === &#x27;&#x27; ? defaultDate : (typeof date == &#x27;string&#x27; ? offsetString(date) :
			(typeof date == &#x27;number&#x27; ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));
		newDate = (newDate &amp;&amp; newDate.toString() == &#x27;Invalid Date&#x27; ? defaultDate : newDate);
		if (newDate) {
			newDate.setHours(0);
			newDate.setMinutes(0);
			newDate.setSeconds(0);
			newDate.setMilliseconds(0);
		}
		return this._daylightSavingAdjust(newDate);
	},

	/* Handle switch to/from daylight saving.
	   Hours may be non-zero on daylight saving cut-over:
	   &gt; 12 when midnight changeover, but then cannot generate
	   midnight datetime, so jump to 1AM, otherwise reset.
	   @param  date  (Date) the date to check
	   @return  (Date) the corrected date */
	_daylightSavingAdjust: function(date) {
		if (!date) return null;
		date.setHours(date.getHours() &gt; 12 ? date.getHours() + 2 : 0);
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function(inst, date, noChange) {
		var clear = !date;
		var origMonth = inst.selectedMonth;
		var origYear = inst.selectedYear;
		var newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ((origMonth != inst.selectedMonth || origYear != inst.selectedYear) &amp;&amp; !noChange)
			this._notifyChange(inst);
		this._adjustInstDate(inst);
		if (inst.input) {
			inst.input.val(clear ? &#x27;&#x27; : this._formatDate(inst));
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function(inst) {
		var startDate = (!inst.currentYear || (inst.input &amp;&amp; inst.input.val() == &#x27;&#x27;) ? null :
			this._daylightSavingAdjust(new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay)));
			return startDate;
	},

	/* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
	_attachHandlers: function(inst) {
		var stepMonths = this._get(inst, &#x27;stepMonths&#x27;);
		var id = &#x27;#&#x27; + inst.id.replace( /\\\\/g, &quot;\\&quot; );
		inst.dpDiv.find(&#x27;[data-handler]&#x27;).map(function () {
			var handler = {
				prev: function () {
					window[&#x27;DP_jQuery_&#x27; + dpuuid].datepicker._adjustDate(id, -stepMonths, &#x27;M&#x27;);
				},
				next: function () {
					window[&#x27;DP_jQuery_&#x27; + dpuuid].datepicker._adjustDate(id, +stepMonths, &#x27;M&#x27;);
				},
				hide: function () {
					window[&#x27;DP_jQuery_&#x27; + dpuuid].datepicker._hideDatepicker();
				},
				today: function () {
					window[&#x27;DP_jQuery_&#x27; + dpuuid].datepicker._gotoToday(id);
				},
				selectDay: function () {
					window[&#x27;DP_jQuery_&#x27; + dpuuid].datepicker._selectDay(id, +this.getAttribute(&#x27;data-month&#x27;), +this.getAttribute(&#x27;data-year&#x27;), this);
					return false;
				},
				selectMonth: function () {
					window[&#x27;DP_jQuery_&#x27; + dpuuid].datepicker._selectMonthYear(id, this, &#x27;M&#x27;);
					return false;
				},
				selectYear: function () {
					window[&#x27;DP_jQuery_&#x27; + dpuuid].datepicker._selectMonthYear(id, this, &#x27;Y&#x27;);
					return false;
				}
			};
			$(this).bind(this.getAttribute(&#x27;data-event&#x27;), handler[this.getAttribute(&#x27;data-handler&#x27;)]);
		});
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function(inst) {
		var today = new Date();
		today = this._daylightSavingAdjust(
			new Date(today.getFullYear(), today.getMonth(), today.getDate())); // clear time
		var isRTL = this._get(inst, &#x27;isRTL&#x27;);
		var showButtonPanel = this._get(inst, &#x27;showButtonPanel&#x27;);
		var hideIfNoPrevNext = this._get(inst, &#x27;hideIfNoPrevNext&#x27;);
		var navigationAsDateFormat = this._get(inst, &#x27;navigationAsDateFormat&#x27;);
		var numMonths = this._getNumberOfMonths(inst);
		var showCurrentAtPos = this._get(inst, &#x27;showCurrentAtPos&#x27;);
		var stepMonths = this._get(inst, &#x27;stepMonths&#x27;);
		var isMultiMonth = (numMonths[0] != 1 || numMonths[1] != 1);
		var currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
			new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		var minDate = this._getMinMaxDate(inst, &#x27;min&#x27;);
		var maxDate = this._getMinMaxDate(inst, &#x27;max&#x27;);
		var drawMonth = inst.drawMonth - showCurrentAtPos;
		var drawYear = inst.drawYear;
		if (drawMonth &lt; 0) {
			drawMonth += 12;
			drawYear--;
		}
		if (maxDate) {
			var maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
			maxDraw = (minDate &amp;&amp; maxDraw &lt; minDate ? minDate : maxDraw);
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) &gt; maxDraw) {
				drawMonth--;
				if (drawMonth &lt; 0) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;
		var prevText = this._get(inst, &#x27;prevText&#x27;);
		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
			this._getFormatConfig(inst)));
		var prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
			&#x27;&lt;a class=&quot;ui-datepicker-prev ui-corner-all&quot; data-handler=&quot;prev&quot; data-event=&quot;click&quot;&#x27; +
			&#x27; title=&quot;&#x27; + prevText + &#x27;&quot;&gt;&lt;span class=&quot;ui-icon ui-icon-circle-triangle-&#x27; + ( isRTL ? &#x27;e&#x27; : &#x27;w&#x27;) + &#x27;&quot;&gt;&#x27; + prevText + &#x27;&lt;/span&gt;&lt;/a&gt;&#x27; :
			(hideIfNoPrevNext ? &#x27;&#x27; : &#x27;&lt;a class=&quot;ui-datepicker-prev ui-corner-all ui-state-disabled&quot; title=&quot;&#x27;+ prevText +&#x27;&quot;&gt;&lt;span class=&quot;ui-icon ui-icon-circle-triangle-&#x27; + ( isRTL ? &#x27;e&#x27; : &#x27;w&#x27;) + &#x27;&quot;&gt;&#x27; + prevText + &#x27;&lt;/span&gt;&lt;/a&gt;&#x27;));
		var nextText = this._get(inst, &#x27;nextText&#x27;);
		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
			this._getFormatConfig(inst)));
		var next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
			&#x27;&lt;a class=&quot;ui-datepicker-next ui-corner-all&quot; data-handler=&quot;next&quot; data-event=&quot;click&quot;&#x27; +
			&#x27; title=&quot;&#x27; + nextText + &#x27;&quot;&gt;&lt;span class=&quot;ui-icon ui-icon-circle-triangle-&#x27; + ( isRTL ? &#x27;w&#x27; : &#x27;e&#x27;) + &#x27;&quot;&gt;&#x27; + nextText + &#x27;&lt;/span&gt;&lt;/a&gt;&#x27; :
			(hideIfNoPrevNext ? &#x27;&#x27; : &#x27;&lt;a class=&quot;ui-datepicker-next ui-corner-all ui-state-disabled&quot; title=&quot;&#x27;+ nextText + &#x27;&quot;&gt;&lt;span class=&quot;ui-icon ui-icon-circle-triangle-&#x27; + ( isRTL ? &#x27;w&#x27; : &#x27;e&#x27;) + &#x27;&quot;&gt;&#x27; + nextText + &#x27;&lt;/span&gt;&lt;/a&gt;&#x27;));
		var currentText = this._get(inst, &#x27;currentText&#x27;);
		var gotoDate = (this._get(inst, &#x27;gotoCurrent&#x27;) &amp;&amp; inst.currentDay ? currentDate : today);
		currentText = (!navigationAsDateFormat ? currentText :
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));
		var controls = (!inst.inline ? &#x27;&lt;button type=&quot;button&quot; class=&quot;ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all&quot; data-handler=&quot;hide&quot; data-event=&quot;click&quot;&gt;&#x27; +
			this._get(inst, &#x27;closeText&#x27;) + &#x27;&lt;/button&gt;&#x27; : &#x27;&#x27;);
		var buttonPanel = (showButtonPanel) ? &#x27;&lt;div class=&quot;ui-datepicker-buttonpane ui-widget-content&quot;&gt;&#x27; + (isRTL ? controls : &#x27;&#x27;) +
			(this._isInRange(inst, gotoDate) ? &#x27;&lt;button type=&quot;button&quot; class=&quot;ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all&quot; data-handler=&quot;today&quot; data-event=&quot;click&quot;&#x27; +
			&#x27;&gt;&#x27; + currentText + &#x27;&lt;/button&gt;&#x27; : &#x27;&#x27;) + (isRTL ? &#x27;&#x27; : controls) + &#x27;&lt;/div&gt;&#x27; : &#x27;&#x27;;
		var firstDay = parseInt(this._get(inst, &#x27;firstDay&#x27;),10);
		firstDay = (isNaN(firstDay) ? 0 : firstDay);
		var showWeek = this._get(inst, &#x27;showWeek&#x27;);
		var dayNames = this._get(inst, &#x27;dayNames&#x27;);
		var dayNamesShort = this._get(inst, &#x27;dayNamesShort&#x27;);
		var dayNamesMin = this._get(inst, &#x27;dayNamesMin&#x27;);
		var monthNames = this._get(inst, &#x27;monthNames&#x27;);
		var monthNamesShort = this._get(inst, &#x27;monthNamesShort&#x27;);
		var beforeShowDay = this._get(inst, &#x27;beforeShowDay&#x27;);
		var showOtherMonths = this._get(inst, &#x27;showOtherMonths&#x27;);
		var selectOtherMonths = this._get(inst, &#x27;selectOtherMonths&#x27;);
		var calculateWeek = this._get(inst, &#x27;calculateWeek&#x27;) || this.iso8601Week;
		var defaultDate = this._getDefaultDate(inst);
		var html = &#x27;&#x27;;
		for (var row = 0; row &lt; numMonths[0]; row++) {
			var group = &#x27;&#x27;;
			this.maxRows = 4;
			for (var col = 0; col &lt; numMonths[1]; col++) {
				var selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
				var cornerClass = &#x27; ui-corner-all&#x27;;
				var calender = &#x27;&#x27;;
				if (isMultiMonth) {
					calender += &#x27;&lt;div class=&quot;ui-datepicker-group&#x27;;
					if (numMonths[1] &gt; 1)
						switch (col) {
							case 0: calender += &#x27; ui-datepicker-group-first&#x27;;
								cornerClass = &#x27; ui-corner-&#x27; + (isRTL ? &#x27;right&#x27; : &#x27;left&#x27;); break;
							case numMonths[1]-1: calender += &#x27; ui-datepicker-group-last&#x27;;
								cornerClass = &#x27; ui-corner-&#x27; + (isRTL ? &#x27;left&#x27; : &#x27;right&#x27;); break;
							default: calender += &#x27; ui-datepicker-group-middle&#x27;; cornerClass = &#x27;&#x27;; break;
						}
					calender += &#x27;&quot;&gt;&#x27;;
				}
				calender += &#x27;&lt;div class=&quot;ui-datepicker-header ui-widget-header ui-helper-clearfix&#x27; + cornerClass + &#x27;&quot;&gt;&#x27; +
					(/all|left/.test(cornerClass) &amp;&amp; row == 0 ? (isRTL ? next : prev) : &#x27;&#x27;) +
					(/all|right/.test(cornerClass) &amp;&amp; row == 0 ? (isRTL ? prev : next) : &#x27;&#x27;) +
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
					row &gt; 0 || col &gt; 0, monthNames, monthNamesShort) + // draw month headers
					&#x27;&lt;/div&gt;&lt;table class=&quot;ui-datepicker-calendar&quot;&gt;&lt;thead&gt;&#x27; +
					&#x27;&lt;tr&gt;&#x27;;
				var thead = (showWeek ? &#x27;&lt;th class=&quot;ui-datepicker-week-col&quot;&gt;&#x27; + this._get(inst, &#x27;weekHeader&#x27;) + &#x27;&lt;/th&gt;&#x27; : &#x27;&#x27;);
				for (var dow = 0; dow &lt; 7; dow++) { // days of the week
					var day = (dow + firstDay) % 7;
					thead += &#x27;&lt;th&#x27; + ((dow + firstDay + 6) % 7 &gt;= 5 ? &#x27; class=&quot;ui-datepicker-week-end&quot;&#x27; : &#x27;&#x27;) + &#x27;&gt;&#x27; +
						&#x27;&lt;span title=&quot;&#x27; + dayNames[day] + &#x27;&quot;&gt;&#x27; + dayNamesMin[day] + &#x27;&lt;/span&gt;&lt;/th&gt;&#x27;;
				}
				calender += thead + &#x27;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&#x27;;
				var daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
				if (drawYear == inst.selectedYear &amp;&amp; drawMonth == inst.selectedMonth)
					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
				var leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
				var curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
				var numRows = (isMultiMonth ? this.maxRows &gt; curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				var printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
				for (var dRow = 0; dRow &lt; numRows; dRow++) { // create date picker rows
					calender += &#x27;&lt;tr&gt;&#x27;;
					var tbody = (!showWeek ? &#x27;&#x27; : &#x27;&lt;td class=&quot;ui-datepicker-week-col&quot;&gt;&#x27; +
						this._get(inst, &#x27;calculateWeek&#x27;)(printDate) + &#x27;&lt;/td&gt;&#x27;);
					for (var dow = 0; dow &lt; 7; dow++) { // create date picker days
						var daySettings = (beforeShowDay ?
							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, &#x27;&#x27;]);
						var otherMonth = (printDate.getMonth() != drawMonth);
						var unselectable = (otherMonth &amp;&amp; !selectOtherMonths) || !daySettings[0] ||
							(minDate &amp;&amp; printDate &lt; minDate) || (maxDate &amp;&amp; printDate &gt; maxDate);
						tbody += &#x27;&lt;td class=&quot;&#x27; +
							((dow + firstDay + 6) % 7 &gt;= 5 ? &#x27; ui-datepicker-week-end&#x27; : &#x27;&#x27;) + // highlight weekends
							(otherMonth ? &#x27; ui-datepicker-other-month&#x27; : &#x27;&#x27;) + // highlight days from other months
							((printDate.getTime() == selectedDate.getTime() &amp;&amp; drawMonth == inst.selectedMonth &amp;&amp; inst._keyEvent) || // user pressed key
							(defaultDate.getTime() == printDate.getTime() &amp;&amp; defaultDate.getTime() == selectedDate.getTime()) ?
							// or defaultDate is current printedDate and defaultDate is selectedDate
							&#x27; &#x27; + this._dayOverClass : &#x27;&#x27;) + // highlight selected day
							(unselectable ? &#x27; &#x27; + this._unselectableClass + &#x27; ui-state-disabled&#x27;: &#x27;&#x27;) +  // highlight unselectable days
							(otherMonth &amp;&amp; !showOtherMonths ? &#x27;&#x27; : &#x27; &#x27; + daySettings[1] + // highlight custom dates
							(printDate.getTime() == currentDate.getTime() ? &#x27; &#x27; + this._currentClass : &#x27;&#x27;) + // highlight selected day
							(printDate.getTime() == today.getTime() ? &#x27; ui-datepicker-today&#x27; : &#x27;&#x27;)) + &#x27;&quot;&#x27; + // highlight today (if different)
							((!otherMonth || showOtherMonths) &amp;&amp; daySettings[2] ? &#x27; title=&quot;&#x27; + daySettings[2] + &#x27;&quot;&#x27; : &#x27;&#x27;) + // cell title
							(unselectable ? &#x27;&#x27; : &#x27; data-handler=&quot;selectDay&quot; data-event=&quot;click&quot; data-month=&quot;&#x27; + printDate.getMonth() + &#x27;&quot; data-year=&quot;&#x27; + printDate.getFullYear() + &#x27;&quot;&#x27;) + &#x27;&gt;&#x27; + // actions
							(otherMonth &amp;&amp; !showOtherMonths ? &#x27;&amp;#xa0;&#x27; : // display for other months
							(unselectable ? &#x27;&lt;span class=&quot;ui-state-default&quot;&gt;&#x27; + printDate.getDate() + &#x27;&lt;/span&gt;&#x27; : &#x27;&lt;a class=&quot;ui-state-default&#x27; +
							(printDate.getTime() == today.getTime() ? &#x27; ui-state-highlight&#x27; : &#x27;&#x27;) +
							(printDate.getTime() == currentDate.getTime() ? &#x27; ui-state-active&#x27; : &#x27;&#x27;) + // highlight selected day
							(otherMonth ? &#x27; ui-priority-secondary&#x27; : &#x27;&#x27;) + // distinguish dates from other months
							&#x27;&quot; href=&quot;#&quot;&gt;&#x27; + printDate.getDate() + &#x27;&lt;/a&gt;&#x27;)) + &#x27;&lt;/td&gt;&#x27;; // display selectable date
						printDate.setDate(printDate.getDate() + 1);
						printDate = this._daylightSavingAdjust(printDate);
					}
					calender += tbody + &#x27;&lt;/tr&gt;&#x27;;
				}
				drawMonth++;
				if (drawMonth &gt; 11) {
					drawMonth = 0;
					drawYear++;
				}
				calender += &#x27;&lt;/tbody&gt;&lt;/table&gt;&#x27; + (isMultiMonth ? &#x27;&lt;/div&gt;&#x27; +
							((numMonths[0] &gt; 0 &amp;&amp; col == numMonths[1]-1) ? &#x27;&lt;div class=&quot;ui-datepicker-row-break&quot;&gt;&lt;/div&gt;&#x27; : &#x27;&#x27;) : &#x27;&#x27;);
				group += calender;
			}
			html += group;
		}
		html += buttonPanel + ($.ui.ie6 &amp;&amp; !inst.inline ?
			&#x27;&lt;iframe src=&quot;javascript:false;&quot; class=&quot;ui-datepicker-cover&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&#x27; : &#x27;&#x27;);
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort) {
		var changeMonth = this._get(inst, &#x27;changeMonth&#x27;);
		var changeYear = this._get(inst, &#x27;changeYear&#x27;);
		var showMonthAfterYear = this._get(inst, &#x27;showMonthAfterYear&#x27;);
		var html = &#x27;&lt;div class=&quot;ui-datepicker-title&quot;&gt;&#x27;;
		var monthHtml = &#x27;&#x27;;
		// month selection
		if (secondary || !changeMonth)
			monthHtml += &#x27;&lt;span class=&quot;ui-datepicker-month&quot;&gt;&#x27; + monthNames[drawMonth] + &#x27;&lt;/span&gt;&#x27;;
		else {
			var inMinYear = (minDate &amp;&amp; minDate.getFullYear() == drawYear);
			var inMaxYear = (maxDate &amp;&amp; maxDate.getFullYear() == drawYear);
			monthHtml += &#x27;&lt;select class=&quot;ui-datepicker-month&quot; data-handler=&quot;selectMonth&quot; data-event=&quot;change&quot;&gt;&#x27;;
			for (var month = 0; month &lt; 12; month++) {
				if ((!inMinYear || month &gt;= minDate.getMonth()) &amp;&amp;
						(!inMaxYear || month &lt;= maxDate.getMonth()))
					monthHtml += &#x27;&lt;option value=&quot;&#x27; + month + &#x27;&quot;&#x27; +
						(month == drawMonth ? &#x27; selected=&quot;selected&quot;&#x27; : &#x27;&#x27;) +
						&#x27;&gt;&#x27; + monthNamesShort[month] + &#x27;&lt;/option&gt;&#x27;;
			}
			monthHtml += &#x27;&lt;/select&gt;&#x27;;
		}
		if (!showMonthAfterYear)
			html += monthHtml + (secondary || !(changeMonth &amp;&amp; changeYear) ? &#x27;&amp;#xa0;&#x27; : &#x27;&#x27;);
		// year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = &#x27;&#x27;;
			if (secondary || !changeYear)
				html += &#x27;&lt;span class=&quot;ui-datepicker-year&quot;&gt;&#x27; + drawYear + &#x27;&lt;/span&gt;&#x27;;
			else {
				// determine range of years to display
				var years = this._get(inst, &#x27;yearRange&#x27;).split(&#x27;:&#x27;);
				var thisYear = new Date().getFullYear();
				var determineYear = function(value) {
					var year = (value.match(/c[+-].*/) ? drawYear + parseInt(value.substring(1), 10) :
						(value.match(/[+-].*/) ? thisYear + parseInt(value, 10) :
						parseInt(value, 10)));
					return (isNaN(year) ? thisYear : year);
				};
				var year = determineYear(years[0]);
				var endYear = Math.max(year, determineYear(years[1] || &#x27;&#x27;));
				year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
				endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
				inst.yearshtml += &#x27;&lt;select class=&quot;ui-datepicker-year&quot; data-handler=&quot;selectYear&quot; data-event=&quot;change&quot;&gt;&#x27;;
				for (; year &lt;= endYear; year++) {
					inst.yearshtml += &#x27;&lt;option value=&quot;&#x27; + year + &#x27;&quot;&#x27; +
						(year == drawYear ? &#x27; selected=&quot;selected&quot;&#x27; : &#x27;&#x27;) +
						&#x27;&gt;&#x27; + year + &#x27;&lt;/option&gt;&#x27;;
				}
				inst.yearshtml += &#x27;&lt;/select&gt;&#x27;;

				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}
		html += this._get(inst, &#x27;yearSuffix&#x27;);
		if (showMonthAfterYear)
			html += (secondary || !(changeMonth &amp;&amp; changeYear) ? &#x27;&amp;#xa0;&#x27; : &#x27;&#x27;) + monthHtml;
		html += &#x27;&lt;/div&gt;&#x27;; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function(inst, offset, period) {
		var year = inst.drawYear + (period == &#x27;Y&#x27; ? offset : 0);
		var month = inst.drawMonth + (period == &#x27;M&#x27; ? offset : 0);
		var day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) +
			(period == &#x27;D&#x27; ? offset : 0);
		var date = this._restrictMinMax(inst,
			this._daylightSavingAdjust(new Date(year, month, day)));
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if (period == &#x27;M&#x27; || period == &#x27;Y&#x27;)
			this._notifyChange(inst);
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, &#x27;min&#x27;);
		var maxDate = this._getMinMaxDate(inst, &#x27;max&#x27;);
		var newDate = (minDate &amp;&amp; date &lt; minDate ? minDate : date);
		newDate = (maxDate &amp;&amp; newDate &gt; maxDate ? maxDate : newDate);
		return newDate;
	},

	/* Notify change of month/year. */
	_notifyChange: function(inst) {
		var onChange = this._get(inst, &#x27;onChangeMonthYear&#x27;);
		if (onChange)
			onChange.apply((inst.input ? inst.input[0] : null),
				[inst.selectedYear, inst.selectedMonth + 1, inst]);
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function(inst) {
		var numMonths = this._get(inst, &#x27;numberOfMonths&#x27;);
		return (numMonths == null ? [1, 1] : (typeof numMonths == &#x27;number&#x27; ? [1, numMonths] : numMonths));
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function(inst, minMax) {
		return this._determineDate(inst, this._get(inst, minMax + &#x27;Date&#x27;), null);
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function(year, month) {
		return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function(year, month) {
		return new Date(year, month, 1).getDay();
	},

	/* Determines if we should allow a &quot;next/prev&quot; month display change. */
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
		var numMonths = this._getNumberOfMonths(inst);
		var date = this._daylightSavingAdjust(new Date(curYear,
			curMonth + (offset &lt; 0 ? offset : numMonths[0] * numMonths[1]), 1));
		if (offset &lt; 0)
			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
		return this._isInRange(inst, date);
	},

	/* Is the given date in the accepted range? */
	_isInRange: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, &#x27;min&#x27;);
		var maxDate = this._getMinMaxDate(inst, &#x27;max&#x27;);
		return ((!minDate || date.getTime() &gt;= minDate.getTime()) &amp;&amp;
			(!maxDate || date.getTime() &lt;= maxDate.getTime()));
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function(inst) {
		var shortYearCutoff = this._get(inst, &#x27;shortYearCutoff&#x27;);
		shortYearCutoff = (typeof shortYearCutoff != &#x27;string&#x27; ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		return {shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get(inst, &#x27;dayNamesShort&#x27;), dayNames: this._get(inst, &#x27;dayNames&#x27;),
			monthNamesShort: this._get(inst, &#x27;monthNamesShort&#x27;), monthNames: this._get(inst, &#x27;monthNames&#x27;)};
	},

	/* Format the given date for display. */
	_formatDate: function(inst, day, month, year) {
		if (!day) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = (day ? (typeof day == &#x27;object&#x27; ? day :
			this._daylightSavingAdjust(new Date(year, month, day))) :
			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		return this.formatDate(this._get(inst, &#x27;dateFormat&#x27;), date, this._getFormatConfig(inst));
	}
});

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function bindHover(dpDiv) {
	var selector = &#x27;button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a&#x27;;
	return dpDiv.delegate(selector, &#x27;mouseout&#x27;, function() {
			$(this).removeClass(&#x27;ui-state-hover&#x27;);
			if (this.className.indexOf(&#x27;ui-datepicker-prev&#x27;) != -1) $(this).removeClass(&#x27;ui-datepicker-prev-hover&#x27;);
			if (this.className.indexOf(&#x27;ui-datepicker-next&#x27;) != -1) $(this).removeClass(&#x27;ui-datepicker-next-hover&#x27;);
		})
		.delegate(selector, &#x27;mouseover&#x27;, function(){
			if (!$.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
				$(this).parents(&#x27;.ui-datepicker-calendar&#x27;).find(&#x27;a&#x27;).removeClass(&#x27;ui-state-hover&#x27;);
				$(this).addClass(&#x27;ui-state-hover&#x27;);
				if (this.className.indexOf(&#x27;ui-datepicker-prev&#x27;) != -1) $(this).addClass(&#x27;ui-datepicker-prev-hover&#x27;);
				if (this.className.indexOf(&#x27;ui-datepicker-next&#x27;) != -1) $(this).addClass(&#x27;ui-datepicker-next-hover&#x27;);
			}
		});
}

/* jQuery extend now ignores nulls! */
function extendRemove(target, props) {
	$.extend(target, props);
	for (var name in props)
		if (props[name] == null || props[name] == undefined)
			target[name] = props[name];
	return target;
};

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
	                Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function(options){

	/* Verify an empty collection wasn&#x27;t passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}

	/* Initialise the date picker. */
	if (!$.datepicker.initialized) {
		$(document).mousedown($.datepicker._checkExternalClick).
			find(document.body).append($.datepicker.dpDiv);
		$.datepicker.initialized = true;
	}

	var otherArgs = Array.prototype.slice.call(arguments, 1);
	if (typeof options == &#x27;string&#x27; &amp;&amp; (options == &#x27;isDisabled&#x27; || options == &#x27;getDate&#x27; || options == &#x27;widget&#x27;))
		return $.datepicker[&#x27;_&#x27; + options + &#x27;Datepicker&#x27;].
			apply($.datepicker, [this[0]].concat(otherArgs));
	if (options == &#x27;option&#x27; &amp;&amp; arguments.length == 2 &amp;&amp; typeof arguments[1] == &#x27;string&#x27;)
		return $.datepicker[&#x27;_&#x27; + options + &#x27;Datepicker&#x27;].
			apply($.datepicker, [this[0]].concat(otherArgs));
	return this.each(function() {
		typeof options == &#x27;string&#x27; ?
			$.datepicker[&#x27;_&#x27; + options + &#x27;Datepicker&#x27;].
				apply($.datepicker, [this].concat(otherArgs)) :
			$.datepicker._attachDatepicker(this, options);
	});
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = &quot;1.9.1&quot;;

// Workaround for #4055
// Add another global to avoid noConflict issues with inline event handlers
window[&#x27;DP_jQuery_&#x27; + dpuuid] = $;

})(jQuery);

(function( $, undefined ) {

var uiDialogClasses = &quot;ui-dialog ui-widget ui-widget-content ui-corner-all &quot;,
	sizeRelatedOptions = {
		buttons: true,
		height: true,
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true,
		width: true
	},
	resizableRelatedOptions = {
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true
	};

$.widget(&quot;ui.dialog&quot;, {
	version: &quot;1.9.1&quot;,
	options: {
		autoOpen: true,
		buttons: {},
		closeOnEscape: true,
		closeText: &quot;close&quot;,
		dialogClass: &quot;&quot;,
		draggable: true,
		hide: null,
		height: &quot;auto&quot;,
		maxHeight: false,
		maxWidth: false,
		minHeight: 150,
		minWidth: 150,
		modal: false,
		position: {
			my: &quot;center&quot;,
			at: &quot;center&quot;,
			of: window,
			collision: &quot;fit&quot;,
			// ensure that the titlebar is never outside the document
			using: function( pos ) {
				var topOffset = $( this ).css( pos ).offset().top;
				if ( topOffset &lt; 0 ) {
					$( this ).css( &quot;top&quot;, pos.top - topOffset );
				}
			}
		},
		resizable: true,
		show: null,
		stack: true,
		title: &quot;&quot;,
		width: 300,
		zIndex: 1000
	},

	_create: function() {
		this.originalTitle = this.element.attr( &quot;title&quot; );
		// #5742 - .attr() might return a DOMElement
		if ( typeof this.originalTitle !== &quot;string&quot; ) {
			this.originalTitle = &quot;&quot;;
		}
		this.oldPosition = {
			parent: this.element.parent(),
			index: this.element.parent().children().index( this.element )
		};
		this.options.title = this.options.title || this.originalTitle;
		var that = this,
			options = this.options,

			title = options.title || &quot;&amp;#160;&quot;,
			uiDialog,
			uiDialogTitlebar,
			uiDialogTitlebarClose,
			uiDialogTitle,
			uiDialogButtonPane;

			uiDialog = ( this.uiDialog = $( &quot;&lt;div&gt;&quot; ) )
				.addClass( uiDialogClasses + options.dialogClass )
				.css({
					display: &quot;none&quot;,
					outline: 0, // TODO: move to stylesheet
					zIndex: options.zIndex
				})
				// setting tabIndex makes the div focusable
				.attr( &quot;tabIndex&quot;, -1)
				.keydown(function( event ) {
					if ( options.closeOnEscape &amp;&amp; !event.isDefaultPrevented() &amp;&amp; event.keyCode &amp;&amp;
							event.keyCode === $.ui.keyCode.ESCAPE ) {
						that.close( event );
						event.preventDefault();
					}
				})
				.mousedown(function( event ) {
					that.moveToTop( false, event );
				})
				.appendTo( &quot;body&quot; );

			this.element
				.show()
				.removeAttr( &quot;title&quot; )
				.addClass( &quot;ui-dialog-content ui-widget-content&quot; )
				.appendTo( uiDialog );

			uiDialogTitlebar = ( this.uiDialogTitlebar = $( &quot;&lt;div&gt;&quot; ) )
				.addClass( &quot;ui-dialog-titlebar  ui-widget-header  &quot; +
					&quot;ui-corner-all  ui-helper-clearfix&quot; )
				.bind( &quot;mousedown&quot;, function() {
					// Dialog isn&#x27;t getting focus when dragging (#8063)
					uiDialog.focus();
				})
				.prependTo( uiDialog );

			uiDialogTitlebarClose = $( &quot;&lt;a href=&#x27;#&#x27;&gt;&lt;/a&gt;&quot; )
				.addClass( &quot;ui-dialog-titlebar-close  ui-corner-all&quot; )
				.attr( &quot;role&quot;, &quot;button&quot; )
				.click(function( event ) {
					event.preventDefault();
					that.close( event );
				})
				.appendTo( uiDialogTitlebar );

			( this.uiDialogTitlebarCloseText = $( &quot;&lt;span&gt;&quot; ) )
				.addClass( &quot;ui-icon ui-icon-closethick&quot; )
				.text( options.closeText )
				.appendTo( uiDialogTitlebarClose );

			uiDialogTitle = $( &quot;&lt;span&gt;&quot; )
				.uniqueId()
				.addClass( &quot;ui-dialog-title&quot; )
				.html( title )
				.prependTo( uiDialogTitlebar );

			uiDialogButtonPane = ( this.uiDialogButtonPane = $( &quot;&lt;div&gt;&quot; ) )
				.addClass( &quot;ui-dialog-buttonpane ui-widget-content ui-helper-clearfix&quot; );

			( this.uiButtonSet = $( &quot;&lt;div&gt;&quot; ) )
				.addClass( &quot;ui-dialog-buttonset&quot; )
				.appendTo( uiDialogButtonPane );

		uiDialog.attr({
			role: &quot;dialog&quot;,
			&quot;aria-labelledby&quot;: uiDialogTitle.attr( &quot;id&quot; )
		});

		uiDialogTitlebar.find( &quot;*&quot; ).add( uiDialogTitlebar ).disableSelection();
		this._hoverable( uiDialogTitlebarClose );
		this._focusable( uiDialogTitlebarClose );

		if ( options.draggable &amp;&amp; $.fn.draggable ) {
			this._makeDraggable();
		}
		if ( options.resizable &amp;&amp; $.fn.resizable ) {
			this._makeResizable();
		}

		this._createButtons( options.buttons );
		this._isOpen = false;

		if ( $.fn.bgiframe ) {
			uiDialog.bgiframe();
		}

		// prevent tabbing out of modal dialogs
		this._on( uiDialog, { keydown: function( event ) {
			if ( !options.modal || event.keyCode !== $.ui.keyCode.TAB ) {
				return;
			}

			var tabbables = $( &quot;:tabbable&quot;, uiDialog ),
				first = tabbables.filter( &quot;:first&quot; ),
				last  = tabbables.filter( &quot;:last&quot; );

			if ( event.target === last[0] &amp;&amp; !event.shiftKey ) {
				first.focus( 1 );
				return false;
			} else if ( event.target === first[0] &amp;&amp; event.shiftKey ) {
				last.focus( 1 );
				return false;
			}
		}});
	},

	_init: function() {
		if ( this.options.autoOpen ) {
			this.open();
		}
	},

	_destroy: function() {
		var next,
			oldPosition = this.oldPosition;

		if ( this.overlay ) {
			this.overlay.destroy();
		}
		this.uiDialog.hide();
		this.element
			.removeClass( &quot;ui-dialog-content ui-widget-content&quot; )
			.hide()
			.appendTo( &quot;body&quot; );
		this.uiDialog.remove();

		if ( this.originalTitle ) {
			this.element.attr( &quot;title&quot;, this.originalTitle );
		}

		next = oldPosition.parent.children().eq( oldPosition.index );
		// Don&#x27;t try to place the dialog next to itself (#8613)
		if ( next.length &amp;&amp; next[ 0 ] !== this.element[ 0 ] ) {
			next.before( this.element );
		} else {
			oldPosition.parent.append( this.element );
		}
	},

	widget: function() {
		return this.uiDialog;
	},

	close: function( event ) {
		var that = this,
			maxZ, thisZ;

		if ( !this._isOpen ) {
			return;
		}

		if ( false === this._trigger( &quot;beforeClose&quot;, event ) ) {
			return;
		}

		this._isOpen = false;

		if ( this.overlay ) {
			this.overlay.destroy();
		}

		if ( this.options.hide ) {
			this._hide( this.uiDialog, this.options.hide, function() {
				that._trigger( &quot;close&quot;, event );
			});
		} else {
			this.uiDialog.hide();
			this._trigger( &quot;close&quot;, event );
		}

		$.ui.dialog.overlay.resize();

		// adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
		if ( this.options.modal ) {
			maxZ = 0;
			$( &quot;.ui-dialog&quot; ).each(function() {
				if ( this !== that.uiDialog[0] ) {
					thisZ = $( this ).css( &quot;z-index&quot; );
					if ( !isNaN( thisZ ) ) {
						maxZ = Math.max( maxZ, thisZ );
					}
				}
			});
			$.ui.dialog.maxZ = maxZ;
		}

		return this;
	},

	isOpen: function() {
		return this._isOpen;
	},

	// the force parameter allows us to move modal dialogs to their correct
	// position on open
	moveToTop: function( force, event ) {
		var options = this.options,
			saveScroll;

		if ( ( options.modal &amp;&amp; !force ) ||
				( !options.stack &amp;&amp; !options.modal ) ) {
			return this._trigger( &quot;focus&quot;, event );
		}

		if ( options.zIndex &gt; $.ui.dialog.maxZ ) {
			$.ui.dialog.maxZ = options.zIndex;
		}
		if ( this.overlay ) {
			$.ui.dialog.maxZ += 1;
			$.ui.dialog.overlay.maxZ = $.ui.dialog.maxZ;
			this.overlay.$el.css( &quot;z-index&quot;, $.ui.dialog.overlay.maxZ );
		}

		// Save and then restore scroll
		// Opera 9.5+ resets when parent z-index is changed.
		// http://bugs.jqueryui.com/ticket/3193
		saveScroll = {
			scrollTop: this.element.scrollTop(),
			scrollLeft: this.element.scrollLeft()
		};
		$.ui.dialog.maxZ += 1;
		this.uiDialog.css( &quot;z-index&quot;, $.ui.dialog.maxZ );
		this.element.attr( saveScroll );
		this._trigger( &quot;focus&quot;, event );

		return this;
	},

	open: function() {
		if ( this._isOpen ) {
			return;
		}

		var hasFocus,
			options = this.options,
			uiDialog = this.uiDialog;

		this._size();
		this._position( options.position );
		uiDialog.show( options.show );
		this.overlay = options.modal ? new $.ui.dialog.overlay( this ) : null;
		this.moveToTop( true );

		// set focus to the first tabbable element in the content area or the first button
		// if there are no tabbable elements, set focus on the dialog itself
		hasFocus = this.element.find( &quot;:tabbable&quot; );
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialogButtonPane.find( &quot;:tabbable&quot; );
			if ( !hasFocus.length ) {
				hasFocus = uiDialog;
			}
		}
		hasFocus.eq( 0 ).focus();

		this._isOpen = true;
		this._trigger( &quot;open&quot; );

		return this;
	},

	_createButtons: function( buttons ) {
		var that = this,
			hasButtons = false;

		// if we already have a button pane, remove it
		this.uiDialogButtonPane.remove();
		this.uiButtonSet.empty();

		if ( typeof buttons === &quot;object&quot; &amp;&amp; buttons !== null ) {
			$.each( buttons, function() {
				return !(hasButtons = true);
			});
		}
		if ( hasButtons ) {
			$.each( buttons, function( name, props ) {
				props = $.isFunction( props ) ?
					{ click: props, text: name } :
					props;
				var button = $( &quot;&lt;button type=&#x27;button&#x27;&gt;&lt;/button&gt;&quot; )
					.attr( props, true )
					.unbind( &quot;click&quot; )
					.click(function() {
						props.click.apply( that.element[0], arguments );
					})
					.appendTo( that.uiButtonSet );
				if ( $.fn.button ) {
					button.button();
				}
			});
			this.uiDialog.addClass( &quot;ui-dialog-buttons&quot; );
			this.uiDialogButtonPane.appendTo( this.uiDialog );
		} else {
			this.uiDialog.removeClass( &quot;ui-dialog-buttons&quot; );
		}
	},

	_makeDraggable: function() {
		var that = this,
			options = this.options;

		function filteredUi( ui ) {
			return {
				position: ui.position,
				offset: ui.offset
			};
		}

		this.uiDialog.draggable({
			cancel: &quot;.ui-dialog-content, .ui-dialog-titlebar-close&quot;,
			handle: &quot;.ui-dialog-titlebar&quot;,
			containment: &quot;document&quot;,
			start: function( event, ui ) {
				$( this )
					.addClass( &quot;ui-dialog-dragging&quot; );
				that._trigger( &quot;dragStart&quot;, event, filteredUi( ui ) );
			},
			drag: function( event, ui ) {
				that._trigger( &quot;drag&quot;, event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				options.position = [
					ui.position.left - that.document.scrollLeft(),
					ui.position.top - that.document.scrollTop()
				];
				$( this )
					.removeClass( &quot;ui-dialog-dragging&quot; );
				that._trigger( &quot;dragStop&quot;, event, filteredUi( ui ) );
				$.ui.dialog.overlay.resize();
			}
		});
	},

	_makeResizable: function( handles ) {
		handles = (handles === undefined ? this.options.resizable : handles);
		var that = this,
			options = this.options,
			// .ui-resizable has position: relative defined in the stylesheet
			// but dialogs have to use absolute or fixed positioning
			position = this.uiDialog.css( &quot;position&quot; ),
			resizeHandles = typeof handles === &#x27;string&#x27; ?
				handles	:
				&quot;n,e,s,w,se,sw,ne,nw&quot;;

		function filteredUi( ui ) {
			return {
				originalPosition: ui.originalPosition,
				originalSize: ui.originalSize,
				position: ui.position,
				size: ui.size
			};
		}

		this.uiDialog.resizable({
			cancel: &quot;.ui-dialog-content&quot;,
			containment: &quot;document&quot;,
			alsoResize: this.element,
			maxWidth: options.maxWidth,
			maxHeight: options.maxHeight,
			minWidth: options.minWidth,
			minHeight: this._minHeight(),
			handles: resizeHandles,
			start: function( event, ui ) {
				$( this ).addClass( &quot;ui-dialog-resizing&quot; );
				that._trigger( &quot;resizeStart&quot;, event, filteredUi( ui ) );
			},
			resize: function( event, ui ) {
				that._trigger( &quot;resize&quot;, event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				$( this ).removeClass( &quot;ui-dialog-resizing&quot; );
				options.height = $( this ).height();
				options.width = $( this ).width();
				that._trigger( &quot;resizeStop&quot;, event, filteredUi( ui ) );
				$.ui.dialog.overlay.resize();
			}
		})
		.css( &quot;position&quot;, position )
		.find( &quot;.ui-resizable-se&quot; )
			.addClass( &quot;ui-icon ui-icon-grip-diagonal-se&quot; );
	},

	_minHeight: function() {
		var options = this.options;

		if ( options.height === &quot;auto&quot; ) {
			return options.minHeight;
		} else {
			return Math.min( options.minHeight, options.height );
		}
	},

	_position: function( position ) {
		var myAt = [],
			offset = [ 0, 0 ],
			isVisible;

		if ( position ) {
			// deep extending converts arrays to objects in jQuery &lt;= 1.3.2 :-(
	//		if (typeof position == &#x27;string&#x27; || $.isArray(position)) {
	//			myAt = $.isArray(position) ? position : position.split(&#x27; &#x27;);

			if ( typeof position === &quot;string&quot; || (typeof position === &quot;object&quot; &amp;&amp; &quot;0&quot; in position ) ) {
				myAt = position.split ? position.split( &quot; &quot; ) : [ position[ 0 ], position[ 1 ] ];
				if ( myAt.length === 1 ) {
					myAt[ 1 ] = myAt[ 0 ];
				}

				$.each( [ &quot;left&quot;, &quot;top&quot; ], function( i, offsetPosition ) {
					if ( +myAt[ i ] === myAt[ i ] ) {
						offset[ i ] = myAt[ i ];
						myAt[ i ] = offsetPosition;
					}
				});

				position = {
					my: myAt[0] + (offset[0] &lt; 0 ? offset[0] : &quot;+&quot; + offset[0]) + &quot; &quot; +
						myAt[1] + (offset[1] &lt; 0 ? offset[1] : &quot;+&quot; + offset[1]),
					at: myAt.join( &quot; &quot; )
				};
			}

			position = $.extend( {}, $.ui.dialog.prototype.options.position, position );
		} else {
			position = $.ui.dialog.prototype.options.position;
		}

		// need to show the dialog to get the actual offset in the position plugin
		isVisible = this.uiDialog.is( &quot;:visible&quot; );
		if ( !isVisible ) {
			this.uiDialog.show();
		}
		this.uiDialog.position( position );
		if ( !isVisible ) {
			this.uiDialog.hide();
		}
	},

	_setOptions: function( options ) {
		var that = this,
			resizableOptions = {},
			resize = false;

		$.each( options, function( key, value ) {
			that._setOption( key, value );

			if ( key in sizeRelatedOptions ) {
				resize = true;
			}
			if ( key in resizableRelatedOptions ) {
				resizableOptions[ key ] = value;
			}
		});

		if ( resize ) {
			this._size();
		}
		if ( this.uiDialog.is( &quot;:data(resizable)&quot; ) ) {
			this.uiDialog.resizable( &quot;option&quot;, resizableOptions );
		}
	},

	_setOption: function( key, value ) {
		var isDraggable, isResizable,
			uiDialog = this.uiDialog;

		switch ( key ) {
			case &quot;buttons&quot;:
				this._createButtons( value );
				break;
			case &quot;closeText&quot;:
				// ensure that we always pass a string
				this.uiDialogTitlebarCloseText.text( &quot;&quot; + value );
				break;
			case &quot;dialogClass&quot;:
				uiDialog
					.removeClass( this.options.dialogClass )
					.addClass( uiDialogClasses + value );
				break;
			case &quot;disabled&quot;:
				if ( value ) {
					uiDialog.addClass( &quot;ui-dialog-disabled&quot; );
				} else {
					uiDialog.removeClass( &quot;ui-dialog-disabled&quot; );
				}
				break;
			case &quot;draggable&quot;:
				isDraggable = uiDialog.is( &quot;:data(draggable)&quot; );
				if ( isDraggable &amp;&amp; !value ) {
					uiDialog.draggable( &quot;destroy&quot; );
				}

				if ( !isDraggable &amp;&amp; value ) {
					this._makeDraggable();
				}
				break;
			case &quot;position&quot;:
				this._position( value );
				break;
			case &quot;resizable&quot;:
				// currently resizable, becoming non-resizable
				isResizable = uiDialog.is( &quot;:data(resizable)&quot; );
				if ( isResizable &amp;&amp; !value ) {
					uiDialog.resizable( &quot;destroy&quot; );
				}

				// currently resizable, changing handles
				if ( isResizable &amp;&amp; typeof value === &quot;string&quot; ) {
					uiDialog.resizable( &quot;option&quot;, &quot;handles&quot;, value );
				}

				// currently non-resizable, becoming resizable
				if ( !isResizable &amp;&amp; value !== false ) {
					this._makeResizable( value );
				}
				break;
			case &quot;title&quot;:
				// convert whatever was passed in o a string, for html() to not throw up
				$( &quot;.ui-dialog-title&quot;, this.uiDialogTitlebar )
					.html( &quot;&quot; + ( value || &quot;&amp;#160;&quot; ) );
				break;
		}

		this._super( key, value );
	},

	_size: function() {
		/* If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
		 * divs will both have width and height set, so we need to reset them
		 */
		var nonContentHeight, minContentHeight, autoHeight,
			options = this.options,
			isVisible = this.uiDialog.is( &quot;:visible&quot; );

		// reset content sizing
		this.element.show().css({
			width: &quot;auto&quot;,
			minHeight: 0,
			height: 0
		});

		if ( options.minWidth &gt; options.width ) {
			options.width = options.minWidth;
		}

		// reset wrapper sizing
		// determine the height of all the non-content elements
		nonContentHeight = this.uiDialog.css({
				height: &quot;auto&quot;,
				width: options.width
			})
			.outerHeight();
		minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );

		if ( options.height === &quot;auto&quot; ) {
			// only needed for IE6 support
			if ( $.support.minHeight ) {
				this.element.css({
					minHeight: minContentHeight,
					height: &quot;auto&quot;
				});
			} else {
				this.uiDialog.show();
				autoHeight = this.element.css( &quot;height&quot;, &quot;auto&quot; ).height();
				if ( !isVisible ) {
					this.uiDialog.hide();
				}
				this.element.height( Math.max( autoHeight, minContentHeight ) );
			}
		} else {
			this.element.height( Math.max( options.height - nonContentHeight, 0 ) );
		}

		if (this.uiDialog.is( &quot;:data(resizable)&quot; ) ) {
			this.uiDialog.resizable( &quot;option&quot;, &quot;minHeight&quot;, this._minHeight() );
		}
	}
});

$.extend($.ui.dialog, {
	uuid: 0,
	maxZ: 0,

	getTitleId: function($el) {
		var id = $el.attr( &quot;id&quot; );
		if ( !id ) {
			this.uuid += 1;
			id = this.uuid;
		}
		return &quot;ui-dialog-title-&quot; + id;
	},

	overlay: function( dialog ) {
		this.$el = $.ui.dialog.overlay.create( dialog );
	}
});

$.extend( $.ui.dialog.overlay, {
	instances: [],
	// reuse old instances due to IE memory leak with alpha transparency (see #5185)
	oldInstances: [],
	maxZ: 0,
	events: $.map(
		&quot;focus,mousedown,mouseup,keydown,keypress,click&quot;.split( &quot;,&quot; ),
		function( event ) {
			return event + &quot;.dialog-overlay&quot;;
		}
	).join( &quot; &quot; ),
	create: function( dialog ) {
		if ( this.instances.length === 0 ) {
			// prevent use of anchors and inputs
			// we use a setTimeout in case the overlay is created from an
			// event that we&#x27;re going to be cancelling (see #2804)
			setTimeout(function() {
				// handle $(el).dialog().dialog(&#x27;close&#x27;) (see #4065)
				if ( $.ui.dialog.overlay.instances.length ) {
					$( document ).bind( $.ui.dialog.overlay.events, function( event ) {
						// stop events if the z-index of the target is &lt; the z-index of the overlay
						// we cannot return true when we don&#x27;t want to cancel the event (#3523)
						if ( $( event.target ).zIndex() &lt; $.ui.dialog.overlay.maxZ ) {
							return false;
						}
					});
				}
			}, 1 );

			// handle window resize
			$( window ).bind( &quot;resize.dialog-overlay&quot;, $.ui.dialog.overlay.resize );
		}

		var $el = ( this.oldInstances.pop() || $( &quot;&lt;div&gt;&quot; ).addClass( &quot;ui-widget-overlay&quot; ) );

		// allow closing by pressing the escape key
		$( document ).bind( &quot;keydown.dialog-overlay&quot;, function( event ) {
			var instances = $.ui.dialog.overlay.instances;
			// only react to the event if we&#x27;re the top overlay
			if ( instances.length !== 0 &amp;&amp; instances[ instances.length - 1 ] === $el &amp;&amp;
				dialog.options.closeOnEscape &amp;&amp; !event.isDefaultPrevented() &amp;&amp; event.keyCode &amp;&amp;
				event.keyCode === $.ui.keyCode.ESCAPE ) {

				dialog.close( event );
				event.preventDefault();
			}
		});

		$el.appendTo( document.body ).css({
			width: this.width(),
			height: this.height()
		});

		if ( $.fn.bgiframe ) {
			$el.bgiframe();
		}

		this.instances.push( $el );
		return $el;
	},

	destroy: function( $el ) {
		var indexOf = $.inArray( $el, this.instances ),
			maxZ = 0;

		if ( indexOf !== -1 ) {
			this.oldInstances.push( this.instances.splice( indexOf, 1 )[ 0 ] );
		}

		if ( this.instances.length === 0 ) {
			$( [ document, window ] ).unbind( &quot;.dialog-overlay&quot; );
		}

		$el.height( 0 ).width( 0 ).remove();

		// adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
		$.each( this.instances, function() {
			maxZ = Math.max( maxZ, this.css( &quot;z-index&quot; ) );
		});
		this.maxZ = maxZ;
	},

	height: function() {
		var scrollHeight,
			offsetHeight;
		// handle IE
		if ( $.ui.ie ) {
			scrollHeight = Math.max(
				document.documentElement.scrollHeight,
				document.body.scrollHeight
			);
			offsetHeight = Math.max(
				document.documentElement.offsetHeight,
				document.body.offsetHeight
			);

			if ( scrollHeight &lt; offsetHeight ) {
				return $( window ).height() + &quot;px&quot;;
			} else {
				return scrollHeight + &quot;px&quot;;
			}
		// handle &quot;good&quot; browsers
		} else {
			return $( document ).height() + &quot;px&quot;;
		}
	},

	width: function() {
		var scrollWidth,
			offsetWidth;
		// handle IE
		if ( $.ui.ie ) {
			scrollWidth = Math.max(
				document.documentElement.scrollWidth,
				document.body.scrollWidth
			);
			offsetWidth = Math.max(
				document.documentElement.offsetWidth,
				document.body.offsetWidth
			);

			if ( scrollWidth &lt; offsetWidth ) {
				return $( window ).width() + &quot;px&quot;;
			} else {
				return scrollWidth + &quot;px&quot;;
			}
		// handle &quot;good&quot; browsers
		} else {
			return $( document ).width() + &quot;px&quot;;
		}
	},

	resize: function() {
		/* If the dialog is draggable and the user drags it past the
		 * right edge of the window, the document becomes wider so we
		 * need to stretch the overlay. If the user then drags the
		 * dialog back to the left, the document will become narrower,
		 * so we need to shrink the overlay to the appropriate size.
		 * This is handled by shrinking the overlay before setting it
		 * to the full document size.
		 */
		var $overlays = $( [] );
		$.each( $.ui.dialog.overlay.instances, function() {
			$overlays = $overlays.add( this );
		});

		$overlays.css({
			width: 0,
			height: 0
		}).css({
			width: $.ui.dialog.overlay.width(),
			height: $.ui.dialog.overlay.height()
		});
	}
});

$.extend( $.ui.dialog.overlay.prototype, {
	destroy: function() {
		$.ui.dialog.overlay.destroy( this.$el );
	}
});

}( jQuery ) );

(function( $, undefined ) {

var rvertical = /up|down|vertical/,
	rpositivemotion = /up|left|vertical|horizontal/;

$.effects.effect.blind = function( o, done ) {
	// Create element
	var el = $( this ),
		props = [ &quot;position&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;height&quot;, &quot;width&quot; ],
		mode = $.effects.setMode( el, o.mode || &quot;hide&quot; ),
		direction = o.direction || &quot;up&quot;,
		vertical = rvertical.test( direction ),
		ref = vertical ? &quot;height&quot; : &quot;width&quot;,
		ref2 = vertical ? &quot;top&quot; : &quot;left&quot;,
		motion = rpositivemotion.test( direction ),
		animation = {},
		show = mode === &quot;show&quot;,
		wrapper, distance, margin;

	// if already wrapped, the wrapper&#x27;s properties are my property. #6245
	if ( el.parent().is( &quot;.ui-effects-wrapper&quot; ) ) {
		$.effects.save( el.parent(), props );
	} else {
		$.effects.save( el, props );
	}
	el.show();
	wrapper = $.effects.createWrapper( el ).css({
		overflow: &quot;hidden&quot;
	});

	distance = wrapper[ ref ]();
	margin = parseFloat( wrapper.css( ref2 ) ) || 0;

	animation[ ref ] = show ? distance : 0;
	if ( !motion ) {
		el
			.css( vertical ? &quot;bottom&quot; : &quot;right&quot;, 0 )
			.css( vertical ? &quot;top&quot; : &quot;left&quot;, &quot;auto&quot; )
			.css({ position: &quot;absolute&quot; });

		animation[ ref2 ] = show ? margin : distance + margin;
	}

	// start at 0 if we are showing
	if ( show ) {
		wrapper.css( ref, 0 );
		if ( ! motion ) {
			wrapper.css( ref2, margin + distance );
		}
	}

	// Animate
	wrapper.animate( animation, {
		duration: o.duration,
		easing: o.easing,
		queue: false,
		complete: function() {
			if ( mode === &quot;hide&quot; ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.bounce = function( o, done ) {
	var el = $( this ),
		props = [ &quot;position&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;height&quot;, &quot;width&quot; ],

		// defaults:
		mode = $.effects.setMode( el, o.mode || &quot;effect&quot; ),
		hide = mode === &quot;hide&quot;,
		show = mode === &quot;show&quot;,
		direction = o.direction || &quot;up&quot;,
		distance = o.distance,
		times = o.times || 5,

		// number of internal animations
		anims = times * 2 + ( show || hide ? 1 : 0 ),
		speed = o.duration / anims,
		easing = o.easing,

		// utility:
		ref = ( direction === &quot;up&quot; || direction === &quot;down&quot; ) ? &quot;top&quot; : &quot;left&quot;,
		motion = ( direction === &quot;up&quot; || direction === &quot;left&quot; ),
		i,
		upAnim,
		downAnim,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	// Avoid touching opacity to prevent clearType and PNG issues in IE
	if ( show || hide ) {
		props.push( &quot;opacity&quot; );
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el ); // Create Wrapper

	// default distance for the BIGGEST bounce is the outer Distance / 3
	if ( !distance ) {
		distance = el[ ref === &quot;top&quot; ? &quot;outerHeight&quot; : &quot;outerWidth&quot; ]() / 3;
	}

	if ( show ) {
		downAnim = { opacity: 1 };
		downAnim[ ref ] = 0;

		// if we are showing, force opacity 0 and set the initial position
		// then do the &quot;first&quot; animation
		el.css( &quot;opacity&quot;, 0 )
			.css( ref, motion ? -distance * 2 : distance * 2 )
			.animate( downAnim, speed, easing );
	}

	// start at the smallest distance if we are hiding
	if ( hide ) {
		distance = distance / Math.pow( 2, times - 1 );
	}

	downAnim = {};
	downAnim[ ref ] = 0;
	// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
	for ( i = 0; i &lt; times; i++ ) {
		upAnim = {};
		upAnim[ ref ] = ( motion ? &quot;-=&quot; : &quot;+=&quot; ) + distance;

		el.animate( upAnim, speed, easing )
			.animate( downAnim, speed, easing );

		distance = hide ? distance * 2 : distance / 2;
	}

	// Last Bounce when Hiding
	if ( hide ) {
		upAnim = { opacity: 0 };
		upAnim[ ref ] = ( motion ? &quot;-=&quot; : &quot;+=&quot; ) + distance;

		el.animate( upAnim, speed, easing );
	}

	el.queue(function() {
		if ( hide ) {
			el.hide();
		}
		$.effects.restore( el, props );
		$.effects.removeWrapper( el );
		done();
	});

	// inject all the animations we just queued to be first in line (after &quot;inprogress&quot;)
	if ( queuelen &gt; 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.clip = function( o, done ) {
	// Create element
	var el = $( this ),
		props = [ &quot;position&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;height&quot;, &quot;width&quot; ],
		mode = $.effects.setMode( el, o.mode || &quot;hide&quot; ),
		show = mode === &quot;show&quot;,
		direction = o.direction || &quot;vertical&quot;,
		vert = direction === &quot;vertical&quot;,
		size = vert ? &quot;height&quot; : &quot;width&quot;,
		position = vert ? &quot;top&quot; : &quot;left&quot;,
		animation = {},
		wrapper, animate, distance;

	// Save &amp; Show
	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: &quot;hidden&quot;
	});
	animate = ( el[0].tagName === &quot;IMG&quot; ) ? wrapper : el;
	distance = animate[ size ]();

	// Shift
	if ( show ) {
		animate.css( size, 0 );
		animate.css( position, distance / 2 );
	}

	// Create Animation Object:
	animation[ size ] = show ? distance : 0;
	animation[ position ] = show ? 0 : distance / 2;

	// Animate
	animate.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( !show ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.drop = function( o, done ) {

	var el = $( this ),
		props = [ &quot;position&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;opacity&quot;, &quot;height&quot;, &quot;width&quot; ],
		mode = $.effects.setMode( el, o.mode || &quot;hide&quot; ),
		show = mode === &quot;show&quot;,
		direction = o.direction || &quot;left&quot;,
		ref = ( direction === &quot;up&quot; || direction === &quot;down&quot; ) ? &quot;top&quot; : &quot;left&quot;,
		motion = ( direction === &quot;up&quot; || direction === &quot;left&quot; ) ? &quot;pos&quot; : &quot;neg&quot;,
		animation = {
			opacity: show ? 1 : 0
		},
		distance;

	// Adjust
	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	distance = o.distance || el[ ref === &quot;top&quot; ? &quot;outerHeight&quot;: &quot;outerWidth&quot; ]( true ) / 2;

	if ( show ) {
		el
			.css( &quot;opacity&quot;, 0 )
			.css( ref, motion === &quot;pos&quot; ? -distance : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( motion === &quot;pos&quot; ? &quot;+=&quot; : &quot;-=&quot; ) :
		( motion === &quot;pos&quot; ? &quot;-=&quot; : &quot;+=&quot; ) ) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === &quot;hide&quot; ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.explode = function( o, done ) {

	var rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,
		cells = rows,
		el = $( this ),
		mode = $.effects.setMode( el, o.mode || &quot;hide&quot; ),
		show = mode === &quot;show&quot;,

		// show and then visibility:hidden the element before calculating offset
		offset = el.show().css( &quot;visibility&quot;, &quot;hidden&quot; ).offset(),

		// width and height of a piece
		width = Math.ceil( el.outerWidth() / cells ),
		height = Math.ceil( el.outerHeight() / rows ),
		pieces = [],

		// loop
		i, j, left, top, mx, my;

	// children animate complete:
	function childComplete() {
		pieces.push( this );
		if ( pieces.length === rows * cells ) {
			animComplete();
		}
	}

	// clone the element for each row and cell.
	for( i = 0; i &lt; rows ; i++ ) { // ===&gt;
		top = offset.top + i * height;
		my = i - ( rows - 1 ) / 2 ;

		for( j = 0; j &lt; cells ; j++ ) { // |||
			left = offset.left + j * width;
			mx = j - ( cells - 1 ) / 2 ;

			// Create a clone of the now hidden main element that will be absolute positioned
			// within a wrapper div off the -left and -top equal to size of our pieces
			el
				.clone()
				.appendTo( &quot;body&quot; )
				.wrap( &quot;&lt;div&gt;&lt;/div&gt;&quot; )
				.css({
					position: &quot;absolute&quot;,
					visibility: &quot;visible&quot;,
					left: -j * width,
					top: -i * height
				})

			// select the wrapper - make it overflow: hidden and absolute positioned based on
			// where the original was located +left and +top equal to the size of pieces
				.parent()
				.addClass( &quot;ui-effects-explode&quot; )
				.css({
					position: &quot;absolute&quot;,
					overflow: &quot;hidden&quot;,
					width: width,
					height: height,
					left: left + ( show ? mx * width : 0 ),
					top: top + ( show ? my * height : 0 ),
					opacity: show ? 0 : 1
				}).animate({
					left: left + ( show ? 0 : mx * width ),
					top: top + ( show ? 0 : my * height ),
					opacity: show ? 1 : 0
				}, o.duration || 500, o.easing, childComplete );
		}
	}

	function animComplete() {
		el.css({
			visibility: &quot;visible&quot;
		});
		$( pieces ).remove();
		if ( !show ) {
			el.hide();
		}
		done();
	}
};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.fade = function( o, done ) {
	var el = $( this ),
		mode = $.effects.setMode( el, o.mode || &quot;toggle&quot; );

	el.animate({
		opacity: mode
	}, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: done
	});
};

})( jQuery );

(function( $, undefined ) {

$.effects.effect.fold = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ &quot;position&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;height&quot;, &quot;width&quot; ],
		mode = $.effects.setMode( el, o.mode || &quot;hide&quot; ),
		show = mode === &quot;show&quot;,
		hide = mode === &quot;hide&quot;,
		size = o.size || 15,
		percent = /([0-9]+)%/.exec( size ),
		horizFirst = !!o.horizFirst,
		widthFirst = show !== horizFirst,
		ref = widthFirst ? [ &quot;width&quot;, &quot;height&quot; ] : [ &quot;height&quot;, &quot;width&quot; ],
		duration = o.duration / 2,
		wrapper, distance,
		animation1 = {},
		animation2 = {};

	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: &quot;hidden&quot;
	});
	distance = widthFirst ?
		[ wrapper.width(), wrapper.height() ] :
		[ wrapper.height(), wrapper.width() ];

	if ( percent ) {
		size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
	}
	if ( show ) {
		wrapper.css( horizFirst ? {
			height: 0,
			width: size
		} : {
			height: size,
			width: 0
		});
	}

	// Animation
	animation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;
	animation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;

	// Animate
	wrapper
		.animate( animation1, duration, o.easing )
		.animate( animation2, duration, o.easing, function() {
			if ( hide ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.highlight = function( o, done ) {
	var elem = $( this ),
		props = [ &quot;backgroundImage&quot;, &quot;backgroundColor&quot;, &quot;opacity&quot; ],
		mode = $.effects.setMode( elem, o.mode || &quot;show&quot; ),
		animation = {
			backgroundColor: elem.css( &quot;backgroundColor&quot; )
		};

	if (mode === &quot;hide&quot;) {
		animation.opacity = 0;
	}

	$.effects.save( elem, props );

	elem
		.show()
		.css({
			backgroundImage: &quot;none&quot;,
			backgroundColor: o.color || &quot;#ffff99&quot;
		})
		.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( mode === &quot;hide&quot; ) {
					elem.hide();
				}
				$.effects.restore( elem, props );
				done();
			}
		});
};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.pulsate = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || &quot;show&quot; ),
		show = mode === &quot;show&quot;,
		hide = mode === &quot;hide&quot;,
		showhide = ( show || mode === &quot;hide&quot; ),

		// showing or hiding leaves of the &quot;last&quot; animation
		anims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
		duration = o.duration / anims,
		animateTo = 0,
		queue = elem.queue(),
		queuelen = queue.length,
		i;

	if ( show || !elem.is(&quot;:visible&quot;)) {
		elem.css( &quot;opacity&quot;, 0 ).show();
		animateTo = 1;
	}

	// anims - 1 opacity &quot;toggles&quot;
	for ( i = 1; i &lt; anims; i++ ) {
		elem.animate({
			opacity: animateTo
		}, duration, o.easing );
		animateTo = 1 - animateTo;
	}

	elem.animate({
		opacity: animateTo
	}, duration, o.easing);

	elem.queue(function() {
		if ( hide ) {
			elem.hide();
		}
		done();
	});

	// We just queued up &quot;anims&quot; animations, we need to put them next in the queue
	if ( queuelen &gt; 1 ) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	elem.dequeue();
};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.puff = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || &quot;hide&quot; ),
		hide = mode === &quot;hide&quot;,
		percent = parseInt( o.percent, 10 ) || 150,
		factor = percent / 100,
		original = {
			height: elem.height(),
			width: elem.width()
		};

	$.extend( o, {
		effect: &quot;scale&quot;,
		queue: false,
		fade: true,
		mode: mode,
		complete: done,
		percent: hide ? percent : 100,
		from: hide ?
			original :
			{
				height: original.height * factor,
				width: original.width * factor
			}
	});

	elem.effect( o );
};

$.effects.effect.scale = function( o, done ) {

	// Create element
	var el = $( this ),
		options = $.extend( true, {}, o ),
		mode = $.effects.setMode( el, o.mode || &quot;effect&quot; ),
		percent = parseInt( o.percent, 10 ) ||
			( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === &quot;hide&quot; ? 0 : 100 ) ),
		direction = o.direction || &quot;both&quot;,
		origin = o.origin,
		original = {
			height: el.height(),
			width: el.width(),
			outerHeight: el.outerHeight(),
			outerWidth: el.outerWidth()
		},
		factor = {
			y: direction !== &quot;horizontal&quot; ? (percent / 100) : 1,
			x: direction !== &quot;vertical&quot; ? (percent / 100) : 1
		};

	// We are going to pass this effect to the size effect:
	options.effect = &quot;size&quot;;
	options.queue = false;
	options.complete = done;

	// Set default origin and restore for show/hide
	if ( mode !== &quot;effect&quot; ) {
		options.origin = origin || [&quot;middle&quot;,&quot;center&quot;];
		options.restore = true;
	}

	options.from = o.from || ( mode === &quot;show&quot; ? { height: 0, width: 0 } : original );
	options.to = {
		height: original.height * factor.y,
		width: original.width * factor.x,
		outerHeight: original.outerHeight * factor.y,
		outerWidth: original.outerWidth * factor.x
	};

	// Fade option to support puff
	if ( options.fade ) {
		if ( mode === &quot;show&quot; ) {
			options.from.opacity = 0;
			options.to.opacity = 1;
		}
		if ( mode === &quot;hide&quot; ) {
			options.from.opacity = 1;
			options.to.opacity = 0;
		}
	}

	// Animate
	el.effect( options );

};

$.effects.effect.size = function( o, done ) {

	// Create element
	var original, baseline, factor,
		el = $( this ),
		props0 = [ &quot;position&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;width&quot;, &quot;height&quot;, &quot;overflow&quot;, &quot;opacity&quot; ],

		// Always restore
		props1 = [ &quot;position&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;overflow&quot;, &quot;opacity&quot; ],

		// Copy for children
		props2 = [ &quot;width&quot;, &quot;height&quot;, &quot;overflow&quot; ],
		cProps = [ &quot;fontSize&quot; ],
		vProps = [ &quot;borderTopWidth&quot;, &quot;borderBottomWidth&quot;, &quot;paddingTop&quot;, &quot;paddingBottom&quot; ],
		hProps = [ &quot;borderLeftWidth&quot;, &quot;borderRightWidth&quot;, &quot;paddingLeft&quot;, &quot;paddingRight&quot; ],

		// Set options
		mode = $.effects.setMode( el, o.mode || &quot;effect&quot; ),
		restore = o.restore || mode !== &quot;effect&quot;,
		scale = o.scale || &quot;both&quot;,
		origin = o.origin || [ &quot;middle&quot;, &quot;center&quot; ],
		position = el.css( &quot;position&quot; ),
		props = restore ? props0 : props1,
		zero = {
			height: 0,
			width: 0
		};

	if ( mode === &quot;show&quot; ) {
		el.show();
	}
	original = {
		height: el.height(),
		width: el.width(),
		outerHeight: el.outerHeight(),
		outerWidth: el.outerWidth()
	};

	if ( o.mode === &quot;toggle&quot; &amp;&amp; mode === &quot;show&quot; ) {
		el.from = o.to || zero;
		el.to = o.from || original;
	} else {
		el.from = o.from || ( mode === &quot;show&quot; ? zero : original );
		el.to = o.to || ( mode === &quot;hide&quot; ? zero : original );
	}

	// Set scaling factor
	factor = {
		from: {
			y: el.from.height / original.height,
			x: el.from.width / original.width
		},
		to: {
			y: el.to.height / original.height,
			x: el.to.width / original.width
		}
	};

	// Scale the css box
	if ( scale === &quot;box&quot; || scale === &quot;both&quot; ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( vProps );
			el.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );
		}

		// Horizontal props scaling
		if ( factor.from.x !== factor.to.x ) {
			props = props.concat( hProps );
			el.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );
			el.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );
		}
	}

	// Scale the content
	if ( scale === &quot;content&quot; || scale === &quot;both&quot; ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( cProps ).concat( props2 );
			el.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );
		}
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );
	el.css( &quot;overflow&quot;, &quot;hidden&quot; ).css( el.from );

	// Adjust
	if (origin) { // Calculate baseline shifts
		baseline = $.effects.getBaseline( origin, original );
		el.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;
		el.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;
		el.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;
		el.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;
	}
	el.css( el.from ); // set top &amp; left

	// Animate
	if ( scale === &quot;content&quot; || scale === &quot;both&quot; ) { // Scale the children

		// Add margins/font-size
		vProps = vProps.concat([ &quot;marginTop&quot;, &quot;marginBottom&quot; ]).concat(cProps);
		hProps = hProps.concat([ &quot;marginLeft&quot;, &quot;marginRight&quot; ]);
		props2 = props0.concat(vProps).concat(hProps);

		el.find( &quot;*[width]&quot; ).each( function(){
			var child = $( this ),
				c_original = {
					height: child.height(),
					width: child.width()
				};
			if (restore) {
				$.effects.save(child, props2);
			}

			child.from = {
				height: c_original.height * factor.from.y,
				width: c_original.width * factor.from.x
			};
			child.to = {
				height: c_original.height * factor.to.y,
				width: c_original.width * factor.to.x
			};

			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				child.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );
				child.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );
			}

			// Horizontal props scaling
			if ( factor.from.x !== factor.to.x ) {
				child.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );
				child.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );
			}

			// Animate children
			child.css( child.from );
			child.animate( child.to, o.duration, o.easing, function() {

				// Restore children
				if ( restore ) {
					$.effects.restore( child, props2 );
				}
			});
		});
	}

	// Animate
	el.animate( el.to, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( el.to.opacity === 0 ) {
				el.css( &quot;opacity&quot;, el.from.opacity );
			}
			if( mode === &quot;hide&quot; ) {
				el.hide();
			}
			$.effects.restore( el, props );
			if ( !restore ) {

				// we need to calculate our new positioning based on the scaling
				if ( position === &quot;static&quot; ) {
					el.css({
						position: &quot;relative&quot;,
						top: el.to.top,
						left: el.to.left
					});
				} else {
					$.each([ &quot;top&quot;, &quot;left&quot; ], function( idx, pos ) {
						el.css( pos, function( _, str ) {
							var val = parseInt( str, 10 ),
								toRef = idx ? el.to.left : el.to.top;

							// if original was &quot;auto&quot;, recalculate the new value from wrapper
							if ( str === &quot;auto&quot; ) {
								return toRef + &quot;px&quot;;
							}

							return val + toRef + &quot;px&quot;;
						});
					});
				}
			}

			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.shake = function( o, done ) {

	var el = $( this ),
		props = [ &quot;position&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;height&quot;, &quot;width&quot; ],
		mode = $.effects.setMode( el, o.mode || &quot;effect&quot; ),
		direction = o.direction || &quot;left&quot;,
		distance = o.distance || 20,
		times = o.times || 3,
		anims = times * 2 + 1,
		speed = Math.round(o.duration/anims),
		ref = (direction === &quot;up&quot; || direction === &quot;down&quot;) ? &quot;top&quot; : &quot;left&quot;,
		positiveMotion = (direction === &quot;up&quot; || direction === &quot;left&quot;),
		animation = {},
		animation1 = {},
		animation2 = {},
		i,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	// Animation
	animation[ ref ] = ( positiveMotion ? &quot;-=&quot; : &quot;+=&quot; ) + distance;
	animation1[ ref ] = ( positiveMotion ? &quot;+=&quot; : &quot;-=&quot; ) + distance * 2;
	animation2[ ref ] = ( positiveMotion ? &quot;-=&quot; : &quot;+=&quot; ) + distance * 2;

	// Animate
	el.animate( animation, speed, o.easing );

	// Shakes
	for ( i = 1; i &lt; times; i++ ) {
		el.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );
	}
	el
		.animate( animation1, speed, o.easing )
		.animate( animation, speed / 2, o.easing )
		.queue(function() {
			if ( mode === &quot;hide&quot; ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

	// inject all the animations we just queued to be first in line (after &quot;inprogress&quot;)
	if ( queuelen &gt; 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.slide = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ &quot;position&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;width&quot;, &quot;height&quot; ],
		mode = $.effects.setMode( el, o.mode || &quot;show&quot; ),
		show = mode === &quot;show&quot;,
		direction = o.direction || &quot;left&quot;,
		ref = (direction === &quot;up&quot; || direction === &quot;down&quot;) ? &quot;top&quot; : &quot;left&quot;,
		positiveMotion = (direction === &quot;up&quot; || direction === &quot;left&quot;),
		distance,
		animation = {};

	// Adjust
	$.effects.save( el, props );
	el.show();
	distance = o.distance || el[ ref === &quot;top&quot; ? &quot;outerHeight&quot; : &quot;outerWidth&quot; ]( true );

	$.effects.createWrapper( el ).css({
		overflow: &quot;hidden&quot;
	});

	if ( show ) {
		el.css( ref, positiveMotion ? (isNaN(distance) ? &quot;-&quot; + distance : -distance) : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( positiveMotion ? &quot;+=&quot; : &quot;-=&quot;) :
		( positiveMotion ? &quot;-=&quot; : &quot;+=&quot;)) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === &quot;hide&quot; ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.transfer = function( o, done ) {
	var elem = $( this ),
		target = $( o.to ),
		targetFixed = target.css( &quot;position&quot; ) === &quot;fixed&quot;,
		body = $(&quot;body&quot;),
		fixTop = targetFixed ? body.scrollTop() : 0,
		fixLeft = targetFixed ? body.scrollLeft() : 0,
		endPosition = target.offset(),
		animation = {
			top: endPosition.top - fixTop ,
			left: endPosition.left - fixLeft ,
			height: target.innerHeight(),
			width: target.innerWidth()
		},
		startPosition = elem.offset(),
		transfer = $( &#x27;&lt;div class=&quot;ui-effects-transfer&quot;&gt;&lt;/div&gt;&#x27; )
			.appendTo( document.body )
			.addClass( o.className )
			.css({
				top: startPosition.top - fixTop ,
				left: startPosition.left - fixLeft ,
				height: elem.innerHeight(),
				width: elem.innerWidth(),
				position: targetFixed ? &quot;fixed&quot; : &quot;absolute&quot;
			})
			.animate( animation, o.duration, o.easing, function() {
				transfer.remove();
				done();
			});
};

})(jQuery);

(function( $, undefined ) {

var mouseHandled = false;

$.widget( &quot;ui.menu&quot;, {
	version: &quot;1.9.1&quot;,
	defaultElement: &quot;&lt;ul&gt;&quot;,
	delay: 300,
	options: {
		icons: {
			submenu: &quot;ui-icon-carat-1-e&quot;
		},
		menus: &quot;ul&quot;,
		position: {
			my: &quot;left top&quot;,
			at: &quot;right top&quot;
		},
		role: &quot;menu&quot;,

		// callbacks
		blur: null,
		focus: null,
		select: null
	},

	_create: function() {
		this.activeMenu = this.element;
		this.element
			.uniqueId()
			.addClass( &quot;ui-menu ui-widget ui-widget-content ui-corner-all&quot; )
			.toggleClass( &quot;ui-menu-icons&quot;, !!this.element.find( &quot;.ui-icon&quot; ).length )
			.attr({
				role: this.options.role,
				tabIndex: 0
			})
			// need to catch all clicks on disabled menu
			// not possible through _on
			.bind( &quot;click&quot; + this.eventNamespace, $.proxy(function( event ) {
				if ( this.options.disabled ) {
					event.preventDefault();
				}
			}, this ));

		if ( this.options.disabled ) {
			this.element
				.addClass( &quot;ui-state-disabled&quot; )
				.attr( &quot;aria-disabled&quot;, &quot;true&quot; );
		}

		this._on({
			// Prevent focus from sticking to links inside menu after clicking
			// them (focus should always stay on UL during navigation).
			&quot;mousedown .ui-menu-item &gt; a&quot;: function( event ) {
				event.preventDefault();
			},
			&quot;click .ui-state-disabled &gt; a&quot;: function( event ) {
				event.preventDefault();
			},
			&quot;click .ui-menu-item:has(a)&quot;: function( event ) {
				var target = $( event.target ).closest( &quot;.ui-menu-item&quot; );
				if ( !mouseHandled &amp;&amp; target.not( &quot;.ui-state-disabled&quot; ).length ) {
					mouseHandled = true;

					this.select( event );
					// Open submenu on click
					if ( target.has( &quot;.ui-menu&quot; ).length ) {
						this.expand( event );
					} else if ( !this.element.is( &quot;:focus&quot; ) ) {
						// Redirect focus to the menu
						this.element.trigger( &quot;focus&quot;, [ true ] );

						// If the active item is on the top level, let it stay active.
						// Otherwise, blur the active item since it is no longer visible.
						if ( this.active &amp;&amp; this.active.parents( &quot;.ui-menu&quot; ).length === 1 ) {
							clearTimeout( this.timer );
						}
					}
				}
			},
			&quot;mouseenter .ui-menu-item&quot;: function( event ) {
				var target = $( event.currentTarget );
				// Remove ui-state-active class from siblings of the newly focused menu item
				// to avoid a jump caused by adjacent elements both having a class with a border
				target.siblings().children( &quot;.ui-state-active&quot; ).removeClass( &quot;ui-state-active&quot; );
				this.focus( event, target );
			},
			mouseleave: &quot;collapseAll&quot;,
			&quot;mouseleave .ui-menu&quot;: &quot;collapseAll&quot;,
			focus: function( event, keepActiveItem ) {
				// If there&#x27;s already an active item, keep it active
				// If not, activate the first item
				var item = this.active || this.element.children( &quot;.ui-menu-item&quot; ).eq( 0 );

				if ( !keepActiveItem ) {
					this.focus( event, item );
				}
			},
			blur: function( event ) {
				this._delay(function() {
					if ( !$.contains( this.element[0], this.document[0].activeElement ) ) {
						this.collapseAll( event );
					}
				});
			},
			keydown: &quot;_keydown&quot;
		});

		this.refresh();

		// Clicks outside of a menu collapse any open menus
		this._on( this.document, {
			click: function( event ) {
				if ( !$( event.target ).closest( &quot;.ui-menu&quot; ).length ) {
					this.collapseAll( event );
				}

				// Reset the mouseHandled flag
				mouseHandled = false;
			}
		});
	},

	_destroy: function() {
		// Destroy (sub)menus
		this.element
			.removeAttr( &quot;aria-activedescendant&quot; )
			.find( &quot;.ui-menu&quot; ).andSelf()
				.removeClass( &quot;ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons&quot; )
				.removeAttr( &quot;role&quot; )
				.removeAttr( &quot;tabIndex&quot; )
				.removeAttr( &quot;aria-labelledby&quot; )
				.removeAttr( &quot;aria-expanded&quot; )
				.removeAttr( &quot;aria-hidden&quot; )
				.removeAttr( &quot;aria-disabled&quot; )
				.removeUniqueId()
				.show();

		// Destroy menu items
		this.element.find( &quot;.ui-menu-item&quot; )
			.removeClass( &quot;ui-menu-item&quot; )
			.removeAttr( &quot;role&quot; )
			.removeAttr( &quot;aria-disabled&quot; )
			.children( &quot;a&quot; )
				.removeUniqueId()
				.removeClass( &quot;ui-corner-all ui-state-hover&quot; )
				.removeAttr( &quot;tabIndex&quot; )
				.removeAttr( &quot;role&quot; )
				.removeAttr( &quot;aria-haspopup&quot; )
				.children().each( function() {
					var elem = $( this );
					if ( elem.data( &quot;ui-menu-submenu-carat&quot; ) ) {
						elem.remove();
					}
				});

		// Destroy menu dividers
		this.element.find( &quot;.ui-menu-divider&quot; ).removeClass( &quot;ui-menu-divider ui-widget-content&quot; );
	},

	_keydown: function( event ) {
		var match, prev, character, skip, regex,
			preventDefault = true;

		function escape( value ) {
			return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, &quot;\\$&amp;&quot; );
		}

		switch ( event.keyCode ) {
		case $.ui.keyCode.PAGE_UP:
			this.previousPage( event );
			break;
		case $.ui.keyCode.PAGE_DOWN:
			this.nextPage( event );
			break;
		case $.ui.keyCode.HOME:
			this._move( &quot;first&quot;, &quot;first&quot;, event );
			break;
		case $.ui.keyCode.END:
			this._move( &quot;last&quot;, &quot;last&quot;, event );
			break;
		case $.ui.keyCode.UP:
			this.previous( event );
			break;
		case $.ui.keyCode.DOWN:
			this.next( event );
			break;
		case $.ui.keyCode.LEFT:
			this.collapse( event );
			break;
		case $.ui.keyCode.RIGHT:
			if ( this.active &amp;&amp; !this.active.is( &quot;.ui-state-disabled&quot; ) ) {
				this.expand( event );
			}
			break;
		case $.ui.keyCode.ENTER:
		case $.ui.keyCode.SPACE:
			this._activate( event );
			break;
		case $.ui.keyCode.ESCAPE:
			this.collapse( event );
			break;
		default:
			preventDefault = false;
			prev = this.previousFilter || &quot;&quot;;
			character = String.fromCharCode( event.keyCode );
			skip = false;

			clearTimeout( this.filterTimer );

			if ( character === prev ) {
				skip = true;
			} else {
				character = prev + character;
			}

			regex = new RegExp( &quot;^&quot; + escape( character ), &quot;i&quot; );
			match = this.activeMenu.children( &quot;.ui-menu-item&quot; ).filter(function() {
				return regex.test( $( this ).children( &quot;a&quot; ).text() );
			});
			match = skip &amp;&amp; match.index( this.active.next() ) !== -1 ?
				this.active.nextAll( &quot;.ui-menu-item&quot; ) :
				match;

			// If no matches on the current filter, reset to the last character pressed
			// to move down the menu to the first item that starts with that character
			if ( !match.length ) {
				character = String.fromCharCode( event.keyCode );
				regex = new RegExp( &quot;^&quot; + escape( character ), &quot;i&quot; );
				match = this.activeMenu.children( &quot;.ui-menu-item&quot; ).filter(function() {
					return regex.test( $( this ).children( &quot;a&quot; ).text() );
				});
			}

			if ( match.length ) {
				this.focus( event, match );
				if ( match.length &gt; 1 ) {
					this.previousFilter = character;
					this.filterTimer = this._delay(function() {
						delete this.previousFilter;
					}, 1000 );
				} else {
					delete this.previousFilter;
				}
			} else {
				delete this.previousFilter;
			}
		}

		if ( preventDefault ) {
			event.preventDefault();
		}
	},

	_activate: function( event ) {
		if ( !this.active.is( &quot;.ui-state-disabled&quot; ) ) {
			if ( this.active.children( &quot;a[aria-haspopup=&#x27;true&#x27;]&quot; ).length ) {
				this.expand( event );
			} else {
				this.select( event );
			}
		}
	},

	refresh: function() {
		// Initialize nested menus
		var menus,
			icon = this.options.icons.submenu,
			submenus = this.element.find( this.options.menus + &quot;:not(.ui-menu)&quot; )
				.addClass( &quot;ui-menu ui-widget ui-widget-content ui-corner-all&quot; )
				.hide()
				.attr({
					role: this.options.role,
					&quot;aria-hidden&quot;: &quot;true&quot;,
					&quot;aria-expanded&quot;: &quot;false&quot;
				});

		// Don&#x27;t refresh list items that are already adapted
		menus = submenus.add( this.element );

		menus.children( &quot;:not(.ui-menu-item):has(a)&quot; )
			.addClass( &quot;ui-menu-item&quot; )
			.attr( &quot;role&quot;, &quot;presentation&quot; )
			.children( &quot;a&quot; )
				.uniqueId()
				.addClass( &quot;ui-corner-all&quot; )
				.attr({
					tabIndex: -1,
					role: this._itemRole()
				});

		// Initialize unlinked menu-items containing spaces and/or dashes only as dividers
		menus.children( &quot;:not(.ui-menu-item)&quot; ).each(function() {
			var item = $( this );
			// hyphen, em dash, en dash
			if ( !/[^\-\s]/.test( item.text() ) ) {
				item.addClass( &quot;ui-widget-content ui-menu-divider&quot; );
			}
		});

		// Add aria-disabled attribute to any disabled menu item
		menus.children( &quot;.ui-state-disabled&quot; ).attr( &quot;aria-disabled&quot;, &quot;true&quot; );

		submenus.each(function() {
			var menu = $( this ),
				item = menu.prev( &quot;a&quot; ),
				submenuCarat = $( &quot;&lt;span&gt;&quot; )
					.addClass( &quot;ui-menu-icon ui-icon &quot; + icon )
					.data( &quot;ui-menu-submenu-carat&quot;, true );

			item
				.attr( &quot;aria-haspopup&quot;, &quot;true&quot; )
				.prepend( submenuCarat );
			menu.attr( &quot;aria-labelledby&quot;, item.attr( &quot;id&quot; ) );
		});

		// If the active item has been removed, blur the menu
		if ( this.active &amp;&amp; !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
			this.blur();
		}
	},

	_itemRole: function() {
		return {
			menu: &quot;menuitem&quot;,
			listbox: &quot;option&quot;
		}[ this.options.role ];
	},

	focus: function( event, item ) {
		var nested, focused;
		this.blur( event, event &amp;&amp; event.type === &quot;focus&quot; );

		this._scrollIntoView( item );

		this.active = item.first();
		focused = this.active.children( &quot;a&quot; ).addClass( &quot;ui-state-focus&quot; );
		// Only update aria-activedescendant if there&#x27;s a role
		// otherwise we assume focus is managed elsewhere
		if ( this.options.role ) {
			this.element.attr( &quot;aria-activedescendant&quot;, focused.attr( &quot;id&quot; ) );
		}

		// Highlight active parent menu item, if any
		this.active
			.parent()
			.closest( &quot;.ui-menu-item&quot; )
			.children( &quot;a:first&quot; )
			.addClass( &quot;ui-state-active&quot; );

		if ( event &amp;&amp; event.type === &quot;keydown&quot; ) {
			this._close();
		} else {
			this.timer = this._delay(function() {
				this._close();
			}, this.delay );
		}

		nested = item.children( &quot;.ui-menu&quot; );
		if ( nested.length &amp;&amp; ( /^mouse/.test( event.type ) ) ) {
			this._startOpening(nested);
		}
		this.activeMenu = item.parent();

		this._trigger( &quot;focus&quot;, event, { item: item } );
	},

	_scrollIntoView: function( item ) {
		var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
		if ( this._hasScroll() ) {
			borderTop = parseFloat( $.css( this.activeMenu[0], &quot;borderTopWidth&quot; ) ) || 0;
			paddingTop = parseFloat( $.css( this.activeMenu[0], &quot;paddingTop&quot; ) ) || 0;
			offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
			scroll = this.activeMenu.scrollTop();
			elementHeight = this.activeMenu.height();
			itemHeight = item.height();

			if ( offset &lt; 0 ) {
				this.activeMenu.scrollTop( scroll + offset );
			} else if ( offset + itemHeight &gt; elementHeight ) {
				this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
			}
		}
	},

	blur: function( event, fromFocus ) {
		if ( !fromFocus ) {
			clearTimeout( this.timer );
		}

		if ( !this.active ) {
			return;
		}

		this.active.children( &quot;a&quot; ).removeClass( &quot;ui-state-focus&quot; );
		this.active = null;

		this._trigger( &quot;blur&quot;, event, { item: this.active } );
	},

	_startOpening: function( submenu ) {
		clearTimeout( this.timer );

		// Don&#x27;t open if already open fixes a Firefox bug that caused a .5 pixel
		// shift in the submenu position when mousing over the carat icon
		if ( submenu.attr( &quot;aria-hidden&quot; ) !== &quot;true&quot; ) {
			return;
		}

		this.timer = this._delay(function() {
			this._close();
			this._open( submenu );
		}, this.delay );
	},

	_open: function( submenu ) {
		var position = $.extend({
			of: this.active
		}, this.options.position );

		clearTimeout( this.timer );
		this.element.find( &quot;.ui-menu&quot; ).not( submenu.parents( &quot;.ui-menu&quot; ) )
			.hide()
			.attr( &quot;aria-hidden&quot;, &quot;true&quot; );

		submenu
			.show()
			.removeAttr( &quot;aria-hidden&quot; )
			.attr( &quot;aria-expanded&quot;, &quot;true&quot; )
			.position( position );
	},

	collapseAll: function( event, all ) {
		clearTimeout( this.timer );
		this.timer = this._delay(function() {
			// If we were passed an event, look for the submenu that contains the event
			var currentMenu = all ? this.element :
				$( event &amp;&amp; event.target ).closest( this.element.find( &quot;.ui-menu&quot; ) );

			// If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
			if ( !currentMenu.length ) {
				currentMenu = this.element;
			}

			this._close( currentMenu );

			this.blur( event );
			this.activeMenu = currentMenu;
		}, this.delay );
	},

	// With no arguments, closes the currently active menu - if nothing is active
	// it closes all menus.  If passed an argument, it will search for menus BELOW
	_close: function( startMenu ) {
		if ( !startMenu ) {
			startMenu = this.active ? this.active.parent() : this.element;
		}

		startMenu
			.find( &quot;.ui-menu&quot; )
				.hide()
				.attr( &quot;aria-hidden&quot;, &quot;true&quot; )
				.attr( &quot;aria-expanded&quot;, &quot;false&quot; )
			.end()
			.find( &quot;a.ui-state-active&quot; )
				.removeClass( &quot;ui-state-active&quot; );
	},

	collapse: function( event ) {
		var newItem = this.active &amp;&amp;
			this.active.parent().closest( &quot;.ui-menu-item&quot;, this.element );
		if ( newItem &amp;&amp; newItem.length ) {
			this._close();
			this.focus( event, newItem );
		}
	},

	expand: function( event ) {
		var newItem = this.active &amp;&amp;
			this.active
				.children( &quot;.ui-menu &quot; )
				.children( &quot;.ui-menu-item&quot; )
				.first();

		if ( newItem &amp;&amp; newItem.length ) {
			this._open( newItem.parent() );

			// Delay so Firefox will not hide activedescendant change in expanding submenu from AT
			this._delay(function() {
				this.focus( event, newItem );
			});
		}
	},

	next: function( event ) {
		this._move( &quot;next&quot;, &quot;first&quot;, event );
	},

	previous: function( event ) {
		this._move( &quot;prev&quot;, &quot;last&quot;, event );
	},

	isFirstItem: function() {
		return this.active &amp;&amp; !this.active.prevAll( &quot;.ui-menu-item&quot; ).length;
	},

	isLastItem: function() {
		return this.active &amp;&amp; !this.active.nextAll( &quot;.ui-menu-item&quot; ).length;
	},

	_move: function( direction, filter, event ) {
		var next;
		if ( this.active ) {
			if ( direction === &quot;first&quot; || direction === &quot;last&quot; ) {
				next = this.active
					[ direction === &quot;first&quot; ? &quot;prevAll&quot; : &quot;nextAll&quot; ]( &quot;.ui-menu-item&quot; )
					.eq( -1 );
			} else {
				next = this.active
					[ direction + &quot;All&quot; ]( &quot;.ui-menu-item&quot; )
					.eq( 0 );
			}
		}
		if ( !next || !next.length || !this.active ) {
			next = this.activeMenu.children( &quot;.ui-menu-item&quot; )[ filter ]();
		}

		this.focus( event, next );
	},

	nextPage: function( event ) {
		var item, base, height;

		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isLastItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.nextAll( &quot;.ui-menu-item&quot; ).each(function() {
				item = $( this );
				return item.offset().top - base - height &lt; 0;
			});

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.children( &quot;.ui-menu-item&quot; )
				[ !this.active ? &quot;first&quot; : &quot;last&quot; ]() );
		}
	},

	previousPage: function( event ) {
		var item, base, height;
		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isFirstItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.prevAll( &quot;.ui-menu-item&quot; ).each(function() {
				item = $( this );
				return item.offset().top - base + height &gt; 0;
			});

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.children( &quot;.ui-menu-item&quot; ).first() );
		}
	},

	_hasScroll: function() {
		return this.element.outerHeight() &lt; this.element.prop( &quot;scrollHeight&quot; );
	},

	select: function( event ) {
		// TODO: It should never be possible to not have an active item at this
		// point, but the tests don&#x27;t trigger mouseenter before click.
		this.active = this.active || $( event.target ).closest( &quot;.ui-menu-item&quot; );
		var ui = { item: this.active };
		if ( !this.active.has( &quot;.ui-menu&quot; ).length ) {
			this.collapseAll( event, true );
		}
		this._trigger( &quot;select&quot;, event, ui );
	}
});

}( jQuery ));

(function( $, undefined ) {

$.ui = $.ui || {};

var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseInt( offsets[ 0 ], 10 ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseInt( offsets[ 1 ], 10 ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}
function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( &quot;&lt;div style=&#x27;display:block;width:50px;height:50px;overflow:hidden;&#x27;&gt;&lt;div style=&#x27;height:100px;width:auto;&#x27;&gt;&lt;/div&gt;&lt;/div&gt;&quot; ),
			innerDiv = div.children()[0];

		$( &quot;body&quot; ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( &quot;overflow&quot;, &quot;scroll&quot; );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[0].clientWidth;
		}

		div.remove();

		return (cachedScrollbarWidth = w1 - w2);
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow ? &quot;&quot; : within.element.css( &quot;overflow-x&quot; ),
			overflowY = within.isWindow ? &quot;&quot; : within.element.css( &quot;overflow-y&quot; ),
			hasOverflowX = overflowX === &quot;scroll&quot; ||
				( overflowX === &quot;auto&quot; &amp;&amp; within.width &lt; within.element[0].scrollWidth ),
			hasOverflowY = overflowY === &quot;scroll&quot; ||
				( overflowY === &quot;auto&quot; &amp;&amp; within.height &lt; within.element[0].scrollHeight );
		return {
			width: hasOverflowX ? $.position.scrollbarWidth() : 0,
			height: hasOverflowY ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[0] );
		return {
			element: withinElement,
			isWindow: isWindow,
			offset: withinElement.offset() || { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: isWindow ? withinElement.width() : withinElement.outerWidth(),
			height: isWindow ? withinElement.height() : withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don&#x27;t want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		targetElem = target[0],
		collision = ( options.collision || &quot;flip&quot; ).split( &quot; &quot; ),
		offsets = {};

	if ( targetElem.nodeType === 9 ) {
		targetWidth = target.width();
		targetHeight = target.height();
		targetOffset = { top: 0, left: 0 };
	} else if ( $.isWindow( targetElem ) ) {
		targetWidth = target.width();
		targetHeight = target.height();
		targetOffset = { top: target.scrollTop(), left: target.scrollLeft() };
	} else if ( targetElem.preventDefault ) {
		// force left top to allow flipping
		options.at = &quot;left top&quot;;
		targetWidth = targetHeight = 0;
		targetOffset = { top: targetElem.pageY, left: targetElem.pageX };
	} else {
		targetWidth = target.outerWidth();
		targetHeight = target.outerHeight();
		targetOffset = target.offset();
	}
	// clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ &quot;my&quot;, &quot;at&quot; ], function() {
		var pos = ( options[ this ] || &quot;&quot; ).split( &quot; &quot; ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ &quot;center&quot; ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ &quot;center&quot; ].concat( pos ) :
					[ &quot;center&quot;, &quot;center&quot; ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : &quot;center&quot;;
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : &quot;center&quot;;

		// calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === &quot;right&quot; ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === &quot;center&quot; ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === &quot;bottom&quot; ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === &quot;center&quot; ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each(function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, &quot;marginLeft&quot; ),
			marginTop = parseCss( this, &quot;marginTop&quot; ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, &quot;marginRight&quot; ) + scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, &quot;marginBottom&quot; ) + scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === &quot;right&quot; ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === &quot;center&quot; ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === &quot;bottom&quot; ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === &quot;center&quot; ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		// if the browser doesn&#x27;t support fractions, then round for consistent results
		if ( !$.support.offsetFractions ) {
			position.left = round( position.left );
			position.top = round( position.top );
		}

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ &quot;left&quot;, &quot;top&quot; ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem : elem
				});
			}
		});

		if ( $.fn.bgiframe ) {
			elem.bgiframe();
		}

		if ( options.using ) {
			// adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right &lt; 0 ? &quot;left&quot; : left &gt; 0 ? &quot;right&quot; : &quot;center&quot;,
						vertical: bottom &lt; 0 ? &quot;top&quot; : top &gt; 0 ? &quot;bottom&quot; : &quot;middle&quot;
					};
				if ( targetWidth &lt; elemWidth &amp;&amp; abs( left + right ) &lt; targetWidth ) {
					feedback.horizontal = &quot;center&quot;;
				}
				if ( targetHeight &lt; elemHeight &amp;&amp; abs( top + bottom ) &lt; targetHeight ) {
					feedback.vertical = &quot;middle&quot;;
				}
				if ( max( abs( left ), abs( right ) ) &gt; max( abs( top ), abs( bottom ) ) ) {
					feedback.important = &quot;horizontal&quot;;
				} else {
					feedback.important = &quot;vertical&quot;;
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// element is wider than within
			if ( data.collisionWidth &gt; outerWidth ) {
				// element is initially over the left side of within
				if ( overLeft &gt; 0 &amp;&amp; overRight &lt;= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
					position.left += overLeft - newOverRight;
				// element is initially over right side of within
				} else if ( overRight &gt; 0 &amp;&amp; overLeft &lt;= 0 ) {
					position.left = withinOffset;
				// element is initially over both left and right sides of within
				} else {
					if ( overLeft &gt; overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}
			// too far left -&gt; align with left edge
			} else if ( overLeft &gt; 0 ) {
				position.left += overLeft;
			// too far right -&gt; align with right edge
			} else if ( overRight &gt; 0 ) {
				position.left -= overRight;
			// adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// element is taller than within
			if ( data.collisionHeight &gt; outerHeight ) {
				// element is initially over the top of within
				if ( overTop &gt; 0 &amp;&amp; overBottom &lt;= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
					position.top += overTop - newOverBottom;
				// element is initially over bottom of within
				} else if ( overBottom &gt; 0 &amp;&amp; overTop &lt;= 0 ) {
					position.top = withinOffset;
				// element is initially over both top and bottom of within
				} else {
					if ( overTop &gt; overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}
			// too far up -&gt; align with top
			} else if ( overTop &gt; 0 ) {
				position.top += overTop;
			// too far down -&gt; align with bottom edge
			} else if ( overBottom &gt; 0 ) {
				position.top -= overBottom;
			// adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === &quot;left&quot; ?
					-data.elemWidth :
					data.my[ 0 ] === &quot;right&quot; ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === &quot;left&quot; ?
					data.targetWidth :
					data.at[ 0 ] === &quot;right&quot; ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft &lt; 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
				if ( newOverRight &lt; 0 || newOverRight &lt; abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			}
			else if ( overRight &gt; 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
				if ( newOverLeft &gt; 0 || abs( newOverLeft ) &lt; overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === &quot;top&quot;,
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === &quot;bottom&quot; ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === &quot;top&quot; ?
					data.targetHeight :
					data.at[ 1 ] === &quot;bottom&quot; ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop &lt; 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
				if ( ( position.top + myOffset + atOffset + offset) &gt; overTop &amp;&amp; ( newOverBottom &lt; 0 || newOverBottom &lt; abs( overTop ) ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
			else if ( overBottom &gt; 0 ) {
				newOverTop = position.top -  data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
				if ( ( position.top + myOffset + atOffset + offset) &gt; overBottom &amp;&amp; ( newOverTop &gt; 0 || abs( newOverTop ) &lt; overBottom ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

// fraction support test
(function () {
	var testElement, testElementParent, testElementStyle, offsetLeft, i,
		body = document.getElementsByTagName( &quot;body&quot; )[ 0 ],
		div = document.createElement( &quot;div&quot; );

	//Create a &quot;fake body&quot; for testing based on method used in jQuery.support
	testElement = document.createElement( body ? &quot;div&quot; : &quot;body&quot; );
	testElementStyle = {
		visibility: &quot;hidden&quot;,
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: &quot;none&quot;
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: &quot;absolute&quot;,
			left: &quot;-1000px&quot;,
			top: &quot;-1000px&quot;
		});
	}
	for ( i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = &quot;position: absolute; left: 10.7432222px;&quot;;

	offsetLeft = $( div ).offset().left;
	$.support.offsetFractions = offsetLeft &gt; 10 &amp;&amp; offsetLeft &lt; 11;

	testElement.innerHTML = &quot;&quot;;
	testElementParent.removeChild( testElement );
})();

// DEPRECATED
if ( $.uiBackCompat !== false ) {
	// offset option
	(function( $ ) {
		var _position = $.fn.position;
		$.fn.position = function( options ) {
			if ( !options || !options.offset ) {
				return _position.call( this, options );
			}
			var offset = options.offset.split( &quot; &quot; ),
				at = options.at.split( &quot; &quot; );
			if ( offset.length === 1 ) {
				offset[ 1 ] = offset[ 0 ];
			}
			if ( /^\d/.test( offset[ 0 ] ) ) {
				offset[ 0 ] = &quot;+&quot; + offset[ 0 ];
			}
			if ( /^\d/.test( offset[ 1 ] ) ) {
				offset[ 1 ] = &quot;+&quot; + offset[ 1 ];
			}
			if ( at.length === 1 ) {
				if ( /left|center|right/.test( at[ 0 ] ) ) {
					at[ 1 ] = &quot;center&quot;;
				} else {
					at[ 1 ] = at[ 0 ];
					at[ 0 ] = &quot;center&quot;;
				}
			}
			return _position.call( this, $.extend( options, {
				at: at[ 0 ] + offset[ 0 ] + &quot; &quot; + at[ 1 ] + offset[ 1 ],
				offset: undefined
			} ) );
		};
	}( jQuery ) );
}

}( jQuery ) );

(function( $, undefined ) {

$.widget( &quot;ui.progressbar&quot;, {
	version: &quot;1.9.1&quot;,
	options: {
		value: 0,
		max: 100
	},

	min: 0,

	_create: function() {
		this.element
			.addClass( &quot;ui-progressbar ui-widget ui-widget-content ui-corner-all&quot; )
			.attr({
				role: &quot;progressbar&quot;,
				&quot;aria-valuemin&quot;: this.min,
				&quot;aria-valuemax&quot;: this.options.max,
				&quot;aria-valuenow&quot;: this._value()
			});

		this.valueDiv = $( &quot;&lt;div class=&#x27;ui-progressbar-value ui-widget-header ui-corner-left&#x27;&gt;&lt;/div&gt;&quot; )
			.appendTo( this.element );

		this.oldValue = this._value();
		this._refreshValue();
	},

	_destroy: function() {
		this.element
			.removeClass( &quot;ui-progressbar ui-widget ui-widget-content ui-corner-all&quot; )
			.removeAttr( &quot;role&quot; )
			.removeAttr( &quot;aria-valuemin&quot; )
			.removeAttr( &quot;aria-valuemax&quot; )
			.removeAttr( &quot;aria-valuenow&quot; );

		this.valueDiv.remove();
	},

	value: function( newValue ) {
		if ( newValue === undefined ) {
			return this._value();
		}

		this._setOption( &quot;value&quot;, newValue );
		return this;
	},

	_setOption: function( key, value ) {
		if ( key === &quot;value&quot; ) {
			this.options.value = value;
			this._refreshValue();
			if ( this._value() === this.options.max ) {
				this._trigger( &quot;complete&quot; );
			}
		}

		this._super( key, value );
	},

	_value: function() {
		var val = this.options.value;
		// normalize invalid value
		if ( typeof val !== &quot;number&quot; ) {
			val = 0;
		}
		return Math.min( this.options.max, Math.max( this.min, val ) );
	},

	_percentage: function() {
		return 100 * this._value() / this.options.max;
	},

	_refreshValue: function() {
		var value = this.value(),
			percentage = this._percentage();

		if ( this.oldValue !== value ) {
			this.oldValue = value;
			this._trigger( &quot;change&quot; );
		}

		this.valueDiv
			.toggle( value &gt; this.min )
			.toggleClass( &quot;ui-corner-right&quot;, value === this.options.max )
			.width( percentage.toFixed(0) + &quot;%&quot; );
		this.element.attr( &quot;aria-valuenow&quot;, value );
	}
});

})( jQuery );

(function( $, undefined ) {

// number of pages in a slider
// (how many times can you page up/down to go through the whole range)
var numPages = 5;

$.widget( &quot;ui.slider&quot;, $.ui.mouse, {
	version: &quot;1.9.1&quot;,
	widgetEventPrefix: &quot;slide&quot;,

	options: {
		animate: false,
		distance: 0,
		max: 100,
		min: 0,
		orientation: &quot;horizontal&quot;,
		range: false,
		step: 1,
		value: 0,
		values: null
	},

	_create: function() {
		var i, handleCount,
			o = this.options,
			existingHandles = this.element.find( &quot;.ui-slider-handle&quot; ).addClass( &quot;ui-state-default ui-corner-all&quot; ),
			handle = &quot;&lt;a class=&#x27;ui-slider-handle ui-state-default ui-corner-all&#x27; href=&#x27;#&#x27;&gt;&lt;/a&gt;&quot;,
			handles = [];

		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();

		this.element
			.addClass( &quot;ui-slider&quot; +
				&quot; ui-slider-&quot; + this.orientation +
				&quot; ui-widget&quot; +
				&quot; ui-widget-content&quot; +
				&quot; ui-corner-all&quot; +
				( o.disabled ? &quot; ui-slider-disabled ui-disabled&quot; : &quot;&quot; ) );

		this.range = $([]);

		if ( o.range ) {
			if ( o.range === true ) {
				if ( !o.values ) {
					o.values = [ this._valueMin(), this._valueMin() ];
				}
				if ( o.values.length &amp;&amp; o.values.length !== 2 ) {
					o.values = [ o.values[0], o.values[0] ];
				}
			}

			this.range = $( &quot;&lt;div&gt;&lt;/div&gt;&quot; )
				.appendTo( this.element )
				.addClass( &quot;ui-slider-range&quot; +
				// note: this isn&#x27;t the most fittingly semantic framework class for this element,
				// but worked best visually with a variety of themes
				&quot; ui-widget-header&quot; +
				( ( o.range === &quot;min&quot; || o.range === &quot;max&quot; ) ? &quot; ui-slider-range-&quot; + o.range : &quot;&quot; ) );
		}

		handleCount = ( o.values &amp;&amp; o.values.length ) || 1;

		for ( i = existingHandles.length; i &lt; handleCount; i++ ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( &quot;&quot; ) ).appendTo( this.element ) );

		this.handle = this.handles.eq( 0 );

		this.handles.add( this.range ).filter( &quot;a&quot; )
			.click(function( event ) {
				event.preventDefault();
			})
			.mouseenter(function() {
				if ( !o.disabled ) {
					$( this ).addClass( &quot;ui-state-hover&quot; );
				}
			})
			.mouseleave(function() {
				$( this ).removeClass( &quot;ui-state-hover&quot; );
			})
			.focus(function() {
				if ( !o.disabled ) {
					$( &quot;.ui-slider .ui-state-focus&quot; ).removeClass( &quot;ui-state-focus&quot; );
					$( this ).addClass( &quot;ui-state-focus&quot; );
				} else {
					$( this ).blur();
				}
			})
			.blur(function() {
				$( this ).removeClass( &quot;ui-state-focus&quot; );
			});

		this.handles.each(function( i ) {
			$( this ).data( &quot;ui-slider-handle-index&quot;, i );
		});

		this._on( this.handles, {
			keydown: function( event ) {
				var allowed, curVal, newVal, step,
					index = $( event.target ).data( &quot;ui-slider-handle-index&quot; );

				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
					case $.ui.keyCode.END:
					case $.ui.keyCode.PAGE_UP:
					case $.ui.keyCode.PAGE_DOWN:
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						event.preventDefault();
						if ( !this._keySliding ) {
							this._keySliding = true;
							$( event.target ).addClass( &quot;ui-state-active&quot; );
							allowed = this._start( event, index );
							if ( allowed === false ) {
								return;
							}
						}
						break;
				}

				step = this.options.step;
				if ( this.options.values &amp;&amp; this.options.values.length ) {
					curVal = newVal = this.values( index );
				} else {
					curVal = newVal = this.value();
				}

				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
						newVal = this._valueMin();
						break;
					case $.ui.keyCode.END:
						newVal = this._valueMax();
						break;
					case $.ui.keyCode.PAGE_UP:
						newVal = this._trimAlignValue( curVal + ( (this._valueMax() - this._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.PAGE_DOWN:
						newVal = this._trimAlignValue( curVal - ( (this._valueMax() - this._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
						if ( curVal === this._valueMax() ) {
							return;
						}
						newVal = this._trimAlignValue( curVal + step );
						break;
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						if ( curVal === this._valueMin() ) {
							return;
						}
						newVal = this._trimAlignValue( curVal - step );
						break;
				}

				this._slide( event, index, newVal );
			},
			keyup: function( event ) {
				var index = $( event.target ).data( &quot;ui-slider-handle-index&quot; );

				if ( this._keySliding ) {
					this._keySliding = false;
					this._stop( event, index );
					this._change( event, index );
					$( event.target ).removeClass( &quot;ui-state-active&quot; );
				}
			}
		});

		this._refreshValue();

		this._animateOff = false;
	},

	_destroy: function() {
		this.handles.remove();
		this.range.remove();

		this.element
			.removeClass( &quot;ui-slider&quot; +
				&quot; ui-slider-horizontal&quot; +
				&quot; ui-slider-vertical&quot; +
				&quot; ui-slider-disabled&quot; +
				&quot; ui-widget&quot; +
				&quot; ui-widget-content&quot; +
				&quot; ui-corner-all&quot; );

		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
			that = this,
			o = this.options;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		this.handles.each(function( i ) {
			var thisDistance = Math.abs( normValue - that.values(i) );
			if ( distance &gt; thisDistance ) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		});

		// workaround for bug #3736 (if both handles of a range are at 0,
		// the first is always used as the one with least distance,
		// and moving it is obviously prevented by preventing negative ranges)
		if( o.range === true &amp;&amp; this.values(1) === o.min ) {
			index += 1;
			closestHandle = $( this.handles[index] );
		}

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		this._handleIndex = index;

		closestHandle
			.addClass( &quot;ui-state-active&quot; )
			.focus();

		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().andSelf().is( &quot;.ui-slider-handle&quot; );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css(&quot;borderTopWidth&quot;), 10 ) || 0 ) -
				( parseInt( closestHandle.css(&quot;borderBottomWidth&quot;), 10 ) || 0) +
				( parseInt( closestHandle.css(&quot;marginTop&quot;), 10 ) || 0)
		};

		if ( !this.handles.hasClass( &quot;ui-state-hover&quot; ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function() {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );

		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this.handles.removeClass( &quot;ui-state-active&quot; );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},

	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === &quot;vertical&quot; ) ? &quot;vertical&quot; : &quot;horizontal&quot;;
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === &quot;horizontal&quot; ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse &gt; 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse &lt; 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === &quot;vertical&quot; ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_start: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values &amp;&amp; this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}
		return this._trigger( &quot;start&quot;, event, uiHash );
	},

	_slide: function( event, index, newVal ) {
		var otherVal,
			newValues,
			allowed;

		if ( this.options.values &amp;&amp; this.options.values.length ) {
			otherVal = this.values( index ? 0 : 1 );

			if ( ( this.options.values.length === 2 &amp;&amp; this.options.range === true ) &amp;&amp;
					( ( index === 0 &amp;&amp; newVal &gt; otherVal) || ( index === 1 &amp;&amp; newVal &lt; otherVal ) )
				) {
				newVal = otherVal;
			}

			if ( newVal !== this.values( index ) ) {
				newValues = this.values();
				newValues[ index ] = newVal;
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( &quot;slide&quot;, event, {
					handle: this.handles[ index ],
					value: newVal,
					values: newValues
				} );
				otherVal = this.values( index ? 0 : 1 );
				if ( allowed !== false ) {
					this.values( index, newVal, true );
				}
			}
		} else {
			if ( newVal !== this.value() ) {
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( &quot;slide&quot;, event, {
					handle: this.handles[ index ],
					value: newVal
				} );
				if ( allowed !== false ) {
					this.value( newVal );
				}
			}
		}
	},

	_stop: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values &amp;&amp; this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}

		this._trigger( &quot;stop&quot;, event, uiHash );
	},

	_change: function( event, index ) {
		if ( !this._keySliding &amp;&amp; !this._mouseSliding ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values &amp;&amp; this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}

			this._trigger( &quot;change&quot;, event, uiHash );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length &gt; 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i &lt; vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this.options.values &amp;&amp; this.options.values.length ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		$.Widget.prototype._setOption.apply( this, arguments );

		switch ( key ) {
			case &quot;disabled&quot;:
				if ( value ) {
					this.handles.filter( &quot;.ui-state-focus&quot; ).blur();
					this.handles.removeClass( &quot;ui-state-hover&quot; );
					this.handles.prop( &quot;disabled&quot;, true );
					this.element.addClass( &quot;ui-disabled&quot; );
				} else {
					this.handles.prop( &quot;disabled&quot;, false );
					this.element.removeClass( &quot;ui-disabled&quot; );
				}
				break;
			case &quot;orientation&quot;:
				this._detectOrientation();
				this.element
					.removeClass( &quot;ui-slider-horizontal ui-slider-vertical&quot; )
					.addClass( &quot;ui-slider-&quot; + this.orientation );
				this._refreshValue();
				break;
			case &quot;value&quot;:
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case &quot;values&quot;:
				this._animateOff = true;
				this._refreshValue();
				for ( i = 0; i &lt; valsLength; i += 1 ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
			case &quot;min&quot;:
			case &quot;max&quot;:
				this._animateOff = true;
				this._refreshValue();
				this._animateOff = false;
				break;
		}
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else {
			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i &lt; vals.length; i+= 1) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		}
	},

	// returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val &lt;= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val &gt;= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step &gt; 0 ) ? this.options.step : 1,
			valModStep = (val - this._valueMin()) % step,
			alignValue = val - valModStep;

		if ( Math.abs(valModStep) * 2 &gt;= step ) {
			alignValue += ( valModStep &gt; 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed(5) );
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.options.max;
	},

	_refreshValue: function() {
		var lastValPercent, valPercent, value, valueMin, valueMax,
			oRange = this.options.range,
			o = this.options,
			that = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			_set = {};

		if ( this.options.values &amp;&amp; this.options.values.length ) {
			this.handles.each(function( i ) {
				valPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;
				_set[ that.orientation === &quot;horizontal&quot; ? &quot;left&quot; : &quot;bottom&quot; ] = valPercent + &quot;%&quot;;
				$( this ).stop( 1, 1 )[ animate ? &quot;animate&quot; : &quot;css&quot; ]( _set, o.animate );
				if ( that.options.range === true ) {
					if ( that.orientation === &quot;horizontal&quot; ) {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { left: valPercent + &quot;%&quot; }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { width: ( valPercent - lastValPercent ) + &quot;%&quot; }, { queue: false, duration: o.animate } );
						}
					} else {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { bottom: ( valPercent ) + &quot;%&quot; }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { height: ( valPercent - lastValPercent ) + &quot;%&quot; }, { queue: false, duration: o.animate } );
						}
					}
				}
				lastValPercent = valPercent;
			});
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ this.orientation === &quot;horizontal&quot; ? &quot;left&quot; : &quot;bottom&quot; ] = valPercent + &quot;%&quot;;
			this.handle.stop( 1, 1 )[ animate ? &quot;animate&quot; : &quot;css&quot; ]( _set, o.animate );

			if ( oRange === &quot;min&quot; &amp;&amp; this.orientation === &quot;horizontal&quot; ) {
				this.range.stop( 1, 1 )[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { width: valPercent + &quot;%&quot; }, o.animate );
			}
			if ( oRange === &quot;max&quot; &amp;&amp; this.orientation === &quot;horizontal&quot; ) {
				this.range[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { width: ( 100 - valPercent ) + &quot;%&quot; }, { queue: false, duration: o.animate } );
			}
			if ( oRange === &quot;min&quot; &amp;&amp; this.orientation === &quot;vertical&quot; ) {
				this.range.stop( 1, 1 )[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { height: valPercent + &quot;%&quot; }, o.animate );
			}
			if ( oRange === &quot;max&quot; &amp;&amp; this.orientation === &quot;vertical&quot; ) {
				this.range[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { height: ( 100 - valPercent ) + &quot;%&quot; }, { queue: false, duration: o.animate } );
			}
		}
	}

});

}(jQuery));

(function( $ ) {

function modifier( fn ) {
	return function() {
		var previous = this.element.val();
		fn.apply( this, arguments );
		this._refresh();
		if ( previous !== this.element.val() ) {
			this._trigger( &quot;change&quot; );
		}
	};
}

$.widget( &quot;ui.spinner&quot;, {
	version: &quot;1.9.1&quot;,
	defaultElement: &quot;&lt;input&gt;&quot;,
	widgetEventPrefix: &quot;spin&quot;,
	options: {
		culture: null,
		icons: {
			down: &quot;ui-icon-triangle-1-s&quot;,
			up: &quot;ui-icon-triangle-1-n&quot;
		},
		incremental: true,
		max: null,
		min: null,
		numberFormat: null,
		page: 10,
		step: 1,

		change: null,
		spin: null,
		start: null,
		stop: null
	},

	_create: function() {
		// handle string values that need to be parsed
		this._setOption( &quot;max&quot;, this.options.max );
		this._setOption( &quot;min&quot;, this.options.min );
		this._setOption( &quot;step&quot;, this.options.step );

		// format the value, but don&#x27;t constrain
		this._value( this.element.val(), true );

		this._draw();
		this._on( this._events );
		this._refresh();

		// turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( &quot;autocomplete&quot; );
			}
		});
	},

	_getCreateOptions: function() {
		var options = {},
			element = this.element;

		$.each( [ &quot;min&quot;, &quot;max&quot;, &quot;step&quot; ], function( i, option ) {
			var value = element.attr( option );
			if ( value !== undefined &amp;&amp; value.length ) {
				options[ option ] = value;
			}
		});

		return options;
	},

	_events: {
		keydown: function( event ) {
			if ( this._start( event ) &amp;&amp; this._keydown( event ) ) {
				event.preventDefault();
			}
		},
		keyup: &quot;_stop&quot;,
		focus: function() {
			this.previous = this.element.val();
		},
		blur: function( event ) {
			if ( this.cancelBlur ) {
				delete this.cancelBlur;
				return;
			}

			this._refresh();
			if ( this.previous !== this.element.val() ) {
				this._trigger( &quot;change&quot;, event );
			}
		},
		mousewheel: function( event, delta ) {
			if ( !delta ) {
				return;
			}
			if ( !this.spinning &amp;&amp; !this._start( event ) ) {
				return false;
			}

			this._spin( (delta &gt; 0 ? 1 : -1) * this.options.step, event );
			clearTimeout( this.mousewheelTimer );
			this.mousewheelTimer = this._delay(function() {
				if ( this.spinning ) {
					this._stop( event );
				}
			}, 100 );
			event.preventDefault();
		},
		&quot;mousedown .ui-spinner-button&quot;: function( event ) {
			var previous;

			// We never want the buttons to have focus; whenever the user is
			// interacting with the spinner, the focus should be on the input.
			// If the input is focused then this.previous is properly set from
			// when the input first received focus. If the input is not focused
			// then we need to set this.previous based on the value before spinning.
			previous = this.element[0] === this.document[0].activeElement ?
				this.previous : this.element.val();
			function checkFocus() {
				var isActive = this.element[0] === this.document[0].activeElement;
				if ( !isActive ) {
					this.element.focus();
					this.previous = previous;
					// support: IE
					// IE sets focus asynchronously, so we need to check if focus
					// moved off of the input because the user clicked on the button.
					this._delay(function() {
						this.previous = previous;
					});
				}
			}

			// ensure focus is on (or stays on) the text field
			event.preventDefault();
			checkFocus.call( this );

			// support: IE
			// IE doesn&#x27;t prevent moving focus even with event.preventDefault()
			// so we set a flag to know when we should ignore the blur event
			// and check (again) if focus moved off of the input.
			this.cancelBlur = true;
			this._delay(function() {
				delete this.cancelBlur;
				checkFocus.call( this );
			});

			if ( this._start( event ) === false ) {
				return;
			}

			this._repeat( null, $( event.currentTarget ).hasClass( &quot;ui-spinner-up&quot; ) ? 1 : -1, event );
		},
		&quot;mouseup .ui-spinner-button&quot;: &quot;_stop&quot;,
		&quot;mouseenter .ui-spinner-button&quot;: function( event ) {
			// button will add ui-state-active if mouse was down while mouseleave and kept down
			if ( !$( event.currentTarget ).hasClass( &quot;ui-state-active&quot; ) ) {
				return;
			}

			if ( this._start( event ) === false ) {
				return false;
			}
			this._repeat( null, $( event.currentTarget ).hasClass( &quot;ui-spinner-up&quot; ) ? 1 : -1, event );
		},
		// TODO: do we really want to consider this a stop?
		// shouldn&#x27;t we just stop the repeater and wait until mouseup before
		// we trigger the stop event?
		&quot;mouseleave .ui-spinner-button&quot;: &quot;_stop&quot;
	},

	_draw: function() {
		var uiSpinner = this.uiSpinner = this.element
			.addClass( &quot;ui-spinner-input&quot; )
			.attr( &quot;autocomplete&quot;, &quot;off&quot; )
			.wrap( this._uiSpinnerHtml() )
			.parent()
				// add buttons
				.append( this._buttonHtml() );

		this.element.attr( &quot;role&quot;, &quot;spinbutton&quot; );

		// button bindings
		this.buttons = uiSpinner.find( &quot;.ui-spinner-button&quot; )
			.attr( &quot;tabIndex&quot;, -1 )
			.button()
			.removeClass( &quot;ui-corner-all&quot; );

		// IE 6 doesn&#x27;t understand height: 50% for the buttons
		// unless the wrapper has an explicit height
		if ( this.buttons.height() &gt; Math.ceil( uiSpinner.height() * 0.5 ) &amp;&amp;
				uiSpinner.height() &gt; 0 ) {
			uiSpinner.height( uiSpinner.height() );
		}

		// disable spinner if element was already disabled
		if ( this.options.disabled ) {
			this.disable();
		}
	},

	_keydown: function( event ) {
		var options = this.options,
			keyCode = $.ui.keyCode;

		switch ( event.keyCode ) {
		case keyCode.UP:
			this._repeat( null, 1, event );
			return true;
		case keyCode.DOWN:
			this._repeat( null, -1, event );
			return true;
		case keyCode.PAGE_UP:
			this._repeat( null, options.page, event );
			return true;
		case keyCode.PAGE_DOWN:
			this._repeat( null, -options.page, event );
			return true;
		}

		return false;
	},

	_uiSpinnerHtml: function() {
		return &quot;&lt;span class=&#x27;ui-spinner ui-widget ui-widget-content ui-corner-all&#x27;&gt;&lt;/span&gt;&quot;;
	},

	_buttonHtml: function() {
		return &quot;&quot; +
			&quot;&lt;a class=&#x27;ui-spinner-button ui-spinner-up ui-corner-tr&#x27;&gt;&quot; +
				&quot;&lt;span class=&#x27;ui-icon &quot; + this.options.icons.up + &quot;&#x27;&gt;&amp;#9650;&lt;/span&gt;&quot; +
			&quot;&lt;/a&gt;&quot; +
			&quot;&lt;a class=&#x27;ui-spinner-button ui-spinner-down ui-corner-br&#x27;&gt;&quot; +
				&quot;&lt;span class=&#x27;ui-icon &quot; + this.options.icons.down + &quot;&#x27;&gt;&amp;#9660;&lt;/span&gt;&quot; +
			&quot;&lt;/a&gt;&quot;;
	},

	_start: function( event ) {
		if ( !this.spinning &amp;&amp; this._trigger( &quot;start&quot;, event ) === false ) {
			return false;
		}

		if ( !this.counter ) {
			this.counter = 1;
		}
		this.spinning = true;
		return true;
	},

	_repeat: function( i, steps, event ) {
		i = i || 500;

		clearTimeout( this.timer );
		this.timer = this._delay(function() {
			this._repeat( 40, steps, event );
		}, i );

		this._spin( steps * this.options.step, event );
	},

	_spin: function( step, event ) {
		var value = this.value() || 0;

		if ( !this.counter ) {
			this.counter = 1;
		}

		value = this._adjustValue( value + step * this._increment( this.counter ) );

		if ( !this.spinning || this._trigger( &quot;spin&quot;, event, { value: value } ) !== false) {
			this._value( value );
			this.counter++;
		}
	},

	_increment: function( i ) {
		var incremental = this.options.incremental;

		if ( incremental ) {
			return $.isFunction( incremental ) ?
				incremental( i ) :
				Math.floor( i*i*i/50000 - i*i/500 + 17*i/200 + 1 );
		}

		return 1;
	},

	_precision: function() {
		var precision = this._precisionOf( this.options.step );
		if ( this.options.min !== null ) {
			precision = Math.max( precision, this._precisionOf( this.options.min ) );
		}
		return precision;
	},

	_precisionOf: function( num ) {
		var str = num.toString(),
			decimal = str.indexOf( &quot;.&quot; );
		return decimal === -1 ? 0 : str.length - decimal - 1;
	},

	_adjustValue: function( value ) {
		var base, aboveMin,
			options = this.options;

		// make sure we&#x27;re at a valid step
		// - find out where we are relative to the base (min or 0)
		base = options.min !== null ? options.min : 0;
		aboveMin = value - base;
		// - round to the nearest step
		aboveMin = Math.round(aboveMin / options.step) * options.step;
		// - rounding is based on 0, so adjust back to our base
		value = base + aboveMin;

		// fix precision from bad JS floating point math
		value = parseFloat( value.toFixed( this._precision() ) );

		// clamp the value
		if ( options.max !== null &amp;&amp; value &gt; options.max) {
			return options.max;
		}
		if ( options.min !== null &amp;&amp; value &lt; options.min ) {
			return options.min;
		}

		return value;
	},

	_stop: function( event ) {
		if ( !this.spinning ) {
			return;
		}

		clearTimeout( this.timer );
		clearTimeout( this.mousewheelTimer );
		this.counter = 0;
		this.spinning = false;
		this._trigger( &quot;stop&quot;, event );
	},

	_setOption: function( key, value ) {
		if ( key === &quot;culture&quot; || key === &quot;numberFormat&quot; ) {
			var prevValue = this._parse( this.element.val() );
			this.options[ key ] = value;
			this.element.val( this._format( prevValue ) );
			return;
		}

		if ( key === &quot;max&quot; || key === &quot;min&quot; || key === &quot;step&quot; ) {
			if ( typeof value === &quot;string&quot; ) {
				value = this._parse( value );
			}
		}

		this._super( key, value );

		if ( key === &quot;disabled&quot; ) {
			if ( value ) {
				this.element.prop( &quot;disabled&quot;, true );
				this.buttons.button( &quot;disable&quot; );
			} else {
				this.element.prop( &quot;disabled&quot;, false );
				this.buttons.button( &quot;enable&quot; );
			}
		}
	},

	_setOptions: modifier(function( options ) {
		this._super( options );
		this._value( this.element.val() );
	}),

	_parse: function( val ) {
		if ( typeof val === &quot;string&quot; &amp;&amp; val !== &quot;&quot; ) {
			val = window.Globalize &amp;&amp; this.options.numberFormat ?
				Globalize.parseFloat( val, 10, this.options.culture ) : +val;
		}
		return val === &quot;&quot; || isNaN( val ) ? null : val;
	},

	_format: function( value ) {
		if ( value === &quot;&quot; ) {
			return &quot;&quot;;
		}
		return window.Globalize &amp;&amp; this.options.numberFormat ?
			Globalize.format( value, this.options.numberFormat, this.options.culture ) :
			value;
	},

	_refresh: function() {
		this.element.attr({
			&quot;aria-valuemin&quot;: this.options.min,
			&quot;aria-valuemax&quot;: this.options.max,
			// TODO: what should we do with values that can&#x27;t be parsed?
			&quot;aria-valuenow&quot;: this._parse( this.element.val() )
		});
	},

	// update the value without triggering change
	_value: function( value, allowAny ) {
		var parsed;
		if ( value !== &quot;&quot; ) {
			parsed = this._parse( value );
			if ( parsed !== null ) {
				if ( !allowAny ) {
					parsed = this._adjustValue( parsed );
				}
				value = this._format( parsed );
			}
		}
		this.element.val( value );
		this._refresh();
	},

	_destroy: function() {
		this.element
			.removeClass( &quot;ui-spinner-input&quot; )
			.prop( &quot;disabled&quot;, false )
			.removeAttr( &quot;autocomplete&quot; )
			.removeAttr( &quot;role&quot; )
			.removeAttr( &quot;aria-valuemin&quot; )
			.removeAttr( &quot;aria-valuemax&quot; )
			.removeAttr( &quot;aria-valuenow&quot; );
		this.uiSpinner.replaceWith( this.element );
	},

	stepUp: modifier(function( steps ) {
		this._stepUp( steps );
	}),
	_stepUp: function( steps ) {
		this._spin( (steps || 1) * this.options.step );
	},

	stepDown: modifier(function( steps ) {
		this._stepDown( steps );
	}),
	_stepDown: function( steps ) {
		this._spin( (steps || 1) * -this.options.step );
	},

	pageUp: modifier(function( pages ) {
		this._stepUp( (pages || 1) * this.options.page );
	}),

	pageDown: modifier(function( pages ) {
		this._stepDown( (pages || 1) * this.options.page );
	}),

	value: function( newVal ) {
		if ( !arguments.length ) {
			return this._parse( this.element.val() );
		}
		modifier( this._value ).call( this, newVal );
	},

	widget: function() {
		return this.uiSpinner;
	}
});

}( jQuery ) );

(function( $, undefined ) {

var tabId = 0,
	rhash = /#.*$/;

function getNextTabId() {
	return ++tabId;
}

function isLocal( anchor ) {
	return anchor.hash.length &gt; 1 &amp;&amp;
		anchor.href.replace( rhash, &quot;&quot; ) === location.href.replace( rhash, &quot;&quot; );
}

$.widget( &quot;ui.tabs&quot;, {
	version: &quot;1.9.1&quot;,
	delay: 300,
	options: {
		active: null,
		collapsible: false,
		event: &quot;click&quot;,
		heightStyle: &quot;content&quot;,
		hide: null,
		show: null,

		// callbacks
		activate: null,
		beforeActivate: null,
		beforeLoad: null,
		load: null
	},

	_create: function() {
		var that = this,
			options = this.options,
			active = options.active,
			locationHash = location.hash.substring( 1 );

		this.running = false;

		this.element
			.addClass( &quot;ui-tabs ui-widget ui-widget-content ui-corner-all&quot; )
			.toggleClass( &quot;ui-tabs-collapsible&quot;, options.collapsible )
			// Prevent users from focusing disabled tabs via click
			.delegate( &quot;.ui-tabs-nav &gt; li&quot;, &quot;mousedown&quot; + this.eventNamespace, function( event ) {
				if ( $( this ).is( &quot;.ui-state-disabled&quot; ) ) {
					event.preventDefault();
				}
			})
			// support: IE &lt;9
			// Preventing the default action in mousedown doesn&#x27;t prevent IE
			// from focusing the element, so if the anchor gets focused, blur.
			// We don&#x27;t have to worry about focusing the previously focused
			// element since clicking on a non-focusable element should focus
			// the body anyway.
			.delegate( &quot;.ui-tabs-anchor&quot;, &quot;focus&quot; + this.eventNamespace, function() {
				if ( $( this ).closest( &quot;li&quot; ).is( &quot;.ui-state-disabled&quot; ) ) {
					this.blur();
				}
			});

		this._processTabs();

		if ( active === null ) {
			// check the fragment identifier in the URL
			if ( locationHash ) {
				this.tabs.each(function( i, tab ) {
					if ( $( tab ).attr( &quot;aria-controls&quot; ) === locationHash ) {
						active = i;
						return false;
					}
				});
			}

			// check for a tab marked active via a class
			if ( active === null ) {
				active = this.tabs.index( this.tabs.filter( &quot;.ui-tabs-active&quot; ) );
			}

			// no active tab, set to false
			if ( active === null || active === -1 ) {
				active = this.tabs.length ? 0 : false;
			}
		}

		// handle numbers: negative, out of range
		if ( active !== false ) {
			active = this.tabs.index( this.tabs.eq( active ) );
			if ( active === -1 ) {
				active = options.collapsible ? false : 0;
			}
		}
		options.active = active;

		// don&#x27;t allow collapsible: false and active: false
		if ( !options.collapsible &amp;&amp; options.active === false &amp;&amp; this.anchors.length ) {
			options.active = 0;
		}

		// Take disabling tabs via class attribute from HTML
		// into account and update option properly.
		if ( $.isArray( options.disabled ) ) {
			options.disabled = $.unique( options.disabled.concat(
				$.map( this.tabs.filter( &quot;.ui-state-disabled&quot; ), function( li ) {
					return that.tabs.index( li );
				})
			) ).sort();
		}

		// check for length avoids error when initializing empty list
		if ( this.options.active !== false &amp;&amp; this.anchors.length ) {
			this.active = this._findActive( this.options.active );
		} else {
			this.active = $();
		}

		this._refresh();

		if ( this.active.length ) {
			this.load( options.active );
		}
	},

	_getCreateEventData: function() {
		return {
			tab: this.active,
			panel: !this.active.length ? $() : this._getPanelForTab( this.active )
		};
	},

	_tabKeydown: function( event ) {
		var focusedTab = $( this.document[0].activeElement ).closest( &quot;li&quot; ),
			selectedIndex = this.tabs.index( focusedTab ),
			goingForward = true;

		if ( this._handlePageNav( event ) ) {
			return;
		}

		switch ( event.keyCode ) {
			case $.ui.keyCode.RIGHT:
			case $.ui.keyCode.DOWN:
				selectedIndex++;
				break;
			case $.ui.keyCode.UP:
			case $.ui.keyCode.LEFT:
				goingForward = false;
				selectedIndex--;
				break;
			case $.ui.keyCode.END:
				selectedIndex = this.anchors.length - 1;
				break;
			case $.ui.keyCode.HOME:
				selectedIndex = 0;
				break;
			case $.ui.keyCode.SPACE:
				// Activate only, no collapsing
				event.preventDefault();
				clearTimeout( this.activating );
				this._activate( selectedIndex );
				return;
			case $.ui.keyCode.ENTER:
				// Toggle (cancel delayed activation, allow collapsing)
				event.preventDefault();
				clearTimeout( this.activating );
				// Determine if we should collapse or activate
				this._activate( selectedIndex === this.options.active ? false : selectedIndex );
				return;
			default:
				return;
		}

		// Focus the appropriate tab, based on which key was pressed
		event.preventDefault();
		clearTimeout( this.activating );
		selectedIndex = this._focusNextTab( selectedIndex, goingForward );

		// Navigating with control key will prevent automatic activation
		if ( !event.ctrlKey ) {
			// Update aria-selected immediately so that AT think the tab is already selected.
			// Otherwise AT may confuse the user by stating that they need to activate the tab,
			// but the tab will already be activated by the time the announcement finishes.
			focusedTab.attr( &quot;aria-selected&quot;, &quot;false&quot; );
			this.tabs.eq( selectedIndex ).attr( &quot;aria-selected&quot;, &quot;true&quot; );

			this.activating = this._delay(function() {
				this.option( &quot;active&quot;, selectedIndex );
			}, this.delay );
		}
	},

	_panelKeydown: function( event ) {
		if ( this._handlePageNav( event ) ) {
			return;
		}

		// Ctrl+up moves focus to the current tab
		if ( event.ctrlKey &amp;&amp; event.keyCode === $.ui.keyCode.UP ) {
			event.preventDefault();
			this.active.focus();
		}
	},

	// Alt+page up/down moves focus to the previous/next tab (and activates)
	_handlePageNav: function( event ) {
		if ( event.altKey &amp;&amp; event.keyCode === $.ui.keyCode.PAGE_UP ) {
			this._activate( this._focusNextTab( this.options.active - 1, false ) );
			return true;
		}
		if ( event.altKey &amp;&amp; event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
			this._activate( this._focusNextTab( this.options.active + 1, true ) );
			return true;
		}
	},

	_findNextTab: function( index, goingForward ) {
		var lastTabIndex = this.tabs.length - 1;

		function constrain() {
			if ( index &gt; lastTabIndex ) {
				index = 0;
			}
			if ( index &lt; 0 ) {
				index = lastTabIndex;
			}
			return index;
		}

		while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
			index = goingForward ? index + 1 : index - 1;
		}

		return index;
	},

	_focusNextTab: function( index, goingForward ) {
		index = this._findNextTab( index, goingForward );
		this.tabs.eq( index ).focus();
		return index;
	},

	_setOption: function( key, value ) {
		if ( key === &quot;active&quot; ) {
			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === &quot;disabled&quot; ) {
			// don&#x27;t use the widget factory&#x27;s disabled handling
			this._setupDisabled( value );
			return;
		}

		this._super( key, value);

		if ( key === &quot;collapsible&quot; ) {
			this.element.toggleClass( &quot;ui-tabs-collapsible&quot;, value );
			// Setting collapsible: false while collapsed; open first panel
			if ( !value &amp;&amp; this.options.active === false ) {
				this._activate( 0 );
			}
		}

		if ( key === &quot;event&quot; ) {
			this._setupEvents( value );
		}

		if ( key === &quot;heightStyle&quot; ) {
			this._setupHeightStyle( value );
		}
	},

	_tabId: function( tab ) {
		return tab.attr( &quot;aria-controls&quot; ) || &quot;ui-tabs-&quot; + getNextTabId();
	},

	_sanitizeSelector: function( hash ) {
		return hash ? hash.replace( /[!&quot;$%&amp;&#x27;()*+,.\/:;&lt;=&gt;?@\[\]\^&#x60;{|}~]/g, &quot;\\$&amp;&quot; ) : &quot;&quot;;
	},

	refresh: function() {
		var options = this.options,
			lis = this.tablist.children( &quot;:has(a[href])&quot; );

		// get disabled tabs from class attribute from HTML
		// this will get converted to a boolean if needed in _refresh()
		options.disabled = $.map( lis.filter( &quot;.ui-state-disabled&quot; ), function( tab ) {
			return lis.index( tab );
		});

		this._processTabs();

		// was collapsed or no tabs
		if ( options.active === false || !this.anchors.length ) {
			options.active = false;
			this.active = $();
		// was active, but active tab is gone
		} else if ( this.active.length &amp;&amp; !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {
			// all remaining tabs are disabled
			if ( this.tabs.length === options.disabled.length ) {
				options.active = false;
				this.active = $();
			// activate previous tab
			} else {
				this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
			}
		// was active, active tab still exists
		} else {
			// make sure active index is correct
			options.active = this.tabs.index( this.active );
		}

		this._refresh();
	},

	_refresh: function() {
		this._setupDisabled( this.options.disabled );
		this._setupEvents( this.options.event );
		this._setupHeightStyle( this.options.heightStyle );

		this.tabs.not( this.active ).attr({
			&quot;aria-selected&quot;: &quot;false&quot;,
			tabIndex: -1
		});
		this.panels.not( this._getPanelForTab( this.active ) )
			.hide()
			.attr({
				&quot;aria-expanded&quot;: &quot;false&quot;,
				&quot;aria-hidden&quot;: &quot;true&quot;
			});

		// Make sure one tab is in the tab order
		if ( !this.active.length ) {
			this.tabs.eq( 0 ).attr( &quot;tabIndex&quot;, 0 );
		} else {
			this.active
				.addClass( &quot;ui-tabs-active ui-state-active&quot; )
				.attr({
					&quot;aria-selected&quot;: &quot;true&quot;,
					tabIndex: 0
				});
			this._getPanelForTab( this.active )
				.show()
				.attr({
					&quot;aria-expanded&quot;: &quot;true&quot;,
					&quot;aria-hidden&quot;: &quot;false&quot;
				});
		}
	},

	_processTabs: function() {
		var that = this;

		this.tablist = this._getList()
			.addClass( &quot;ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all&quot; )
			.attr( &quot;role&quot;, &quot;tablist&quot; );

		this.tabs = this.tablist.find( &quot;&gt; li:has(a[href])&quot; )
			.addClass( &quot;ui-state-default ui-corner-top&quot; )
			.attr({
				role: &quot;tab&quot;,
				tabIndex: -1
			});

		this.anchors = this.tabs.map(function() {
				return $( &quot;a&quot;, this )[ 0 ];
			})
			.addClass( &quot;ui-tabs-anchor&quot; )
			.attr({
				role: &quot;presentation&quot;,
				tabIndex: -1
			});

		this.panels = $();

		this.anchors.each(function( i, anchor ) {
			var selector, panel, panelId,
				anchorId = $( anchor ).uniqueId().attr( &quot;id&quot; ),
				tab = $( anchor ).closest( &quot;li&quot; ),
				originalAriaControls = tab.attr( &quot;aria-controls&quot; );

			// inline tab
			if ( isLocal( anchor ) ) {
				selector = anchor.hash;
				panel = that.element.find( that._sanitizeSelector( selector ) );
			// remote tab
			} else {
				panelId = that._tabId( tab );
				selector = &quot;#&quot; + panelId;
				panel = that.element.find( selector );
				if ( !panel.length ) {
					panel = that._createPanel( panelId );
					panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
				}
				panel.attr( &quot;aria-live&quot;, &quot;polite&quot; );
			}

			if ( panel.length) {
				that.panels = that.panels.add( panel );
			}
			if ( originalAriaControls ) {
				tab.data( &quot;ui-tabs-aria-controls&quot;, originalAriaControls );
			}
			tab.attr({
				&quot;aria-controls&quot;: selector.substring( 1 ),
				&quot;aria-labelledby&quot;: anchorId
			});
			panel.attr( &quot;aria-labelledby&quot;, anchorId );
		});

		this.panels
			.addClass( &quot;ui-tabs-panel ui-widget-content ui-corner-bottom&quot; )
			.attr( &quot;role&quot;, &quot;tabpanel&quot; );
	},

	// allow overriding how to find the list for rare usage scenarios (#7715)
	_getList: function() {
		return this.element.find( &quot;ol,ul&quot; ).eq( 0 );
	},

	_createPanel: function( id ) {
		return $( &quot;&lt;div&gt;&quot; )
			.attr( &quot;id&quot;, id )
			.addClass( &quot;ui-tabs-panel ui-widget-content ui-corner-bottom&quot; )
			.data( &quot;ui-tabs-destroy&quot;, true );
	},

	_setupDisabled: function( disabled ) {
		if ( $.isArray( disabled ) ) {
			if ( !disabled.length ) {
				disabled = false;
			} else if ( disabled.length === this.anchors.length ) {
				disabled = true;
			}
		}

		// disable tabs
		for ( var i = 0, li; ( li = this.tabs[ i ] ); i++ ) {
			if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
				$( li )
					.addClass( &quot;ui-state-disabled&quot; )
					.attr( &quot;aria-disabled&quot;, &quot;true&quot; );
			} else {
				$( li )
					.removeClass( &quot;ui-state-disabled&quot; )
					.removeAttr( &quot;aria-disabled&quot; );
			}
		}

		this.options.disabled = disabled;
	},

	_setupEvents: function( event ) {
		var events = {
			click: function( event ) {
				event.preventDefault();
			}
		};
		if ( event ) {
			$.each( event.split(&quot; &quot;), function( index, eventName ) {
				events[ eventName ] = &quot;_eventHandler&quot;;
			});
		}

		this._off( this.anchors.add( this.tabs ).add( this.panels ) );
		this._on( this.anchors, events );
		this._on( this.tabs, { keydown: &quot;_tabKeydown&quot; } );
		this._on( this.panels, { keydown: &quot;_panelKeydown&quot; } );

		this._focusable( this.tabs );
		this._hoverable( this.tabs );
	},

	_setupHeightStyle: function( heightStyle ) {
		var maxHeight, overflow,
			parent = this.element.parent();

		if ( heightStyle === &quot;fill&quot; ) {
			// IE 6 treats height like minHeight, so we need to turn off overflow
			// in order to get a reliable height
			// we use the minHeight support test because we assume that only
			// browsers that don&#x27;t support minHeight will treat height as minHeight
			if ( !$.support.minHeight ) {
				overflow = parent.css( &quot;overflow&quot; );
				parent.css( &quot;overflow&quot;, &quot;hidden&quot;);
			}
			maxHeight = parent.height();
			this.element.siblings( &quot;:visible&quot; ).each(function() {
				var elem = $( this ),
					position = elem.css( &quot;position&quot; );

				if ( position === &quot;absolute&quot; || position === &quot;fixed&quot; ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			});
			if ( overflow ) {
				parent.css( &quot;overflow&quot;, overflow );
			}

			this.element.children().not( this.panels ).each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.panels.each(function() {
				$( this ).height( Math.max( 0, maxHeight -
					$( this ).innerHeight() + $( this ).height() ) );
			})
			.css( &quot;overflow&quot;, &quot;auto&quot; );
		} else if ( heightStyle === &quot;auto&quot; ) {
			maxHeight = 0;
			this.panels.each(function() {
				maxHeight = Math.max( maxHeight, $( this ).height( &quot;&quot; ).height() );
			}).height( maxHeight );
		}
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			anchor = $( event.currentTarget ),
			tab = anchor.closest( &quot;li&quot; ),
			clickedIsActive = tab[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive &amp;&amp; options.collapsible,
			toShow = collapsing ? $() : this._getPanelForTab( tab ),
			toHide = !active.length ? $() : this._getPanelForTab( active ),
			eventData = {
				oldTab: active,
				oldPanel: toHide,
				newTab: collapsing ? $() : tab,
				newPanel: toShow
			};

		event.preventDefault();

		if ( tab.hasClass( &quot;ui-state-disabled&quot; ) ||
				// tab is already loading
				tab.hasClass( &quot;ui-tabs-loading&quot; ) ||
				// can&#x27;t switch durning an animation
				this.running ||
				// click on active header, but not collapsible
				( clickedIsActive &amp;&amp; !options.collapsible ) ||
				// allow canceling activation
				( this._trigger( &quot;beforeActivate&quot;, event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.tabs.index( tab );

		this.active = clickedIsActive ? $() : tab;
		if ( this.xhr ) {
			this.xhr.abort();
		}

		if ( !toHide.length &amp;&amp; !toShow.length ) {
			$.error( &quot;jQuery UI Tabs: Mismatching fragment identifier.&quot; );
		}

		if ( toShow.length ) {
			this.load( this.tabs.index( tab ), event );
		}
		this._toggle( event, eventData );
	},

	// handles show/hide for selecting tabs
	_toggle: function( event, eventData ) {
		var that = this,
			toShow = eventData.newPanel,
			toHide = eventData.oldPanel;

		this.running = true;

		function complete() {
			that.running = false;
			that._trigger( &quot;activate&quot;, event, eventData );
		}

		function show() {
			eventData.newTab.closest( &quot;li&quot; ).addClass( &quot;ui-tabs-active ui-state-active&quot; );

			if ( toShow.length &amp;&amp; that.options.show ) {
				that._show( toShow, that.options.show, complete );
			} else {
				toShow.show();
				complete();
			}
		}

		// start out by hiding, then showing, then completing
		if ( toHide.length &amp;&amp; this.options.hide ) {
			this._hide( toHide, this.options.hide, function() {
				eventData.oldTab.closest( &quot;li&quot; ).removeClass( &quot;ui-tabs-active ui-state-active&quot; );
				show();
			});
		} else {
			eventData.oldTab.closest( &quot;li&quot; ).removeClass( &quot;ui-tabs-active ui-state-active&quot; );
			toHide.hide();
			show();
		}

		toHide.attr({
			&quot;aria-expanded&quot;: &quot;false&quot;,
			&quot;aria-hidden&quot;: &quot;true&quot;
		});
		eventData.oldTab.attr( &quot;aria-selected&quot;, &quot;false&quot; );
		// If we&#x27;re switching tabs, remove the old tab from the tab order.
		// If we&#x27;re opening from collapsed state, remove the previous tab from the tab order.
		// If we&#x27;re collapsing, then keep the collapsing tab in the tab order.
		if ( toShow.length &amp;&amp; toHide.length ) {
			eventData.oldTab.attr( &quot;tabIndex&quot;, -1 );
		} else if ( toShow.length ) {
			this.tabs.filter(function() {
				return $( this ).attr( &quot;tabIndex&quot; ) === 0;
			})
			.attr( &quot;tabIndex&quot;, -1 );
		}

		toShow.attr({
			&quot;aria-expanded&quot;: &quot;true&quot;,
			&quot;aria-hidden&quot;: &quot;false&quot;
		});
		eventData.newTab.attr({
			&quot;aria-selected&quot;: &quot;true&quot;,
			tabIndex: 0
		});
	},

	_activate: function( index ) {
		var anchor,
			active = this._findActive( index );

		// trying to activate the already active panel
		if ( active[ 0 ] === this.active[ 0 ] ) {
			return;
		}

		// trying to collapse, simulate a click on the current active header
		if ( !active.length ) {
			active = this.active;
		}

		anchor = active.find( &quot;.ui-tabs-anchor&quot; )[ 0 ];
		this._eventHandler({
			target: anchor,
			currentTarget: anchor,
			preventDefault: $.noop
		});
	},

	_findActive: function( index ) {
		return index === false ? $() : this.tabs.eq( index );
	},

	_getIndex: function( index ) {
		// meta-function to give users option to provide a href string instead of a numerical index.
		if ( typeof index === &quot;string&quot; ) {
			index = this.anchors.index( this.anchors.filter( &quot;[href$=&#x27;&quot; + index + &quot;&#x27;]&quot; ) );
		}

		return index;
	},

	_destroy: function() {
		if ( this.xhr ) {
			this.xhr.abort();
		}

		this.element.removeClass( &quot;ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible&quot; );

		this.tablist
			.removeClass( &quot;ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all&quot; )
			.removeAttr( &quot;role&quot; );

		this.anchors
			.removeClass( &quot;ui-tabs-anchor&quot; )
			.removeAttr( &quot;role&quot; )
			.removeAttr( &quot;tabIndex&quot; )
			.removeData( &quot;href.tabs&quot; )
			.removeData( &quot;load.tabs&quot; )
			.removeUniqueId();

		this.tabs.add( this.panels ).each(function() {
			if ( $.data( this, &quot;ui-tabs-destroy&quot; ) ) {
				$( this ).remove();
			} else {
				$( this )
					.removeClass( &quot;ui-state-default ui-state-active ui-state-disabled &quot; +
						&quot;ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel&quot; )
					.removeAttr( &quot;tabIndex&quot; )
					.removeAttr( &quot;aria-live&quot; )
					.removeAttr( &quot;aria-busy&quot; )
					.removeAttr( &quot;aria-selected&quot; )
					.removeAttr( &quot;aria-labelledby&quot; )
					.removeAttr( &quot;aria-hidden&quot; )
					.removeAttr( &quot;aria-expanded&quot; )
					.removeAttr( &quot;role&quot; );
			}
		});

		this.tabs.each(function() {
			var li = $( this ),
				prev = li.data( &quot;ui-tabs-aria-controls&quot; );
			if ( prev ) {
				li.attr( &quot;aria-controls&quot;, prev );
			} else {
				li.removeAttr( &quot;aria-controls&quot; );
			}
		});

		if ( this.options.heightStyle !== &quot;content&quot; ) {
			this.panels.css( &quot;height&quot;, &quot;&quot; );
		}
	},

	enable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === false ) {
			return;
		}

		if ( index === undefined ) {
			disabled = false;
		} else {
			index = this._getIndex( index );
			if ( $.isArray( disabled ) ) {
				disabled = $.map( disabled, function( num ) {
					return num !== index ? num : null;
				});
			} else {
				disabled = $.map( this.tabs, function( li, num ) {
					return num !== index ? num : null;
				});
			}
		}
		this._setupDisabled( disabled );
	},

	disable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === true ) {
			return;
		}

		if ( index === undefined ) {
			disabled = true;
		} else {
			index = this._getIndex( index );
			if ( $.inArray( index, disabled ) !== -1 ) {
				return;
			}
			if ( $.isArray( disabled ) ) {
				disabled = $.merge( [ index ], disabled ).sort();
			} else {
				disabled = [ index ];
			}
		}
		this._setupDisabled( disabled );
	},

	load: function( index, event ) {
		index = this._getIndex( index );
		var that = this,
			tab = this.tabs.eq( index ),
			anchor = tab.find( &quot;.ui-tabs-anchor&quot; ),
			panel = this._getPanelForTab( tab ),
			eventData = {
				tab: tab,
				panel: panel
			};

		// not remote
		if ( isLocal( anchor[ 0 ] ) ) {
			return;
		}

		this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );

		// support: jQuery &lt;1.8
		// jQuery &lt;1.8 returns false if the request is canceled in beforeSend,
		// but as of 1.8, $.ajax() always returns a jqXHR object.
		if ( this.xhr &amp;&amp; this.xhr.statusText !== &quot;canceled&quot; ) {
			tab.addClass( &quot;ui-tabs-loading&quot; );
			panel.attr( &quot;aria-busy&quot;, &quot;true&quot; );

			this.xhr
				.success(function( response ) {
					// support: jQuery &lt;1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						panel.html( response );
						that._trigger( &quot;load&quot;, event, eventData );
					}, 1 );
				})
				.complete(function( jqXHR, status ) {
					// support: jQuery &lt;1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						if ( status === &quot;abort&quot; ) {
							that.panels.stop( false, true );
						}

						tab.removeClass( &quot;ui-tabs-loading&quot; );
						panel.removeAttr( &quot;aria-busy&quot; );

						if ( jqXHR === that.xhr ) {
							delete that.xhr;
						}
					}, 1 );
				});
		}
	},

	// TODO: Remove this function in 1.10 when ajaxOptions is removed
	_ajaxSettings: function( anchor, event, eventData ) {
		var that = this;
		return {
			url: anchor.attr( &quot;href&quot; ),
			beforeSend: function( jqXHR, settings ) {
				return that._trigger( &quot;beforeLoad&quot;, event,
					$.extend( { jqXHR : jqXHR, ajaxSettings: settings }, eventData ) );
			}
		};
	},

	_getPanelForTab: function( tab ) {
		var id = $( tab ).attr( &quot;aria-controls&quot; );
		return this.element.find( this._sanitizeSelector( &quot;#&quot; + id ) );
	}
});

// DEPRECATED
if ( $.uiBackCompat !== false ) {

	// helper method for a lot of the back compat extensions
	$.ui.tabs.prototype._ui = function( tab, panel ) {
		return {
			tab: tab,
			panel: panel,
			index: this.anchors.index( tab )
		};
	};

	// url method
	$.widget( &quot;ui.tabs&quot;, $.ui.tabs, {
		url: function( index, url ) {
			this.anchors.eq( index ).attr( &quot;href&quot;, url );
		}
	});

	// TODO: Remove _ajaxSettings() method when removing this extension
	// ajaxOptions and cache options
	$.widget( &quot;ui.tabs&quot;, $.ui.tabs, {
		options: {
			ajaxOptions: null,
			cache: false
		},

		_create: function() {
			this._super();

			var that = this;

			this._on({ tabsbeforeload: function( event, ui ) {
				// tab is already cached
				if ( $.data( ui.tab[ 0 ], &quot;cache.tabs&quot; ) ) {
					event.preventDefault();
					return;
				}

				ui.jqXHR.success(function() {
					if ( that.options.cache ) {
						$.data( ui.tab[ 0 ], &quot;cache.tabs&quot;, true );
					}
				});
			}});
		},

		_ajaxSettings: function( anchor, event, ui ) {
			var ajaxOptions = this.options.ajaxOptions;
			return $.extend( {}, ajaxOptions, {
				error: function( xhr, status ) {
					try {
						// Passing index avoid a race condition when this method is
						// called after the user has selected another tab.
						// Pass the anchor that initiated this request allows
						// loadError to manipulate the tab content panel via $(a.hash)
						ajaxOptions.error(
							xhr, status, ui.tab.closest( &quot;li&quot; ).index(), ui.tab[ 0 ] );
					}
					catch ( error ) {}
				}
			}, this._superApply( arguments ) );
		},

		_setOption: function( key, value ) {
			// reset cache if switching from cached to not cached
			if ( key === &quot;cache&quot; &amp;&amp; value === false ) {
				this.anchors.removeData( &quot;cache.tabs&quot; );
			}
			this._super( key, value );
		},

		_destroy: function() {
			this.anchors.removeData( &quot;cache.tabs&quot; );
			this._super();
		},

		url: function( index ){
			this.anchors.eq( index ).removeData( &quot;cache.tabs&quot; );
			this._superApply( arguments );
		}
	});

	// abort method
	$.widget( &quot;ui.tabs&quot;, $.ui.tabs, {
		abort: function() {
			if ( this.xhr ) {
				this.xhr.abort();
			}
		}
	});

	// spinner
	$.widget( &quot;ui.tabs&quot;, $.ui.tabs, {
		options: {
			spinner: &quot;&lt;em&gt;Loading&amp;#8230;&lt;/em&gt;&quot;
		},
		_create: function() {
			this._super();
			this._on({
				tabsbeforeload: function( event, ui ) {
					// Don&#x27;t react to nested tabs or tabs that don&#x27;t use a spinner
					if ( event.target !== this.element[ 0 ] ||
							!this.options.spinner ) {
						return;
					}

					var span = ui.tab.find( &quot;span&quot; ),
						html = span.html();
					span.html( this.options.spinner );
					ui.jqXHR.complete(function() {
						span.html( html );
					});
				}
			});
		}
	});

	// enable/disable events
	$.widget( &quot;ui.tabs&quot;, $.ui.tabs, {
		options: {
			enable: null,
			disable: null
		},

		enable: function( index ) {
			var options = this.options,
				trigger;

			if ( index &amp;&amp; options.disabled === true ||
					( $.isArray( options.disabled ) &amp;&amp; $.inArray( index, options.disabled ) !== -1 ) ) {
				trigger = true;
			}

			this._superApply( arguments );

			if ( trigger ) {
				this._trigger( &quot;enable&quot;, null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
			}
		},

		disable: function( index ) {
			var options = this.options,
				trigger;

			if ( index &amp;&amp; options.disabled === false ||
					( $.isArray( options.disabled ) &amp;&amp; $.inArray( index, options.disabled ) === -1 ) ) {
				trigger = true;
			}

			this._superApply( arguments );

			if ( trigger ) {
				this._trigger( &quot;disable&quot;, null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
			}
		}
	});

	// add/remove methods and events
	$.widget( &quot;ui.tabs&quot;, $.ui.tabs, {
		options: {
			add: null,
			remove: null,
			tabTemplate: &quot;&lt;li&gt;&lt;a href=&#x27;#{href}&#x27;&gt;&lt;span&gt;#{label}&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&quot;
		},

		add: function( url, label, index ) {
			if ( index === undefined ) {
				index = this.anchors.length;
			}

			var doInsertAfter, panel,
				options = this.options,
				li = $( options.tabTemplate
					.replace( /#\{href\}/g, url )
					.replace( /#\{label\}/g, label ) ),
				id = !url.indexOf( &quot;#&quot; ) ?
					url.replace( &quot;#&quot;, &quot;&quot; ) :
					this._tabId( li );

			li.addClass( &quot;ui-state-default ui-corner-top&quot; ).data( &quot;ui-tabs-destroy&quot;, true );
			li.attr( &quot;aria-controls&quot;, id );

			doInsertAfter = index &gt;= this.tabs.length;

			// try to find an existing element before creating a new one
			panel = this.element.find( &quot;#&quot; + id );
			if ( !panel.length ) {
				panel = this._createPanel( id );
				if ( doInsertAfter ) {
					if ( index &gt; 0 ) {
						panel.insertAfter( this.panels.eq( -1 ) );
					} else {
						panel.appendTo( this.element );
					}
				} else {
					panel.insertBefore( this.panels[ index ] );
				}
			}
			panel.addClass( &quot;ui-tabs-panel ui-widget-content ui-corner-bottom&quot; ).hide();

			if ( doInsertAfter ) {
				li.appendTo( this.tablist );
			} else {
				li.insertBefore( this.tabs[ index ] );
			}

			options.disabled = $.map( options.disabled, function( n ) {
				return n &gt;= index ? ++n : n;
			});

			this.refresh();
			if ( this.tabs.length === 1 &amp;&amp; options.active === false ) {
				this.option( &quot;active&quot;, 0 );
			}

			this._trigger( &quot;add&quot;, null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
			return this;
		},

		remove: function( index ) {
			index = this._getIndex( index );
			var options = this.options,
				tab = this.tabs.eq( index ).remove(),
				panel = this._getPanelForTab( tab ).remove();

			// If selected tab was removed focus tab to the right or
			// in case the last tab was removed the tab to the left.
			// We check for more than 2 tabs, because if there are only 2,
			// then when we remove this tab, there will only be one tab left
			// so we don&#x27;t need to detect which tab to activate.
			if ( tab.hasClass( &quot;ui-tabs-active&quot; ) &amp;&amp; this.anchors.length &gt; 2 ) {
				this._activate( index + ( index + 1 &lt; this.anchors.length ? 1 : -1 ) );
			}

			options.disabled = $.map(
				$.grep( options.disabled, function( n ) {
					return n !== index;
				}),
				function( n ) {
					return n &gt;= index ? --n : n;
				});

			this.refresh();

			this._trigger( &quot;remove&quot;, null, this._ui( tab.find( &quot;a&quot; )[ 0 ], panel[ 0 ] ) );
			return this;
		}
	});

	// length method
	$.widget( &quot;ui.tabs&quot;, $.ui.tabs, {
		length: function() {
			return this.anchors.length;
		}
	});

	// panel ids (idPrefix option + title attribute)
	$.widget( &quot;ui.tabs&quot;, $.ui.tabs, {
		options: {
			idPrefix: &quot;ui-tabs-&quot;
		},

		_tabId: function( tab ) {
			var a = tab.is( &quot;li&quot; ) ? tab.find( &quot;a[href]&quot; ) : tab;
			a = a[0];
			return $( a ).closest( &quot;li&quot; ).attr( &quot;aria-controls&quot; ) ||
				a.title &amp;&amp; a.title.replace( /\s/g, &quot;_&quot; ).replace( /[^\w\u00c0-\uFFFF\-]/g, &quot;&quot; ) ||
				this.options.idPrefix + getNextTabId();
		}
	});

	// _createPanel method
	$.widget( &quot;ui.tabs&quot;, $.ui.tabs, {
		options: {
			panelTemplate: &quot;&lt;div&gt;&lt;/div&gt;&quot;
		},

		_createPanel: function( id ) {
			return $( this.options.panelTemplate )
				.attr( &quot;id&quot;, id )
				.addClass( &quot;ui-tabs-panel ui-widget-content ui-corner-bottom&quot; )
				.data( &quot;ui-tabs-destroy&quot;, true );
		}
	});

	// selected option
	$.widget( &quot;ui.tabs&quot;, $.ui.tabs, {
		_create: function() {
			var options = this.options;
			if ( options.active === null &amp;&amp; options.selected !== undefined ) {
				options.active = options.selected === -1 ? false : options.selected;
			}
			this._super();
			options.selected = options.active;
			if ( options.selected === false ) {
				options.selected = -1;
			}
		},

		_setOption: function( key, value ) {
			if ( key !== &quot;selected&quot; ) {
				return this._super( key, value );
			}

			var options = this.options;
			this._super( &quot;active&quot;, value === -1 ? false : value );
			options.selected = options.active;
			if ( options.selected === false ) {
				options.selected = -1;
			}
		},

		_eventHandler: function() {
			this._superApply( arguments );
			this.options.selected = this.options.active;
			if ( this.options.selected === false ) {
				this.options.selected = -1;
			}
		}
	});

	// show and select event
	$.widget( &quot;ui.tabs&quot;, $.ui.tabs, {
		options: {
			show: null,
			select: null
		},
		_create: function() {
			this._super();
			if ( this.options.active !== false ) {
				this._trigger( &quot;show&quot;, null, this._ui(
					this.active.find( &quot;.ui-tabs-anchor&quot; )[ 0 ],
					this._getPanelForTab( this.active )[ 0 ] ) );
			}
		},
		_trigger: function( type, event, data ) {
			var ret = this._superApply( arguments );
			if ( !ret ) {
				return false;
			}
			if ( type === &quot;beforeActivate&quot; &amp;&amp; data.newTab.length ) {
				ret = this._super( &quot;select&quot;, event, {
					tab: data.newTab.find( &quot;.ui-tabs-anchor&quot; )[ 0],
					panel: data.newPanel[ 0 ],
					index: data.newTab.closest( &quot;li&quot; ).index()
				});
			} else if ( type === &quot;activate&quot; &amp;&amp; data.newTab.length ) {
				ret = this._super( &quot;show&quot;, event, {
					tab: data.newTab.find( &quot;.ui-tabs-anchor&quot; )[ 0 ],
					panel: data.newPanel[ 0 ],
					index: data.newTab.closest( &quot;li&quot; ).index()
				});
			}
			return ret;
		}
	});

	// select method
	$.widget( &quot;ui.tabs&quot;, $.ui.tabs, {
		select: function( index ) {
			index = this._getIndex( index );
			if ( index === -1 ) {
				if ( this.options.collapsible &amp;&amp; this.options.selected !== -1 ) {
					index = this.options.selected;
				} else {
					return;
				}
			}
			this.anchors.eq( index ).trigger( this.options.event + this.eventNamespace );
		}
	});

	// cookie option
	(function() {

	var listId = 0;

	$.widget( &quot;ui.tabs&quot;, $.ui.tabs, {
		options: {
			cookie: null // e.g. { expires: 7, path: &#x27;/&#x27;, domain: &#x27;jquery.com&#x27;, secure: true }
		},
		_create: function() {
			var options = this.options,
				active;
			if ( options.active == null &amp;&amp; options.cookie ) {
				active = parseInt( this._cookie(), 10 );
				if ( active === -1 ) {
					active = false;
				}
				options.active = active;
			}
			this._super();
		},
		_cookie: function( active ) {
			var cookie = [ this.cookie ||
				( this.cookie = this.options.cookie.name || &quot;ui-tabs-&quot; + (++listId) ) ];
			if ( arguments.length ) {
				cookie.push( active === false ? -1 : active );
				cookie.push( this.options.cookie );
			}
			return $.cookie.apply( null, cookie );
		},
		_refresh: function() {
			this._super();
			if ( this.options.cookie ) {
				this._cookie( this.options.active, this.options.cookie );
			}
		},
		_eventHandler: function() {
			this._superApply( arguments );
			if ( this.options.cookie ) {
				this._cookie( this.options.active, this.options.cookie );
			}
		},
		_destroy: function() {
			this._super();
			if ( this.options.cookie ) {
				this._cookie( null, this.options.cookie );
			}
		}
	});

	})();

	// load event
	$.widget( &quot;ui.tabs&quot;, $.ui.tabs, {
		_trigger: function( type, event, data ) {
			var _data = $.extend( {}, data );
			if ( type === &quot;load&quot; ) {
				_data.panel = _data.panel[ 0 ];
				_data.tab = _data.tab.find( &quot;.ui-tabs-anchor&quot; )[ 0 ];
			}
			return this._super( type, event, _data );
		}
	});

	// fx option
	// The new animation options (show, hide) conflict with the old show callback.
	// The old fx option wins over show/hide anyway (always favor back-compat).
	// If a user wants to use the new animation API, they must give up the old API.
	$.widget( &quot;ui.tabs&quot;, $.ui.tabs, {
		options: {
			fx: null // e.g. { height: &quot;toggle&quot;, opacity: &quot;toggle&quot;, duration: 200 }
		},

		_getFx: function() {
			var hide, show,
				fx = this.options.fx;

			if ( fx ) {
				if ( $.isArray( fx ) ) {
					hide = fx[ 0 ];
					show = fx[ 1 ];
				} else {
					hide = show = fx;
				}
			}

			return fx ? { show: show, hide: hide } : null;
		},

		_toggle: function( event, eventData ) {
			var that = this,
				toShow = eventData.newPanel,
				toHide = eventData.oldPanel,
				fx = this._getFx();

			if ( !fx ) {
				return this._super( event, eventData );
			}

			that.running = true;

			function complete() {
				that.running = false;
				that._trigger( &quot;activate&quot;, event, eventData );
			}

			function show() {
				eventData.newTab.closest( &quot;li&quot; ).addClass( &quot;ui-tabs-active ui-state-active&quot; );

				if ( toShow.length &amp;&amp; fx.show ) {
					toShow
						.animate( fx.show, fx.show.duration, function() {
							complete();
						});
				} else {
					toShow.show();
					complete();
				}
			}

			// start out by hiding, then showing, then completing
			if ( toHide.length &amp;&amp; fx.hide ) {
				toHide.animate( fx.hide, fx.hide.duration, function() {
					eventData.oldTab.closest( &quot;li&quot; ).removeClass( &quot;ui-tabs-active ui-state-active&quot; );
					show();
				});
			} else {
				eventData.oldTab.closest( &quot;li&quot; ).removeClass( &quot;ui-tabs-active ui-state-active&quot; );
				toHide.hide();
				show();
			}
		}
	});
}

})( jQuery );

(function( $ ) {

var increments = 0;

function addDescribedBy( elem, id ) {
	var describedby = (elem.attr( &quot;aria-describedby&quot; ) || &quot;&quot;).split( /\s+/ );
	describedby.push( id );
	elem
		.data( &quot;ui-tooltip-id&quot;, id )
		.attr( &quot;aria-describedby&quot;, $.trim( describedby.join( &quot; &quot; ) ) );
}

function removeDescribedBy( elem ) {
	var id = elem.data( &quot;ui-tooltip-id&quot; ),
		describedby = (elem.attr( &quot;aria-describedby&quot; ) || &quot;&quot;).split( /\s+/ ),
		index = $.inArray( id, describedby );
	if ( index !== -1 ) {
		describedby.splice( index, 1 );
	}

	elem.removeData( &quot;ui-tooltip-id&quot; );
	describedby = $.trim( describedby.join( &quot; &quot; ) );
	if ( describedby ) {
		elem.attr( &quot;aria-describedby&quot;, describedby );
	} else {
		elem.removeAttr( &quot;aria-describedby&quot; );
	}
}

$.widget( &quot;ui.tooltip&quot;, {
	version: &quot;1.9.1&quot;,
	options: {
		content: function() {
			return $( this ).attr( &quot;title&quot; );
		},
		hide: true,
		// Disabled elements have inconsistent behavior across browsers (#8661)
		items: &quot;[title]:not([disabled])&quot;,
		position: {
			my: &quot;left top+15&quot;,
			at: &quot;left bottom&quot;,
			collision: &quot;flipfit flipfit&quot;
		},
		show: true,
		tooltipClass: null,
		track: false,

		// callbacks
		close: null,
		open: null
	},

	_create: function() {
		this._on({
			mouseover: &quot;open&quot;,
			focusin: &quot;open&quot;
		});

		// IDs of generated tooltips, needed for destroy
		this.tooltips = {};
		// IDs of parent tooltips where we removed the title attribute
		this.parents = {};

		if ( this.options.disabled ) {
			this._disable();
		}
	},

	_setOption: function( key, value ) {
		var that = this;

		if ( key === &quot;disabled&quot; ) {
			this[ value ? &quot;_disable&quot; : &quot;_enable&quot; ]();
			this.options[ key ] = value;
			// disable element style changes
			return;
		}

		this._super( key, value );

		if ( key === &quot;content&quot; ) {
			$.each( this.tooltips, function( id, element ) {
				that._updateContent( element );
			});
		}
	},

	_disable: function() {
		var that = this;

		// close open tooltips
		$.each( this.tooltips, function( id, element ) {
			var event = $.Event( &quot;blur&quot; );
			event.target = event.currentTarget = element[0];
			that.close( event, true );
		});

		// remove title attributes to prevent native tooltips
		this.element.find( this.options.items ).andSelf().each(function() {
			var element = $( this );
			if ( element.is( &quot;[title]&quot; ) ) {
				element
					.data( &quot;ui-tooltip-title&quot;, element.attr( &quot;title&quot; ) )
					.attr( &quot;title&quot;, &quot;&quot; );
			}
		});
	},

	_enable: function() {
		// restore title attributes
		this.element.find( this.options.items ).andSelf().each(function() {
			var element = $( this );
			if ( element.data( &quot;ui-tooltip-title&quot; ) ) {
				element.attr( &quot;title&quot;, element.data( &quot;ui-tooltip-title&quot; ) );
			}
		});
	},

	open: function( event ) {
		var that = this,
			target = $( event ? event.target : this.element )
				// we need closest here due to mouseover bubbling,
				// but always pointing at the same event target
				.closest( this.options.items );

		// No element to show a tooltip for
		if ( !target.length ) {
			return;
		}

		// If the tooltip is open and we&#x27;re tracking then reposition the tooltip.
		// This makes sure that a tracking tooltip doesn&#x27;t obscure a focused element
		// if the user was hovering when the element gained focused.
		if ( this.options.track &amp;&amp; target.data( &quot;ui-tooltip-id&quot; ) ) {
			this._find( target ).position( $.extend({
				of: target
			}, this.options.position ) );
			// Stop tracking (#8622)
			this._off( this.document, &quot;mousemove&quot; );
			return;
		}

		if ( target.attr( &quot;title&quot; ) ) {
			target.data( &quot;ui-tooltip-title&quot;, target.attr( &quot;title&quot; ) );
		}

		target.data( &quot;tooltip-open&quot;, true );

		// kill parent tooltips, custom or native, for hover
		if ( event &amp;&amp; event.type === &quot;mouseover&quot; ) {
			target.parents().each(function() {
				var blurEvent;
				if ( $( this ).data( &quot;tooltip-open&quot; ) ) {
					blurEvent = $.Event( &quot;blur&quot; );
					blurEvent.target = blurEvent.currentTarget = this;
					that.close( blurEvent, true );
				}
				if ( this.title ) {
					$( this ).uniqueId();
					that.parents[ this.id ] = {
						element: this,
						title: this.title
					};
					this.title = &quot;&quot;;
				}
			});
		}

		this._updateContent( target, event );
	},

	_updateContent: function( target, event ) {
		var content,
			contentOption = this.options.content,
			that = this;

		if ( typeof contentOption === &quot;string&quot; ) {
			return this._open( event, target, contentOption );
		}

		content = contentOption.call( target[0], function( response ) {
			// ignore async response if tooltip was closed already
			if ( !target.data( &quot;tooltip-open&quot; ) ) {
				return;
			}
			// IE may instantly serve a cached response for ajax requests
			// delay this call to _open so the other call to _open runs first
			that._delay(function() {
				this._open( event, target, response );
			});
		});
		if ( content ) {
			this._open( event, target, content );
		}
	},

	_open: function( event, target, content ) {
		var tooltip, events, delayedShow,
			positionOption = $.extend( {}, this.options.position );

		if ( !content ) {
			return;
		}

		// Content can be updated multiple times. If the tooltip already
		// exists, then just update the content and bail.
		tooltip = this._find( target );
		if ( tooltip.length ) {
			tooltip.find( &quot;.ui-tooltip-content&quot; ).html( content );
			return;
		}

		// if we have a title, clear it to prevent the native tooltip
		// we have to check first to avoid defining a title if none exists
		// (we don&#x27;t want to cause an element to start matching [title])
		//
		// We use removeAttr only for key events, to allow IE to export the correct
		// accessible attributes. For mouse events, set to empty string to avoid
		// native tooltip showing up (happens only when removing inside mouseover).
		if ( target.is( &quot;[title]&quot; ) ) {
			if ( event &amp;&amp; event.type === &quot;mouseover&quot; ) {
				target.attr( &quot;title&quot;, &quot;&quot; );
			} else {
				target.removeAttr( &quot;title&quot; );
			}
		}

		tooltip = this._tooltip( target );
		addDescribedBy( target, tooltip.attr( &quot;id&quot; ) );
		tooltip.find( &quot;.ui-tooltip-content&quot; ).html( content );

		function position( event ) {
			positionOption.of = event;
			if ( tooltip.is( &quot;:hidden&quot; ) ) {
				return;
			}
			tooltip.position( positionOption );
		}
		if ( this.options.track &amp;&amp; event &amp;&amp; /^mouse/.test( event.originalEvent.type ) ) {
			this._on( this.document, {
				mousemove: position
			});
			// trigger once to override element-relative positioning
			position( event );
		} else {
			tooltip.position( $.extend({
				of: target
			}, this.options.position ) );
		}

		tooltip.hide();

		this._show( tooltip, this.options.show );
		// Handle tracking tooltips that are shown with a delay (#8644). As soon
		// as the tooltip is visible, position the tooltip using the most recent
		// event.
		if ( this.options.show &amp;&amp; this.options.show.delay ) {
			delayedShow = setInterval(function() {
				if ( tooltip.is( &quot;:visible&quot; ) ) {
					position( positionOption.of );
					clearInterval( delayedShow );
				}
			}, $.fx.interval );
		}

		this._trigger( &quot;open&quot;, event, { tooltip: tooltip } );

		events = {
			keyup: function( event ) {
				if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
					var fakeEvent = $.Event(event);
					fakeEvent.currentTarget = target[0];
					this.close( fakeEvent, true );
				}
			},
			remove: function() {
				this._removeTooltip( tooltip );
			}
		};
		if ( !event || event.type === &quot;mouseover&quot; ) {
			events.mouseleave = &quot;close&quot;;
		}
		if ( !event || event.type === &quot;focusin&quot; ) {
			events.focusout = &quot;close&quot;;
		}
		this._on( target, events );
	},

	close: function( event ) {
		var that = this,
			target = $( event ? event.currentTarget : this.element ),
			tooltip = this._find( target );

		// disabling closes the tooltip, so we need to track when we&#x27;re closing
		// to avoid an infinite loop in case the tooltip becomes disabled on close
		if ( this.closing ) {
			return;
		}

		// only set title if we had one before (see comment in _open())
		if ( target.data( &quot;ui-tooltip-title&quot; ) ) {
			target.attr( &quot;title&quot;, target.data( &quot;ui-tooltip-title&quot; ) );
		}

		removeDescribedBy( target );

		tooltip.stop( true );
		this._hide( tooltip, this.options.hide, function() {
			that._removeTooltip( $( this ) );
		});

		target.removeData( &quot;tooltip-open&quot; );
		this._off( target, &quot;mouseleave focusout keyup&quot; );
		// Remove &#x27;remove&#x27; binding only on delegated targets
		if ( target[0] !== this.element[0] ) {
			this._off( target, &quot;remove&quot; );
		}
		this._off( this.document, &quot;mousemove&quot; );

		if ( event &amp;&amp; event.type === &quot;mouseleave&quot; ) {
			$.each( this.parents, function( id, parent ) {
				parent.element.title = parent.title;
				delete that.parents[ id ];
			});
		}

		this.closing = true;
		this._trigger( &quot;close&quot;, event, { tooltip: tooltip } );
		this.closing = false;
	},

	_tooltip: function( element ) {
		var id = &quot;ui-tooltip-&quot; + increments++,
			tooltip = $( &quot;&lt;div&gt;&quot; )
				.attr({
					id: id,
					role: &quot;tooltip&quot;
				})
				.addClass( &quot;ui-tooltip ui-widget ui-corner-all ui-widget-content &quot; +
					( this.options.tooltipClass || &quot;&quot; ) );
		$( &quot;&lt;div&gt;&quot; )
			.addClass( &quot;ui-tooltip-content&quot; )
			.appendTo( tooltip );
		tooltip.appendTo( this.document[0].body );
		if ( $.fn.bgiframe ) {
			tooltip.bgiframe();
		}
		this.tooltips[ id ] = element;
		return tooltip;
	},

	_find: function( target ) {
		var id = target.data( &quot;ui-tooltip-id&quot; );
		return id ? $( &quot;#&quot; + id ) : $();
	},

	_removeTooltip: function( tooltip ) {
		tooltip.remove();
		delete this.tooltips[ tooltip.attr( &quot;id&quot; ) ];
	},

	_destroy: function() {
		var that = this;

		// close open tooltips
		$.each( this.tooltips, function( id, element ) {
			// Delegate to close method to handle common cleanup
			var event = $.Event( &quot;blur&quot; );
			event.target = event.currentTarget = element[0];
			that.close( event, true );

			// Remove immediately; destroying an open tooltip doesn&#x27;t use the
			// hide animation
			$( &quot;#&quot; + id ).remove();

			// Restore the title
			if ( element.data( &quot;ui-tooltip-title&quot; ) ) {
				element.attr( &quot;title&quot;, element.data( &quot;ui-tooltip-title&quot; ) );
				element.removeData( &quot;ui-tooltip-title&quot; );
			}
		});
	}
});

}( jQuery ) );

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
