<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>jxanimate.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/animSetting.html">animSetting</a></li>
            
                <li><a href="../classes/JX.Animate.html">JX.Animate</a></li>
            
                <li><a href="../classes/JXAnimate.Audio.html">JXAnimate.Audio</a></li>
            
                <li><a href="../classes/SlideShow.html">SlideShow</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/JXAnimate.html">JXAnimate</a></li>
            
                <li><a href="../modules/JXAnimate.Animate.Demo.html">JXAnimate.Animate.Demo</a></li>
            
                <li><a href="../modules/JXAnimate.Audio.html">JXAnimate.Audio</a></li>
            
                <li><a href="../modules/SlideShow.html">SlideShow</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: jxanimate.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">

/* ===========================================================================
 * etamina == animate
 *
 * @description
 * A CSS animation Engine and Library
 *
 * @author minren 
 * ===========================================================================
 * 
 */

/**
 * @description JX.Animate主文件
 * @module JXAnimate
 */

Jx().$package(&quot;JXAnimate&quot;, function(J){

    var $Audio;

    var etamina = (function () {

        var core = {
                id: &quot;etamina&quot;,
                name: &quot;etamina&quot;,
                description: &quot;A CSS animation Engine and Library&quot;,
                version: &quot;1.0&quot;,

                prefix: &quot;&quot;,
                prefixJS: &quot;&quot;,

                elems: null,

                format: {},
                helper: {},
                effects: {},

                debug: true,

                originalCssClasses: {},
                //保存在element上应用的动画class名称，用于在动画后删除相关的css
                AnimatingClasses: {},
                keyframeRules:{},
                doNotDeleteKeyframes:{}, //不需要删除的动画名称，一般是静态CSS文件中的动画。
                //存放bool值，表示元素是否正在播放动画。
                animElementList: [],
                //保存每个元素在动画播放完毕之后的回调函数,以元素id为索引
                animCallbackList:[],
                //保存domino效果中每一个合并元素组。
                donimoElementGroups:{},

                /*
                 * Returns array of HTML elements by string, HTML elements or string array.
                 */
                getHTMLelements: function (params) {
                    var elems = [],
                        each = function (arr, func) {
                            Array.prototype.forEach.apply(arr, [func]);
                        },
                        push = function (v) {
                            elems.push(v);
                        },
                        lookup = function (query) {
                            if (typeof query != &#x27;string&#x27;) return [];
                            var result = document.getElementById(query);
                            return result ? [result] : document.querySelectorAll(query);
                        };

                    if (typeof params === &quot;string&quot;) {
                        each(lookup(params), push);
                    }
                    else if (params.length === undefined) {
                        elems.push(params); // myElem1
                    }
                    else {
                        each(params, function(param) {
                            if (param.nodeType &amp;&amp; param.nodeType !== 3) {
                                elems.push(param);
                            }
                            else {
                                each(lookup(param), push);
                            }
                        });
                    }
                    each(elems,function(elem){
                        if(!elem.id || elem.id == &#x27;&#x27; || elem.id === undefined){
                            elem.id = elem.type + &#x27;_&#x27; + (new Date()).getTime();
                        }
                    });

                    return elems;
                },
                /*
                 * Set browser css &amp; JS prefix
                 */
                initPrefix: function () {
                    var el = document.createElement(&quot;div&quot;);

                    // Safari 4+, iOS Safari 3.2+, Chrome 2+, and Android 2.1+
                    if (&quot;webkitAnimation&quot; in el.style) {
                        this.prefix = &quot;-webkit-&quot;;
                        this.prefixJS = &quot;webkit&quot;;
                    }
                    // Firefox 5+
                    else if (&quot;MozAnimation&quot; in el.style) {
                        this.prefix = &quot;-moz-&quot;;
                        this.prefixJS = &quot;Moz&quot;;
                    }
                    // Internet Explorer 10+
                    else if (&quot;msAnimation&quot; in el.style) {
                        this.prefix = &quot;-ms-&quot;;
                        this.prefixJS = &quot;MS&quot;;
                    }
                    // Opera 12+
                    else if (&quot;OAnimation&quot; in el.style || &quot;OTransform&quot; in el.style) {
                        this.prefix = &quot;-o-&quot;;
                        this.prefixJS = &quot;O&quot;;
                    }
                    else {
                        this.prefix = &quot;&quot;;
                        this.prefixJS = &quot;&quot;;
                    }

                    if (this.debug) {
                        console.log(&quot;prefix=&quot; + this.prefix, &quot;prefixJS=&quot; + this.prefixJS);
                    }

                    return;
                },

                /*
                 * Get the document height
                 */
                docHeight: function () {
                    var D = document;

                    return Math.max(
                        Math.max(D.body.scrollHeight, D.documentElement.scrollHeight), 
                        Math.max(D.body.offsetHeight, D.documentElement.offsetHeight), 
                        Math.max(D.body.clientHeight, D.documentElement.clientHeight)
                        );
                },


                /*
                 * Insert CSS keyframe rule
                 */
                insertCSS: function (rule) {
                    var sheets = document.styleSheets;

                    if (sheets &amp;&amp; sheets.length) {
                        for (var i = sheets.length - 1; i &gt;= 0; i--) {
                            try {
                                sheets[i].insertRule(rule, 0);
                                break;
                            }
                            catch (ex) {
                                console.warn(ex.message, rule);
                            }
                        };
                    }
                    else {
                        var style = document.createElement(&quot;style&quot;);
                        style.innerHTML = rule;
                        document.head.appendChild(style);
                    }

                    return;
                },

                /*
                 * Delete CSS keyframe rule
                 */
                deleteCSS: function (ruleName) {
                    //TODO:当HTML中没有Style节点时，会出现Bug。
                    var cssrules = (document.all) ? &quot;rules&quot; : &quot;cssRules&quot;,
                        i,sheets = document.styleSheets;
                    if (sheets &amp;&amp; sheets.length) {
                        sheets:for (var j = sheets.length - 1; j &gt;= 0; j--) {
                            if(sheets[j][cssrules] &amp;&amp;
                                sheets[j][cssrules].length&gt;0){
                                rules:for (i = 0; i &lt; sheets[j][cssrules].length; i += 1) {
                                    var rule = sheets[j][cssrules][i];
                                    if (rule.name === ruleName || rule.selectorText === &#x27;.&#x27;+ruleName) {
                                        sheets[j].deleteRule(i);
                                        if (this.debug) {
                                            console.log(&quot;Deleted keyframe: &quot; + ruleName);
                                        }
                                        break sheets;
                                        break rules;
                                    }                            
                                }
                            }
                        }
                    }

                    return;
                },

                /*
                 * 动画结束时的统一回调参数。
                 * Clear animation settings
                 */
                clearAnimation: function (elem,evt) {
                    if(this.debug){
                        console.info(&quot;_clearAnimation&quot;, elem, evt.srcElement.id, evt.animationName, evt.elapsedTime);
                    }
                    etamina.animElementList[elem.id] = false;

                    //恢复元素原有的class属性。
                    etamina.restoreCssClass(elem);
                    
                    //结束时删除 动画class。 动画class也要记录。
                    var classname = etamina.popAnimateClassName(elem.id);
                    //etamina.deleteCSS(classname);


                    // 删除关键帧的css。
                    if(evt.animationName in etamina.doNotDeleteKeyframes){

                    }
                    else{
                        //etamina.deleteCSS(evt.animationName);
                    }

                    var callbackObj = etamina.animCallbackList[elem.id];

                    if(callbackObj &amp;&amp; callbackObj.hasCallback){
                        //向回调中传入动画元素和事件参数。
                        callbackObj.params = J.extend(
                            {
                                elem : elem,
                                event : evt
                            },
                            callbackObj.params);

                        callbackObj.method(callbackObj.params);
                    }

                    return;
                },
                onDonimoGroupAnimationEnd:function(evt) {
                    if(this.debug){
                        console.info(&quot;_onDonimoGroupAnimationEnd&quot;, this, evt.srcElement.id, evt.animationName, evt.elapsedTime);
                    }
                    var group = etamina.donimoElementGroups[this.id],
                        length;
                    if(J.isArray(group)){
                        length = group.length;
                        for (var i =0; i &lt; length; i++) {
                            etamina.clearAnimation(group[i],evt);
                        };

                    }
                    delete etamina.donimoElementGroups[this.id];
                },
                onAnimationEnd:function(evt){
                    etamina.clearAnimation(this,evt);
                },

                /*
                 * initialize animation playing param
                 */
                initPlayParam: function(params,animType){

                    var animType = animType || &#x27;Any&#x27;,
                        params = params || {};

                    params.animType = params.animType||animType;                
                    params.delay = params.delay || &#x27;0ms&#x27;;
                    params.duration = params.duration || &#x27;1s&#x27;;
                    params.timing = params.timing || &#x27;linear&#x27;;
                    params.iteration = params.iteration || &#x27;1&#x27;;
                    params.direction = params.direction || &#x27;normal&#x27;;
                    params.playstate = params.playstate || &quot;running&quot;;

                    params.perspective = params.perspective || &quot;1000px&quot;;
                    params.perspectiveOrigin = params.perspectiveOrigin || &quot;50% 50%&quot;;
                    params.backfaceVisibility = params.backfaceVisibility || &quot;visible&quot;;
                    return params;
                },


                /*
                 *生成用于在element上应用动画效果class css
                 *在此处应用多米诺效果
                 */
                getAnimationClassRule: function(params,animSetting){
                    var 
                    className = params.animType + &#x27;-&#x27; +(new Date()).getTime() + &quot;-&quot; + Math.floor(Math.random() * 1000),
                    css=&#x27;&#x27;,domino,dominoDelay=0,newDelay;

                    if(params.toDelete &amp;&amp; params.toDelete.length&gt;0){
                        for(var i=0,len = params.toDelete.length;i&lt;len;i++)
                        {
                            var attr = params.toDelete[i];
                            delete params[attr];
                        }
                    }
                    
                    newDelay = etamina.format.fromTime(params.delay);

                    if(animSetting.domino){
                        domino = etamina.format.fromTime(animSetting.domino);
                        dominoDelay = domino * animSetting.index;
                        newDelay+= dominoDelay;
                    }

                    newDelay = etamina.format.toMilliSecond(newDelay);

                    css += &#x27;.&#x27;+className+&#x27;{&#x27;+&#x27;\n&#x27;;

                    css += &#x27;\t&#x27;+etamina.prefix+&#x27;animation-name:&#x27;+params.name+&#x27;;\n&#x27;;
                    if (&#x27;delay&#x27; in params) {
                        css += &#x27;\t&#x27;+etamina.prefix+&#x27;animation-delay:&#x27;+newDelay+&#x27;;\n&#x27;;
                    }
                    if (&#x27;duration&#x27; in params) {
                        css += &#x27;\t&#x27;+etamina.prefix+&#x27;animation-duration:&#x27;+params.duration+&#x27;;\n&#x27;;
                    }
                    if (&#x27;timing&#x27;) {
                        css += &#x27;\t&#x27;+etamina.prefix+&#x27;animation-timing-function:&#x27;+params.timing+&#x27;;\n&#x27;;
                    }
                    if (&#x27;iteration&#x27; in params) {
                        css += &#x27;\t&#x27;+etamina.prefix+&#x27;animation-iteration-count:&#x27;+params.iteration+&#x27;;\n&#x27;;
                    }
                    if (&#x27;direction&#x27; in params) {
                        css += &#x27;\t&#x27;+etamina.prefix+&#x27;animation-direction:&#x27;+params.direction+&#x27;;\n&#x27;;
                    }
                    if(&#x27;perspective&#x27; in params){
                        css += &#x27;\t&#x27;+etamina.prefix+&#x27;perspective:&#x27;+params.perspective+&#x27;;\n&#x27;;
                    }
                    if(&#x27;perspectiveOrigin&#x27; in params){
                        css += &#x27;\t&#x27;+etamina.prefix+&#x27;perspective-origin:&#x27;+params.perspectiveOrigin+&#x27;;\n&#x27;;
                    }
                    if(&#x27;backfaceVisibility&#x27; in params){
                        css += &#x27;\t&#x27;+etamina.prefix+&#x27;backface-visibility:&#x27;+params.backfaceVisibility+&#x27;;\n&#x27;;
                    }

                    css += &#x27;}\n&#x27; ;

                    return {
                        name:className,
                        css:css
                    };
                 },

                saveCssClass : function(elem){
                    if(elem &amp;&amp; elem.id &amp;&amp; elem.id!=&#x27;&#x27;){
                        this.originalCssClasses[elem.id] = elem.className;
                    }
                 },
                restoreCssClass : function(elem){
                    if(elem &amp;&amp; elem.id &amp;&amp; elem.id!=&#x27;&#x27;){
                        elem.className = this.originalCssClasses[elem.id];
                        if(etamina.debug){
                            console.log(&#x27;restor #&#x27;+elem.id+&#x27; to &#x27;+elem.className+&#x27;\n&#x27;);
                        }
                    }
                 },
                 //保存在element上应用的动画class名称，用于在动画后删除相关的css
                pushAnimateClassName : function(id, className){
                    if(id &amp;&amp; id!=&#x27;&#x27; &amp;&amp; className){
                        this.AnimatingClasses[id] = className;
                    }
                 },
                popAnimateClassName : function(id){
                    if(id &amp;&amp; id!=&#x27;&#x27;){
                        var name = this.AnimatingClasses[id];
                        delete this.AnimatingClasses[id];

                        return name;
                    }
                 },
                /**
                 * HTML5 CSS3关键帧动画引擎。每个动画效果都包装为一个方法，在方法中可以指定动画的播放时长、重复次数等选项。
                 * 也可以通过指定Ruler的名称，播放CSS文件中预定义的动画效果。
                 * @class JX.Animate
                 * @constructor
                 * @param {object} params 初始化参数{elems:HTML对象数组}
                 */
                init: function (params) {
                    console.info(&quot;Initializing &quot; + this.name + &quot; (&quot; + this.description + &quot;) &quot; + this.version);

                    this.initPrefix();

                    if (params &amp;&amp; params.elems) {
                        this.elems = this.elements(params.elems);
                        //console.log(this.elems);
                    }

                    return core.effects;
                },
                composeTransformPropery : function(params){
                    if(!params){
                        return;
                    }
                    var transform = &#x27;&#x27;,val;

                    for(p in params){
                        switch(p){
                            case &#x27;transform&#x27;:
                                transform += params.transform;
                                break;
                            case &#x27;perspective&#x27;:
                                val = etamina.format.toPixel(params.perspective);
                                transform +=&#x27;perspective(&#x27; + val + &#x27;)&#x27; + &#x27; &#x27;;
                                break;
                            case &#x27;translateX&#x27;:
                                val = etamina.format.toPixel(params.translateX);
                                transform +=&#x27;translateX(&#x27; + val + &#x27;)&#x27; + &#x27; &#x27;;    
                                break;
                            case &#x27;translateY&#x27;:
                                val = etamina.format.toPixel(params.translateY);
                                transform +=&#x27;translateY(&#x27; + val + &#x27;)&#x27; + &#x27; &#x27;;
                                break;
                            case &#x27;scaleX&#x27;:
                                val = params.scaleX;
                                transform +=&#x27;scaleX(&#x27; + val + &#x27;)&#x27; + &#x27; &#x27;;
                                break;
                            case &#x27;scaleY&#x27;:
                                val = params.scaleY;
                                transform +=&#x27;scaleY(&#x27; + val + &#x27;)&#x27; + &#x27; &#x27;;
                                break;
                            case &#x27;scale&#x27;:
                                val = params.scale;
                                transform +=&#x27;scale(&#x27; + val + &#x27;)&#x27; + &#x27; &#x27;;
                                break;
                            case &#x27;skewX&#x27;:
                                val = etamina.format.toDegree(params.skewX);
                                transform +=&#x27;skewX(&#x27; + val + &#x27;)&#x27; + &#x27; &#x27;;
                                break;
                            case &#x27;skewY&#x27;:
                                val = etamina.format.toDegree(params.skewY);
                                transform +=&#x27;skewY(&#x27; + val + &#x27;)&#x27; + &#x27; &#x27;;
                                break;
                            case &#x27;rotate&#x27;:
                                val = etamina.format.toDegree(params.rotate);
                                transform +=&#x27;rotate(&#x27; + val + &#x27;)&#x27; + &#x27; &#x27;;
                                break;
                            case &#x27;rotateX&#x27;:
                                val = etamina.format.toDegree(params.rotateX);
                                transform +=&#x27;rotateX(&#x27; + val + &#x27;)&#x27; + &#x27; &#x27;;
                                break;
                            case &#x27;rotateY&#x27;:
                                val = etamina.format.toDegree(params.rotateY);
                                transform +=&#x27;rotateY(&#x27; + val + &#x27;)&#x27; + &#x27; &#x27;;
                                break;
                       }

                    }
                    if(transform.length&gt;0){
                        return transform;
                    }
                    else{
                        return false;
                    };

                }
            };

        return core;
    }());


    var onDonimoGroupAnimationEnd =function(evt) {

    };




    etamina.format = {
        isNumber : function(o) {
            return (o === 0 || o) &amp;&amp; o.constructor === Number;
        },
        isString : function(o) {
            return (o === &quot;&quot; || o) &amp;&amp; (o.constructor === String);
        },
        trim : function(string){
            return String(string).replace(/^\s+|\s+$/g, &#x27;&#x27;);
        },
        toPixel : function(param){
            var val = etamina.format.fromPixel(param);
            return val+&#x27;px&#x27;;
        },
        fromPixel : function(param){
            var pxStr,
                parseNum = function (num) {
                    return num;
                },
                parseStr = function (str) {
                    var val;
                    if (str.indexOf(&quot;px&quot;) &gt; -1) {
                        val = parseInt(str, 10); // &quot;1000ms&quot;, &quot;1500ms&quot;
                    }
                    else {
                        val = parseInt(str, 10); // &quot;1000&quot;
                    }
                    return val;
                };


            switch (typeof param) {
            case &quot;number&quot;:
                pxStr = parseNum(param);
                break;
            case &quot;string&quot;:
                pxStr = parseStr(param);
                break;
            default:
                pxStr = parseStr(param);
            }
            return pxStr;
        },
        toDegree : function(param){
            var degStr = etamina.format.fromDegree(param);
            return degStr+&#x27;deg&#x27;;
        },
        fromDegree : function(param){
            var degStr,
                parseNum = function (num) {
                    return num;
                },
                parseStr = function (str) {
                    var val;
                    if (str.indexOf(&quot;deg&quot;) &gt; -1) {
                        val = parseInt(str, 10); // &quot;1000ms&quot;, &quot;1500ms&quot;
                    }
                    else {
                        val = parseInt(str, 10); // &quot;1000&quot;
                    }
                    return val;
                };


            switch (typeof param) {
            case &quot;number&quot;:
                degStr = parseNum(param);
                break;
            case &quot;string&quot;:
                degStr = parseStr(param);
                break;
            default:
                degStr = parseStr(param);
            }
            return degStr;
        },

        fromTime : function(param){
        
            //console.info(&quot;duration&quot;, params, typeof params);
            var dur,
                parseNum = function (num) {
                    return num;
                },
                parseStr = function (str) {
                    var val;
                    if (str.indexOf(&quot;ms&quot;) &gt; -1) {
                        val = parseInt(str, 10); // &quot;1000ms&quot;, &quot;1500ms&quot;
                    }
                    else if (str.indexOf(&quot;s&quot;) &gt; -1) {
                        val = parseFloat(str, 10) * 1000; // &quot;1s&quot;, &quot;1.5s&quot;
                    }
                    else {
                        val = parseInt(str, 10); // &quot;1000&quot;
                    }
                    return val;
                },
                parseObj = function (obj) {
                    var val;
                    if (obj.value) {
                        if (typeof obj.value === &quot;string&quot;) {
                            val = parseStr(obj.value);
                        }
                        else {
                            val = parseNum(obj.value); // {value: 2000}
                        }
                    }
                    return val;
                };

            switch (typeof param) {
            case &quot;number&quot;:
                dur = parseNum(param);
                break;
            case &quot;string&quot;:
                dur = parseStr(param);
                break;
            case &quot;object&quot;:
                dur = parseObj(param);
                break;
            default:
                dur = param;
            }

            //console.log(&quot;duration:&quot;, &quot;dur=&quot; + dur);
            return dur;
        },
        toMilliSecond:function(param){
            var val = etamina.format.fromTime(param);
            return val+&#x27;ms&#x27;;
        }
    };

    /**
     * 生成关键帧动画的CSS样式字符串。
     * @method buildframes
     * @param  {string} name   [关键帧动画的名称]
     * @param  {array} frames [关键帧数组]
     * @return {void}
     */
    etamina.effects.buildframes = function(name,frames)
    {
        if(!frames || frames.length&lt;2){
            return;
        }
        var 
            transform,transformOrigin,fade,shadow,styleText,
            css;

        css = &#x27;@&#x27;+etamina.prefix+&#x27;keyframes &#x27;+  name +&#x27;{\n&#x27;;

        for(var i=0, len = frames.length; i&lt;len; i++)
        {
            var f = frames[i];
            transform = etamina.composeTransformPropery(f);
            transformOrigin = (f.transformOrigin) ? f.transformOrigin:false;
            opacity = f.opacity;
            shadow = f.shadow;
            styleText=f.styleText;

            css +=                      &#x27;\t&#x27; + f.p +&#x27;{\n&#x27;;    
            css += (styleText)?         &#x27;\t\t&#x27; + f.styleText+&#x27;;\n&#x27;:&#x27;&#x27;;
            css += (transform)?         &#x27;\t\t&#x27; + etamina.prefix + &#x27;transform:&#x27; + transform + &#x27;;&#x27; + &#x27;\n&#x27; : &#x27;&#x27;;
            css += (transformOrigin) ?  &#x27;\t\t&#x27; + etamina.prefix + &#x27;transform-origin:&#x27; + transformOrigin + &#x27;;&#x27; + &#x27;\n&#x27; : &#x27;&#x27;;
            css += (&#x27;opacity&#x27; in f) ?   &#x27;\t\t&#x27; + &#x27;opacity: &#x27; + opacity + &#x27;;&#x27; + &#x27;\n&#x27; : &#x27;&#x27;;
            css += (shadow) ?           &#x27;\t\t&#x27; + etamina.prefix + &#x27;box-shadow: &#x27; + shadow + &#x27;;&#x27; + &#x27;\n&#x27; : &#x27;&#x27;;
            css +=                      &#x27;\t&#x27; + &#x27;}&#x27; + &#x27;\n&#x27;;
        }

        css += &#x27;}\n&#x27;;

        return css;    
    };

    /**
     * 返回唯一的关键帧的名称
     * @method buildUniqueKeyframeName
     * @param  {string} animType 动画类型的名称
     * @return {void}          唯一的关键帧名称
     */
    etamina.effects.buildUniqueKeyframeName = function(animType){

        return &#x27;etamina-&#x27;+animType+&#x27;-&#x27;+(new Date()).getTime() + &quot;-&quot; + Math.floor(Math.random() * 1000);
    };



    /**
     * 开始播放元素对应的CSS动画
     * @method go
     * @param  {array} elems       HTML元素id的集合
     * @param  {object} playParam   播放参数，时长、延时、重复等
     * @param  {animSetting} animSetting 动画参数，多米诺效果、回调、声音等
     * @param  {function} getKeyframe 获取动画的具体keyframe的名称和代码的函数
     * @return {void}             
     */
    etamina.effects.go = function(elems,playParam,animSetting,getKeyframe){

    //还需实现保持动画后状态的方法。

    //优化点、针对多个元素应用动画时keyframe的css可能相同。

        playParam = etamina.initPlayParam(playParam,animSetting.animType);
        if(playParam.iteration&lt;1){
            return;
        }

        var animSetting = animSetting||{},
            /*
             * domino效果中事件太多，浏览器响应不过来，
             * 可以将邻近的domino元素的动画结束事件合并到一个元素中。
             * 此变量中保存用于处理合并事件的元素id。
             * @type {[type]}
             */
            groupEventElems = animSetting.dominoGroupEventElements,
            tempEventElemGroup=[];

        var //循环变量
            elem,elemClass,keyframe, animClassName,       
            elements = etamina.getHTMLelements(elems);



        // Loop through elements
        if (elements &amp;&amp; elements.length &gt; 0) {
            for (i = 0; i &lt; elements.length; i += 1) {

                elem = elements[i];
                animSetting.index = i;

                //设置动画的回调
                etamina.animCallbackList[elem.id] = 
                    J.isFunction(animSetting.callback)?
                        {
                            hasCallback:true,
                            method:animSetting.callback,
                            params:animSetting.callbackParam
                        }
                        :false;


                //检查并设置元素的动画状态
                if(etamina.animElementList[elem.id]){
                    //忽略正在动画中的的元素。
                    continue;
                }
                etamina.animElementList[elem.id] = true;



                //获取动画的具体keyframe的名称和代码。
                keyframe = getKeyframe.call(this,elem,animSetting); 
                if(animSetting.doNotDeleteKeyframe){
                    etamina.doNotDeleteKeyframes[keyframe.name] = true;
                }

                //add css text into DOM style
                if(keyframe.css &amp;&amp; keyframe.css!=&#x27;&#x27;){
                    if(etamina.debug){
                        console.log(keyframe.css);
                    }
                    etamina.insertCSS(keyframe.css);
                }

                //prepare class for element to play the animation.
                //多米诺domino效果在此处应用。
                playParam.name = keyframe.name;
                elemClass = etamina.getAnimationClassRule(playParam,animSetting);
                //add css text into DOM style
                if(etamina.debug){
                    console.log(elemClass.css);
                }
                if(elemClass.css &amp;&amp; elemClass.css!=&#x27;&#x27;){
                    etamina.insertCSS(elemClass.css);
                }


                // Add listener to clear animation after it&#x27;s done
                //如果针对了domino效果设置了事件优化
                if(animSetting.domino &amp;&amp;
                    J.isArray(groupEventElems)){

                    tempEventElemGroup.push(elem);

                    if(groupEventElems.indexOf(elem.id)&gt;-1){

                        etamina.donimoElementGroups[elem.id] = tempEventElemGroup;
                        tempEventElemGroup=[];

                        //设置合并组的动画结束的回调事件。
                        if (etamina.prefix == &quot;-moz-&quot;) {
                            elem.addEventListener(&quot;animationend&quot;, etamina.onDonimoGroupAnimationEnd, false);
                        }
                        else {
                            elem.addEventListener(etamina.prefixJS + &quot;AnimationEnd&quot;, etamina.onDonimoGroupAnimationEnd, false);
                        }

                    }
                    else{
                    }
                }
                else{
                    etamina.donimoElementGroups[elem.id] = null;
                    //设置动画结束的回调事件。
                    if (etamina.prefix == &quot;-moz-&quot;) {
                        elem.addEventListener(&quot;animationend&quot;, etamina.onAnimationEnd, false);
                    }
                    else {
                        elem.addEventListener(etamina.prefixJS + &quot;AnimationEnd&quot;, etamina.onAnimationEnd, false);
                    }

                }
                //TODO: 是否在动画后保留结束时的状态。

                //保存elem原有的class，用于在动画后恢复。
                etamina.saveCssClass(elem);
                etamina.pushAnimateClassName(elem.id,elemClass.name)



                //apply css animation
                

                if(J.isString(animSetting.additionalClass)){
                    animClassName = elemClass.name + &#x27; &#x27; + animSetting.additionalClass;                   
                }
                else{
                    animClassName = elemClass.name
                }
                //J.dom.addClass(elem,animClassName);
                elem.className += &#x27; &#x27; + animClassName;

                if(animSetting.sound &amp;&amp; JXAnimate.Audio){

                    var delayTime = etamina.format.fromTime(playParam.delay);

                    if(delayTime&gt;0){
                        setTimeout(function(){
                            JXAnimate.Audio.playSound(animSetting.sound,animSetting.volume);
                        },delayTime);
                    }
                    else{
                        JXAnimate.Audio.playSound(animSetting.sound,animSetting.volume);
                    }
                }
                log(elem.classname);
                if(this.debug){
                    console.log(elem.className);
                }
            }       
        }

    };

    /**
     * 根据自定义的关键帧生成动画，并播放。
     * @method goWithFixFrames
     * @param  {array} elems       HTML元素id的集合
     * @param  {object} playParam   播放参数，时长、延时、重复等
     * @param  {animSetting} animSetting 动画参数，多米诺效果、回调、声音等
     * @param  {array} frames      关键帧数组
     * @return {void}             
     */
    etamina.effects.goWithFixFrames = function(elems,playParam,animSetting,frames){

        var buildKeyframe = function(elem,animSetting){
                var index = animSetting.index;
                var keyframeName = etamina.effects.buildUniqueKeyframeName(animSetting.animType);
                return {
                    name:keyframeName,
                    css: etamina.effects.buildframes(keyframeName,frames)
                };
            };
        
        etamina.effects.go(elems,playParam,animSetting,buildKeyframe);
    };

    /**
     * 播放CSS文件中预定义的关键帧动画
     * @method applyCss
     * @param  {array} elems       HTML元素id的集合
     * @param  {object} playParam   播放参数，时长、延时、重复等
     * @param  {animSetting} animSetting 动画参数，多米诺效果、回调、声音等
     * @return {void}             
     */
    etamina.effects.applyCss = function(elems,playParam,animSetting){
        var animSetting = animSetting||{};
        var keyframeName;
        //字符串，表示关键帧的名字
        if(animSetting.constructor === String &amp;&amp; animSetting.length&gt;0){
            keyframeName = animSetting;
            animSetting = {};
            animSetting.name = keyframeName;
        }
        //对象格式，读取name属性
        else if(&#x27;name&#x27; in animSetting &amp;&amp; animSetting.name.length&gt;0){
            keyframeName = animSetting.name;
        }
        else{
            return;
        }

        animSetting.animType = &#x27;applyCss&#x27;;
        animSetting.doNotDeleteKeyframe = true;

        var buildKeyframe = function(){
            return {name:keyframeName};
        };

        etamina.effects.go(elems,playParam,animSetting,buildKeyframe);
    }

    /**
     * 闪烁效果，内置Demo动画，代码演示了通过CSS样式字符串的形式定义动画。
     * @method flash
     * @param  {array} elems       HTML元素id的集合
     * @param  {object} playParam   播放参数，时长、延时、重复等
     * @param  {animSetting} animSetting 动画参数，多米诺效果、回调、声音等
     * @return {void}             
     */
    etamina.effects.flash = function(elems,playParam,animSetting){

        var animSetting = animSetting||{};

        animSetting.animType = &#x27;flash&#x27;;

        var buildKeyframe = function(){
            var keyframeName = etamina.effects.buildUniqueKeyframeName(animSetting.animType);
       
                keyframeCss = &#x27;@&#x27;+etamina.prefix+&#x27;keyframes &#x27;+  keyframeName +&#x27;{\n&#x27;+
                &#x27;0%, 50%, 100% {opacity: 1;} \n&#x27; +
                &#x27;25%, 75% {opacity: 0;}\n&#x27; +
            &#x27;}&#x27;;

            return {
                name:keyframeName,
                css:keyframeCss
            };
        };

        etamina.effects.go(elems,playParam,animSetting,buildKeyframe);

    };

    /**
     * 水平3D翻转，内置Demo动画，代码演示了通过Frame数组形式定义动画。
     * @method flipInY
     * @param  {array} elems       HTML元素id的集合
     * @param  {object} playParam   播放参数，时长、延时、重复等
     * @param  {animSetting} animSetting 动画参数，多米诺效果、回调、声音等
     * @return {void}             
     */
    etamina.effects.flipInY = function(elems,playParam,animSetting){
        var animSetting = animSetting || {}
            playParam = playParam||{};
        animSetting.animType = &#x27;flipInY&#x27;;
        playParam.toDelete = [&#x27;perspective&#x27;];

        var    frames = [
                {p:&#x27;0%&#x27;,rotateY:&#x27;90deg&#x27;,perspective:400,opacity:&#x27;0&#x27;},
                {p:&#x27;40%&#x27;,rotateY:&#x27;-10&#x27;,perspective:400},
                {p:&#x27;70%&#x27;,rotateY:&#x27;10&#x27;,perspective:400},
                {p:&#x27;100%&#x27;,rotateY:0,perspective:400,opacity:&#x27;1&#x27;}
            ];

        etamina.effects.goWithFixFrames(elems,playParam,animSetting,frames);


    };
    /**
     * 竖直3D翻转，内置Demo动画，代码演示了通过Frame数组形式定义动画。
     * @method flipInX
     * @param  {array} elems       HTML元素id的集合
     * @param  {object} playParam   播放参数，时长、延时、重复等
     * @param  {animSetting} animSetting 动画参数，多米诺效果、回调、声音等
     * @return {void}             
     */
    etamina.effects.flipInX = function(elems,playParam,animSetting){
        var animSetting = animSetting || {};
        animSetting.animType = &#x27;flipInX&#x27;;

        var    frames = [
                {p:&#x27;0%&#x27;,rotateX:&#x27;90deg&#x27;,perspective:400,opacity:&#x27;0&#x27;},
                {p:&#x27;40%&#x27;,rotateX:&#x27;-10&#x27;,perspective:400},
                {p:&#x27;70%&#x27;,rotateX:&#x27;10&#x27;,perspective:400},
                {p:&#x27;100%&#x27;,rotateX:0,perspective:400,opacity:&#x27;1&#x27;}
            ];

        etamina.effects.goWithFixFrames(elems,playParam,animSetting,frames);
    };


    /**
     * 添加自定义动画效果
     * @method addEffects
     * @param  {array} effectArray 动画效果函数数组，请参考flash,flipInX，flipInY函数编写自定义动画。
     * @return {void}             
     */
    this.addEffects = function  (effectArray) {
        
        if(J.isObject(effectArray)){
            var p,
            effect;
            for (p in effectArray){
                effect = effectArray[p];
                if(J.isFunction(effect)){
                    this[p] = effect;
                }
            };
        }
        else{
            return;
        }

    };


    var innerAnim = etamina.init(),
        _debug=false;

    var debugOn=function () {
        _debug = true;
    }
    var debugOff=function () {
        _debug = false;
    }
    var log = function (argument) {
        if(_debug == false){
            return;
        }
        console.log(argument);
    }

    J.extend(this,innerAnim);
    /**
     * 浏览器的CSS3 样式的前缀
     * @property {string} prefix 
     */
    this.prefix = etamina.prefix;
    /**
     * 浏览器的CSS3 JS方法的前缀
     * @property {string} prefixJS 
     */
    this.prefixJS = etamina.prefixJS;



/*
    this.initAudio = function (params) {
        $Audio = JXAnimate.Audio;
        $Audio.init(params);
        this.preloadAudio = $Audio.preload;
    }
*/
});
//----------------------------------------------------------------------------

    /**
     * 动画设置参数
    animSetting{
        domino: 100 , // 设置domino中间的间隔时间。 数字或字符串。100或‘100ms’
        animType: &#x27;rotateOut&#x27;, //动画类型，内部用。
        index: 1,               //序列号，内部用。
        dominoGroupEventElements: [], //保存用于处理合并事件的元素id
        callback: method,       //每个元素动画结束后的回调。
        callbackParam: object,  //回调的参数。
        doNotDeleteKeyframe: true,  //标识动画结束后是否删除关键帧CSS。
        additionalClass: &#x27;className&#x27;, //设置动画时可以同时附加其他的css类。
        sound:&#x27;soundName&#x27;,              //播放声音的名称。
        volume: &#x27;&#x27;,                     //声音音量。
    }
     * @class animSetting
     */
    /**
     * 设置domino中间的间隔时间。 数字或字符串。100或‘100ms’
     * @property {int} domino 
     */
    /**
     * 动画类型
     * @property {string} animType 
     * @private
     */
    /**
     * 序列号，用于设置domino顺序
     * @property {int} index 
     * @private
     */
    /**
     * 保存用于处理合并事件的元素id
     * @property {array} dominoGroupEventElement 
     */
    /**
     * 每个元素动画结束后的回调。
     * @property {function} callback 
     */
    /**
     * 回调参数
     * @property {object} callbackParam 
     */
    /**
     * 标识动画结束后保留关键帧CSS
     * @property {bool} doNotDeleteKeyframe
     */
    /**
     * 设置动画时可以同时附加其他的css类，动画结束后删除
     * @property {string} additionalClass 
     */
    /**
     * 播放声音的名称。
     * @property {string} sound 
     */
    /**
     * 声音音量。
     * @property {float} volume 
     */
    /**
     * CSS文件中关键帧动画的名称，尽在applyCSS方法中有效。
     * @property {string} name 
     */












    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
